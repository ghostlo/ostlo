<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2Fostlo%2F2019%2F04%2F07%2F%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[迭代开发 敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。 那么什么是&quot;迭代开发&quot;呢？迭代的英文是 iterative，直译为&quot;重复&quot;，迭代开发其实就是&quot;重复开发&quot;。 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次&quot;大开发&quot;；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次&quot;大开发&quot;变成多次&quot;小开发&quot;，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 **迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。**开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。 增量开发 迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用&quot;增量开发&quot;（incremental development）划分迭代。 所谓&quot;增量开发&quot;，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼…每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶… 增量开发加上迭代开发，才算真正的敏捷开发。 敏捷开发的好处 早期交付 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的&quot;瀑布开发模式&quot;，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。 降低风险 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？ 对于软件项目来说，先有一个原型产品，了解市场的接受程度，往往是项目成功的关键。有一本书叫做《梦断代码》，副标题就是&quot;20+个程序员，三年时间，4732个bug，100+万美元，最后失败的故事&quot;，这就是没有采用敏捷开发的结果。相反的，Instagram 最初是一个地理位置打卡 App，后来发现用户不怎么在乎地理位置，更喜欢上传照片，就改做照片上传软件，结果成了独角兽。 由于敏捷开发可以不断试错，找出对业务最重要的功能，然后通过迭代，调整软件方向。相比传统方式，大大增加了产品成功的可能性。如果市场需求不确定，或者你对该领域不熟悉，那么敏捷开发几乎是唯一可行的应对方式。 如何进行每一次迭代 虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。 具体来说，每次迭代都必须依次完成以下五个步骤。 需求分析（requirements analysis） 设计（design） 编码（coding） 测试（testing） 部署和评估（deployment / evaluation） 每个迭代大约持续2~6周。 敏捷开发的价值观 《敏捷软件开发宣言》里面提到四个价值观。 程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。 软件能够运行，优于详尽的文档。 跟客户的密切协作，优于合同和谈判。 能够响应变化，优于遵循计划。 十二条原则 该宣言还提出十二条敏捷开发的原则。 通过早期和持续交付有价值的软件，实现客户满意度。 欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。 不断交付可用的软件，周期通常是几周，越短越好。 项目过程中，业务人员与开发人员必须在一起工作。 项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。 面对面交谈是最好的沟通方式。 可用性是衡量进度的主要指标。 提倡可持续的开发，保持稳定的进展速度。 不断关注技术是否优秀，设计是否良好。 简单性至关重要，尽最大可能减少不必要的工作。 最好的架构、要求和设计，来自团队内部自发的认识。 团队要定期反思如何更有效，并相应地进行调整。 来源：阮一峰]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-面试]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2Fmysql%2F</url>
    <content type="text"><![CDATA[Mysql中有哪几种锁？ 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 Mysql中有哪些不同的表格？ 共有5种类型的表格： MyISAM Heap Merge INNODB ISAM 简述在MySQL数据库中MyISAM和InnoDB的区别 MyISAM： 不支持事务，但是每次查询都是原子的； 支持表级锁，即每次操作是对整个表加锁； 存储表的总行数； 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件； 采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。 InnoDb： 支持ACID的事务，支持事务的四种隔离级别； 支持行级锁及外键约束：因此可以支持写并发； 不存储总行数； 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制； 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。 Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？ SQL标准定义的四个隔离级别为： read uncommited ：读到未提交数据 read committed：脏读，不可重复读 repeatable read：可重读 serializable ：串行事物 CHAR和VARCHAR的区别？ 1.CHAR和VARCHAR类型在存储和检索方面有所不同 2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255 当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。 主键和候选键有什么区别？ 表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 myisamchk是用来做什么的？ 它用来压缩MyISAM表，这减少了磁盘或内存使用。 MyISAM Static和MyISAM Dynamic有什么区别？ 在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。 MyISAM Static在受损情况下更容易恢复。 如果一个表有一列定义为TIMESTAMP，将发生什么？ 每当行被更改时，时间戳字段将获取当前时间戳。 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？ 它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。 怎样才能找出最后一次插入时分配了哪个自动增量？ LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。 你怎么看到为表格定义的所有索引？ 索引是通过以下方式为表格定义的： SHOW INDEX FROM ; LIKE声明中的％和_是什么意思？ ％对应于0个或更多字符，_只是LIKE语句中的一个字符。 如何在Unix和Mysql时间戳之间进行转换？ UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令 FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令 列对比运算符是什么？ 在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。 BLOB和TEXT有什么区别？ BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。 BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。 mysql_fetch_array和mysql_fetch_object的区别是什么？ 以下是mysql_fetch_array和mysql_fetch_object的区别： mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。 mysql_fetch_object – 从数据库返回结果行作为对象。 MyISAM表格将在哪里存储，并且还提供其存储格式？ 每个MyISAM表格以三种格式存储在磁盘上： ·“.frm”文件存储表定义 ·数据文件具有“.MYD”（MYData）扩展名 索引文件具有“.MYI”（MYIndex）扩展名 Mysql如何优化DISTINCT？ DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。 SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a; 如何显示前50行？ 在Mysql中，使用以下代码查询显示前50行： SELECT*FROM LIMIT 0,50; 可以使用多少列创建索引？ 任何标准表最多可以创建16个索引列。 NOW（）和CURRENT_DATE（）有什么区别？ NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 CURRENT_DATE（）仅显示当前年份，月份和日期。 什么是非标准字符串类型？ TINYTEXT TEXT MEDIUMTEXT LONGTEXT 什么是通用SQL函数？ CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。 FORMAT(X, D)- 格式化数字X到D有效数字。 CURRDATE(), CURRTIME()- 返回当前日期或时间。 NOW（） – 将当前日期和时间作为一个值返回。 MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。 HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。 DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄 SUBTIMES（A，B） – 确定两次之间的差异。 FROMDAYS（INT） – 将整数天数转换为日期值。 MYSQL支持事务吗？ 在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。 但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。 mysql里记录货币用什么字段类型好 NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。 例如： salary DECIMAL(9,2) 在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。 因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。 mysql有关权限的表都有哪几个？ Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。 列的字符串类型可以是什么？ 字符串类型是： SET BLOB ENUM CHAR TEXT MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？ a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。 b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。 c. mysql库主从读写分离。 d. 找规律分表，减少单表中的数据量提高查询速度。 e。添加缓存机制，比如memcached，apc等。 f. 不经常改动的页面，生成静态页面。 g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 锁的优化策略 \1. 读写分离 \2. 分段加锁 \3. 减少锁持有的时间 \4. 多个线程尽量以相同的顺序去获取资源 不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。 索引的底层实现原理和优化 B+树，经过优化的B+树 主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。 什么情况下设置了索引但无法使用 以“%”开头的LIKE语句，模糊匹配 OR语句前后没有同时使用索引 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型） 实践中如何优化MySQL 最好是按照以下顺序优化： 1.SQL语句及索引的优化 \2. 数据库表结构的优化 3.系统配置的优化 4.硬件的优化 详细可以查看 阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结 优化数据库的方法 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM 使用连接(JOIN)来代替子查询 适用联合(UNION)来代替手动创建的临时表 事务处理 锁定表、优化事务处理 适用外键，优化锁定表 建立索引 优化查询语句 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面） 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。 普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。 主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。 索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。 数据库中的事务是什么? 事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。 事务特性： （1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。 （2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态 （3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， （4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 或者这样理解： 事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 SQL注入漏洞产生的原因？如何防止？ SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。 防止SQL注入的方式： 开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置 执行sql语句时使用addslashes进行sql语句转换 Sql语句书写尽量不要省略双引号和单引号。 过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。 提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。 为表中得字段选择合适得数据类型 字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text 优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型 存储时期 Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，占用8个字节得存储空间，datatime类型与时区无关 Timestamp:以时间戳格式存储，占用4个字节，范围小1970-1-1到2038-1-19，显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改timestamp列得值 Date:（生日）占用得字节数比使用字符串.储存要少，使用date只需要3个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算 Time:存储时间部分得数据 注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，在进行查找过滤可以利用日期得函数） 使用int存储日期时间不如使用timestamp类型 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题： 1.索引的目的是什么？ 快速访问数据表中的特定信息，提高检索速度 创建唯一性索引，保证数据库表中每一行数据的唯一性。 加速表和表之间的连接 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 2.索引对数据库系统的负面影响是什么？ 负面影响： 创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。 3.为数据表建立索引的原则有哪些？ 在最频繁使用的、用以缩小查询范围的字段上建立索引。 在频繁使用的、需要排序的字段上建立索引 4.什么情况下不宜建立索引？ 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。 对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等 解释MySQL外连接、内连接与自连接的区别 先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。 内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。 外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中 的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。 左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。 Myql中的事务回滚机制概述 事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。 要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚 SQL语言包括哪几部分？每部分都有哪些操作关键字？ SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。 数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等 数据操纵：Select ,insert,update,delete, 数据控制：grant,revoke 数据查询：select 完整性约束包括哪些？ 数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类： 实体完整性：规定表的每一行在表中是惟一的实体。 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 什么是锁？ 答：数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。 基本锁类型：锁包括行级锁和表级锁 什么叫视图？游标是什么？ 答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 什么是存储过程？用什么来调用？ 答：存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。 如何通俗地理解三个范式？ 答：第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。。 范式化设计优缺点: 优点: 可以尽量得减少数据冗余，使得更新快，体积小 缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化 反范式化: 优点:可以减少表得关联，可以更好得进行索引优化 缺点:数据冗余以及数据异常，数据得修改需要更多的成本 什么是基本表？什么是视图？ 答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表 试述视图的优点？ 答：(1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据； (3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供安全保护。 NULL是什么意思 答：NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。 使用IS NULL来进行NULL判断 主键、外键和索引的区别？ 主键、外键和索引的区别 定义： 主键–唯一标识一条记录，不能有重复的，不允许为空 外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值 索引–该字段没有重复值，但可以有一个空值 作用： 主键–用来保证数据完整性 外键–用来和其他表建立联系用的 索引–是提高查询排序的速度 个数： 主键–主键只能有一个 外键–一个表可以有多个外键 索引–一个表可以有多个唯一索引 你可以用什么来确保表格里的字段只接受特定范围里的值? 答：Check限制，它在数据库表格里被定义，用来限制输入该列的值。 触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。 说说对SQL语句优化有哪些方法？（选择几条） （1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。 （2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。 （3） 避免在索引列上使用计算 （4）避免在索引列上使用IS NULL和IS NOT NULL （5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 （6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 （7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描]]></content>
      <categories>
        <category>数据库</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2F%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[什么是并发： 并发是指多个执行任务同时、在一个较长的时间段内可认为是并行被执行。 什么是并行： 并行就是指多个任务同时执行 什么是竞态： 字面意思是竞争，并发的执行单元对共享资源（硬件资源和软件上的全局变量，静态变量等）的访问容易发生竞态。 对于一个虚拟的字符设备驱动，假设一个执行单元A对其写入300个字符‘a’，而另一个执行单元B对其写入300个字符‘b’，第三个执行单元读取所有字符。如果A、B被顺序串行执行那么C读出的则不会出错，但如果A、B并发执行，那结果则是我们不可料想的。 竞态发生的情况 对称多处理器（SMP）的多个CPU： SMP是一种紧耦合、共享存储的系统模型，它的特点是多个CPU使用共同的系统总线，因此可以访问共同的外设和存储器。 单CPU内进程与抢占它的进程： Linux 2.6的内核支持抢占调度，一个进程在内核执行的时候可能被另一高优先级进程打断。 中断（硬中断、软中断、tasklet、低半部）与进程之间：中断可以打断正在执行的进程，处理中断的程序和被打断的进程间也可能发生竞态。 竞态的解决办法 解决竞态问题的途径是保证对共享资源的互斥访问。访问共享资源的代码区域称为临界区，临界区要互斥机制保护。Linux设备驱动中常见的互斥机制有以下方式：中断屏蔽、原子操作、自旋锁和信号量等。 临界区 Most readers would agree that this scenario is best avoided. Therefore, the core rule that applies to spinlocks is that any code must, while holding a spinlock, be atomic.It cannot sleep; in fact, it cannot relinquish the processor for any reason except toservice interrupts (and sometimes not even then). 互斥锁和自旋锁、信号量的区别 互斥锁和互斥量 在我的理解里没啥区别，不同叫法。广义上讲可以值所有实现互斥作用的同步机制。狭义上讲指的就是mutex这种特定的二元锁机制。互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的 。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。 信号量（semaphore） 是一种更高级的同步机制，mutex（互斥锁） 可以说是 semaphore（信号量） 在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。 程序运行状态 开始 运行 就绪 阻塞 结束 互斥锁：常用，使用后需要的程序进入就绪态，通常情况下锁操作失败会将该线程睡眠等待锁释放时被唤醒 自旋锁：相比一般的互斥锁会在等待期间放弃cpu，使用硬件提供的swap指令或test_and_set指令实现，自旋锁则是不断循环并测试锁的状态，这样就一直占着cpu。所以相比于自旋锁和信号量，在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒休眠的线程。可以联想到程序查询中断方式。 递归锁：严格上讲递归锁只是互斥锁的一个特例，同样只能有一个线程访问该对象，但允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作，直到一个线程所有的acquire都被release，其他的线程才能获得资源。 windows下的临界区默认是支持递归锁的，而linux下的互斥量则需要设置参数PTHREAD_MUTEX_RECURSIVE_NP，默认则是不支持。 读写锁(rwlock)：高级别锁，区分读和写，符合条件时允许多个线程访问对象。处于读锁操作时可以允许其他线程和本线程的读锁， 但不允许写锁， 处于写锁时则任何锁操作都会睡眠等待；常见的操作系统会在写锁等待时屏蔽后续的读锁操作以防写锁被无限孤立而等待，在操作系统不支持情况下可以用引用计数加写优先等待来用互斥锁实现。 读写锁适用于大量读少量写的环境，但由于其特殊的逻辑使得其效率相对普通的互斥锁和自旋锁要慢一个数量级；值得注意的一点是按POSIX标准 在线程申请读锁并未释放前本线程申请写锁是成功的，但运行后的逻辑结果是无法预测 另外注意并发时候stl的改变]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务的四大特性以及事务的隔离级别]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[来源 如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性： 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。 持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题： 脏读 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下 123update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’; 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。 不可重复读 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了…… 虚读(幻读) 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 隔离级别 现在来看看MySQL数据库为我们提供的四种隔离级别： ① Serializable (串行化) 可避免脏读、不可重复读、幻读的发生。 ② Repeatable read (可重复读) 可避免脏读、不可重复读的发生。 ③ Read committed (读已提交) 可避免脏读的发生。 ④ Read uncommitted (读未提交) 最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。 在MySQL数据库中查看当前事务的隔离级别： 1select @@tx_isolation; 在MySQL数据库中设置事务的隔离 级别： 123set [glogal | session] transaction isolation level 隔离级别名称;set tx_isolation=’隔离级别名称;’ 例1：查看当前事务的隔离级别： 例2：将事务的隔离级别设置为Read uncommitted级别： 或： 记住：设置数据库的隔离级别一定要是在开启事务之前！ 如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段： 在JDBC中设置隔离级别的部分代码： 后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 参考博客： http://www.zhihu.com/question/23989904 http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html http://www.cnblogs.com/xdp-gacl/p/3984001.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试--抛棋子]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2F%E9%9D%A2%E8%AF%95-%E6%8A%9B%E6%A3%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[问题 有一个一百层高的大厦，从这个大厦的某一层扔下棋子恰好就会碎（称这一层为临界层）。请你用手中的两个玻璃围棋子，找出一个最优的策略来得出那个最优层。 分析：题目要求策略最优，因而要使得在最坏的情况下投掷的总次数 $$T_{max}$$ 最少。首先考虑只有一个棋子的情况，条件若为多个棋子则可转化为一个棋子的情况。 解答 一个棋子 棋子必须在临界层扔下的时候碎，所以唯一的策略是从1层往上逐层投掷，此时$$T_{max} =99$$，临界层为99层或100层（因为题目告诉100层肯定会碎，如果99层没碎，那表示临界层即为100） 两个棋子 利用多的这个棋子缩小查找的范围，因而把100层分成若干段：先利用一个棋子来确定临界层所在的段，再利用另一个棋子确定临界层，总的投掷次数等于确定临界段的次数$$n_{1}$$和确定临界层的次数$$n_{2}$$的和 现把100层平均分成n段（n是100的正因数），有$$T_{max}= (n-1) + \frac{100}{n-1} = n + \frac{100}{n}-2$$由均值不等式可知n=10时，$$T_{max} =18$$为最小值，此时临界段为第80~90层，临界层为第89层。如果把100层分成12段$$(100=9\times 11+1)$$：19,1018,…91~99,100,与上述n=10的情况相比虽然每段的层数在减少（从而$$n_{1}$$在减少），但所分的段数在增加（从而$$n_{2}$$在增加），因而$$T_{max}$$并没有减少。如果把100层分成其他段（比如9段：$$100=12\times 8+4$$，情况也是如此. 根据上面的讨论，如何把100层合理地分段是关键。上述对100层所分段数的调整并没有使得$$T_{max} =18$$减少的原因在于每段包含的层数比较均匀(图1)，因而出现$$n_{1}$$和$$n_{2}$$此消彼长的情况。鉴于此我们做出以下方式的调整： 把100层分成若干段，从下往上，每段的层数逐渐少1（图2），这样就使得在最坏的情况下，$$n_{1}$$增加1的同时$$n_{2}$$减少1，因而$$n_{1}$$与$$n_{2}$$的总和不变（等于第一段的层数n）,为确定n的值，只需要解不等式$$n+(n-1)+(n-2)+…+1\geq 100$$,从而得到n=14 从第14层开始扔第一枚棋子，如果没有碎则从第14+13=27层开始扔，如果还没有碎则从14+13+12=39层开始扔，以此类推，此时$$T_{max} =14$$,临界层可为第27层，第39层，…第99层。 拓展： 对于m层楼高，k个球的扔棋子问题，又该怎么做？ 答案是用动态规划的思想：如果是三个棋子，100层楼，我扔了一次棋子碎了以后，就变成2个棋子的问题了，因此可以利用上面的结果： （x∗(x−1)/2+((x−1)∗(x−2)/2)+…+3+1&gt;=100.（x*(x-1)/2+((x-1)*(x-2)/2)+…+3+1&gt;=100. （x∗(x−1)/2+((x−1)∗(x−2)/2)+…+3+1&gt;=100. 推广 从上面的讨论可以发现此题的关键是（高阶）等差数列： 两个棋子：1 2 3 4 5…$$\sum_{i=1}{n}{C_{i}{1} \geq }100$$! 三个棋子：1 3 6 10 15… $$\sum_{i=2}{n}{C_{i}{2} }\geq 100$$ 因而我们还可以考虑大楼有m层，棋子有k个的情况 $$\sum_{ i=k}{n}{C_{i}{k} } \geq m$$ 算法证明：对 $$m$$ 层楼，k个棋子的问题，存在复杂度为 $$O(\sqrt[y]{m})$$ 的算法。 thanks]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>建模</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie 与 session 的区别]]></title>
    <url>%2Fostlo%2F2019%2F04%2F04%2Fcookie-%E4%B8%8E-session-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[原文链接：mp.weixin.qq.com 本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有一个更深入的了解，并对自己的开发工作中灵活运用带来启示。 cookie机制 Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。 具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。 session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。 session机制 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。 Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。 不同 1、存取方式的不同 Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。 而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 2、隐私策略的不同 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。 假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。 3、有效期上的不同 使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。 由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。 4、服务器压力的不同 Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。 而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。 5、浏览器支持的不同 Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。 假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。 假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干） 6、跨域支持上的不同 Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。 仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[同步异步阻塞非阻塞]]></title>
    <url>%2Fostlo%2F2019%2F04%2F04%2F%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[同步： 所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事 异步： 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕 阻塞： 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。 有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。 非阻塞： 非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 再简单点理解就是： 同步，就是我调用一个功能，该功能没有结束前，我死等结果。 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞 阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回 综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 安装]]></title>
    <url>%2Fostlo%2F2019%2F04%2F04%2F%E5%AE%89%E8%A3%85-Hexo%2F</url>
    <content type="text"><![CDATA[安装 首先安装如下两个包 Node.js Git 安装好之后初次运行Git需要做一些配置： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 文档 npm安装时改源 npm 安装报错 rollbackFailedOptional verb npm-session 解决办法 npm config set registry http://registry.npm.taobao.org 建站 Hexo安装好了之后，就开始进行建站。打开终端cd到桌面并使用如下命令即可建好 hexo init name cd name 常用参数 clean Remove generated files and cache. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. new Create a new post. server Start the server. deploy注意事项 1:排查-&gt;是否安装一下hexo-deployer-git这个模块 没有安装:npm install hexo-deployer-git --save使用指令安装 2:排查-&gt;_config.yml 这个文件的deploy写了没有;写全了没有 我的就是因为_config.yml中deploy下的type等前面没有空格导致。。。。。 hexo d 提示You should configure deployment settings in _config.yml first! 123deploy: type: repo: hexo d/deploy 时遇到问题再试一次，可能是用户名密码没有来得及输入，， 主题 next主题 deploy后github上未显示主题 If your site is put in a subdirectory, set url as ‘http://yoursite.com/child’ and root as ‘/child/’ url: https://ghostlo.github.io/ostlo root: /ostlo/ 后续 后续的修改只需要重复第5步就可以了，代码如下： 1234cd 本地库目录git add .git commit -m &quot;版本日志&quot;git push -u origin master Hexo 配置1 Hexo 配置2 GitHub还有很多好功能有待开发，善于利用搜索引擎，have fun~]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
