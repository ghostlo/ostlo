<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go学习（二）]]></title>
    <url>%2Fostlo%2F2019%2F04%2F22%2FGo%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[Go语言特点 没有对象，没有继承多态，没有泛型，没有try/catch 有接口，函数是变成，csp并发模型 变量类型 1234bool,string(u)int,(u)int8,(u)int16,(u)int32,(u)int64,uintptrbyte,runefloat32,float64,complex64,complex128 rune是个字符型（char），与utf-8与unicode编码接轨，是32位 complex64 float32+float32 complex128 float64+float64 在使用格式化说明符时，可以使用 %v 来表示复数，但当你希望只表示其中的一个部分的时候需要使用 %f。 类型转换是强制的，没有隐式变量转换 当进行类似 a32bitInt = int32(a32Float) 的转换时，小数点后的数字将被丢弃。这种情况一般发生当从取值范围较大的类型转换为取值范围较小的类型时，或者你可以写一个专门用于处理类型转换的函数来确保没有发生精度的丢失。 123456789101112131415161718//从 int 型转换为 int8：func Uint8FromInt(n int) (uint8, error) &#123; if 0 &lt;= n &amp;&amp; n &lt;= math.MaxUint8 &#123; // conversion is safe return uint8(n), nil &#125; return 0, fmt.Errorf("%d is out of the uint8 range", n)&#125;//从 float64 转换为 int：func IntFromFloat64(x float64) int &#123; if math.MinInt32 &lt;= x &amp;&amp; x &lt;= math.MaxInt32 &#123; // x lies in the integer range whole, fraction := math.Modf(x) if fraction &gt;= 0.5 &#123; whole++ &#125; return int(whole) &#125; panic(fmt.Sprintf("%g is out of the int32 range", x))&#125; 对于整数和浮点数，你可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀： 12i++ -&gt; i += 1 -&gt; i = i + 1i-- -&gt; i -= 1 -&gt; i = i - 1 同时，带有 ++ 和 -- 的只能作为语句，而非表达式，因此 n = i++ 这种写法是无效的，其它像 f(i++) 或者 a[i]=b[i++] 这些可以用于 C、C++ 和 Java 中的写法在 Go 中也是不允许的 在运算时 溢出 不会产生错误，Go 会简单地将超出位数抛弃。如果你需要范围无限大的整数或者有理数（意味着只被限制于计算机内存），你可以使用标准库中的 big 包，该包提供了类似 big.Int 和 big.Rat 这样的类型 if 1234567891011121314151617181920package mainimport ( "fmt" "io/ioutil")func main() &#123; const filename="trans/abc.txt" if contents, err := ioutil.ReadFile(filename) ; err!=nil&#123; fmt.Println(err) &#125;else&#123; fmt.Printf("%s\n",contents) fmt.Println(contents) &#125;&#125;/*abc[97 98 99]*/ switch switch会自动break，除非使用fallthrough for 不需要括号，条件里可以省略初始条件，结束条件，递增表达式，另外for没有小括号 死循环 123for &#123;&#125; iota 1234567891011121314151617181920type ByteSize float64const ( _ = iota // 通过赋值给空白标识符来忽略值 KB ByteSize = 1&lt;&lt;(10*iota) MB GB TB PB EB ZB YB)type BitFlag intconst ( Active BitFlag = 1 &lt;&lt; iota // 1 &lt;&lt; 0 == 1 Send // 1 &lt;&lt; 1 == 2 Receive // 1 &lt;&lt; 2 == 4)flag := Active | Send // == 3 可变函数列表 1234567func sumArgs(value ...int) int&#123; sum:=0 for i:= range values&#123; sum+=values[i] &#125; return sum&#125; 返回值写最后 可以返回多个值 函数可以作为参数 没有默认参数 可以选参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( "fmt" "math" "reflect" "runtime")func eval(a,b int, op string)(int, error)&#123; switch op &#123; case "+": return a+b,nil case "-": return a-b,nil case "*": return a*b,nil case "/": q, _ := div(a,b) return q,nil default: return 0,fmt.Errorf( "unsupported operation:%s",op) &#125;&#125;func div(a,b int)(q,r int)&#123; return a/b, a%b&#125;func apply(op func(int,int) int, a,b int)int &#123; p:=reflect.ValueOf(op).Pointer() opName := runtime.FuncForPC(p).Name() fmt.Printf("Calling function %s with args: "+"(%d %d)\n",opName,a,b) return op(a,b)&#125;func pow(a,b int) int &#123; return int(math.Pow(float64(a),float64(b)))&#125;func sum (numbers ... int) int&#123; s:=0 for i:=range numbers&#123; s+=numbers[i] &#125; return s&#125;func main() &#123; if result,err := eval(3,4,"x"); err!=nil&#123; fmt.Println("Error",err) &#125;else &#123; fmt.Println(result) &#125; q, r :=div(13,3) fmt.Println(q,r) fmt.Println(apply(func(a int, b int) int &#123; return int(math.Pow( float64(a),float64(b))) &#125;,3,4)) fmt.Println(apply(pow,3,3)) fmt.Println(sum(1,2,4,12 ,3))&#125;/*Error unsupported operation:x4 1Calling function main.main.func1 with args: (3 4)81Calling function main.pow with args: (3 3)2722*/ 指针 go函数是传值 12345678910package mainimport "fmt"func swap(a,b *int) &#123; *a,*b=*b,*a&#125;func main() &#123; a,b :=3,4 swap(&amp;a,&amp;b) fmt.Println(a,b)&#125; 12345678910package mainimport "fmt"func swap(a,b int)(int,int) &#123; return b,a&#125;func main() &#123; a,b :=3,4 a,b = swap(a,b) fmt.Println(a,b)&#125; 数组 可以用_省略一个值 123456789101112131415package mainimport "fmt"func main() &#123; var arr1 [5]int arr2 := [3]int&#123;1,3,5&#125; arr3 := [...]int&#123;2,4,6,8,10&#125; var grid [4][5]int fmt.Println(arr1,arr2,arr3) fmt.Println(grid) for i,v:=range arr3&#123; fmt.Println(i,v) &#125;&#125; 数组传入函数会拷贝 一般使用切片 切片 内部是一个视图 s1[4]不存在，但slice可以view取出来 不超过cap就可以view扩展出来 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport "fmt"func updateSlice(s []int) &#123; s[0]=100&#125;func main() &#123; arr := [...]int&#123;0,1,2,3,4,5,6,7&#125; fmt.Println(arr[2:6]) fmt.Println(arr[:6]) fmt.Println(arr[2:]) fmt.Println(arr[:]) s1:=arr[2:] fmt.Println(s1) updateSlice(s1) fmt.Println(s1) s2:=arr[:] fmt.Println(s2) updateSlice(s2) fmt.Println(s2) s3 := append(s2,10) s4 := append(s3,11) s5 := append(s4,12) fmt.Println("s3, s4, s5 = ",s3,s4,s5) fmt.Println("arr =", arr)&#125;/*[2 3 4 5][0 1 2 3 4 5][2 3 4 5 6 7][0 1 2 3 4 5 6 7][2 3 4 5 6 7][100 3 4 5 6 7][0 1 100 3 4 5 6 7][100 1 100 3 4 5 6 7]s3, s4, s5 = [100 1 100 3 4 5 6 7 10] [100 1 100 3 4 5 6 7 10 11] [100 1 100 3 4 5 6 7 10 11 12]arr = [100 1 100 3 4 5 6 7]*/ 1234567891011121314151617181920212223242526package mainimport "fmt"func printSlice(s []int)&#123; fmt.Printf("len=%d, cap=%d\n", len(s), cap(s))&#125;func main() &#123; var s[] int for i:=0;i&lt;100;i++&#123; printSlice(s) s=append(s,2*i+1) &#125; fmt.Println(s) s1:=[]int&#123;2,4,6,8&#125; printSlice(s1) s2:=make([]int ,16) s3:=make([]int ,10 ,32) printSlice(s2) printSlice(s3) fmt.Println("Copying slice") copy(s2,s1) printSlice(s2) fmt.Println("Deleting slements from slice") s2=append(s2[:3],s2[4:]...) printSlice(s2)&#125; Map 创建 make(map[string]int) key不存在时，获取value类型的初始值 value,ok:=m[key]来判断是否存在key delete删除一个key range遍历 len获取元素个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport "fmt"func main() &#123; m := map[string]string&#123;//hash map 无序 "name":"ccmouse", "course":"golang", "site":"imooc", "quality":"notbad", &#125; m2:=make(map[string]string)//m2==empty map var m3 map[string]int//m3==nil fmt.Println(m,m2,m3) for k,v:=range m&#123; fmt.Println(k,v) &#125; fmt.Println("Getting values") courseName,ok:=m["course"] fmt.Println(courseName,ok) if causeName,ok:=m["cause"];ok&#123; fmt.Println(causeName) &#125;else &#123; fmt.Println("Key dosen't exist") &#125; fmt.Println("Deleting values") name,ok:=m["name"] fmt.Println(name,ok) delete(m,"name") name,ok=m["name"] fmt.Println(name,ok)&#125;/*map[course:golang name:ccmouse quality:notbad site:imooc] map[] map[]site imoocquality notbadname ccmousecourse golangGetting valuesgolang trueKey dosen't existDeleting valuesccmouse true false*/]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go学习（一）]]></title>
    <url>%2Fostlo%2F2019%2F04%2F21%2FGo%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[安装 下载安装包 地址： https://golang.org/dl/ 安装包的位置一般是默认在usr/local/go 配置环境变量 1、打开终端输入cd ~进入用户主目录; 2、输入ls -all命令查看是否存在.bash_profile; 3、存在既使用vim .bash_profile 打开文件; 4、输入 i 进入vim编辑模式； 5、输入下面代码， 其中 GOPATH: 日常开发的根目录。GOBIN:是GOPATH下的bin目录。 12345export GOPATH=/Users/longxiansheng/goexport GOBIN=$GOPATH/binPATH=\$PATH:\$GOBIN 这里列举几个最为重要的环境变量： $GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。 为了区分本地机器和目标机器，你可以使用 GOHOSTOS 和 GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（GOOS 和 GOARCH）一样。 $GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节。 安装Intellij golang 设置SDK路径为usr/local/go go run/ go install/ go build / go get的区别 go run 运行当个.go文件 go install 在编译源代码之后还安装到指定的目录 go build 加上可编译的go源文件可以得到一个可执行文件 go get = git clone + go install 从指定源上面下载或者更新指定的代码和依赖，并对他们进行编译和安装 调试 如果你不想使用调试器，你可以按照下面的一些有用的方法来达到基本调试的目的： 在合适的位置使用打印语句输出相关变量的值（print/println 和 fmt.Print/fmt.Println/fmt.Printf）。 在 fmt.Printf 中使用下面的说明符来打印有关变量的相关信息： %+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息 %T 打印某个类型的完整说明 使用 panic 语句（第 13.2 节）来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。 使用关键字 defer 来跟踪代码执行过程（第 6.4 节）。 编写程序 特性 LALR 是 Go 语言的语法标准，你也可以在 src/cmd/internal/gc/go.y 中查看到，这种语法标准在编译时不需要符号表来协助解析。 许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。 为了简化设计，不支持函数重载和操作符重载 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换 Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型 不支持动态加载代码 不支持动态链接库 不支持泛型 通过 recover 和 panic 来替代异常机制（第 13.2-3 节） 不支持静态变量 关于 Go 语言开发团队对于这些方面的讨论，你可以通过 Go 常见问题 页面查看。 格式化 Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：go fmt（gofmt）。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 gofmt 来格式化你的代码。 在格式化输出时，你可以使用 %t 来表示你要输出的值为布尔型。 在格式化字符串里，%d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0d 用于规定输出定长的整数，其中开头的数字 0 是必须的。 %n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f [格式化代码-gitbook][https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/03.5.md] [与c,c++交互][https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/03.9.md] 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var Go 语言还有 36 个预定义标识符 append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 可见性规则 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。 你可以通过使用包的别名来解决包名之间的名称冲突 1234567package mainimport fm "fmt" // alias3func main() &#123; fm.Println("hello, world")&#125; 当一个变量被声明之后(var)，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate。 首字母大写表示全局的。 123456fmt.Println（"hello, world"）//以下函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 fmt 中的相关函数。printprintln：print("ABC")println("ABC")println(i) 类型转换 在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）： 1valueOfTypeB = typeB(valueOfTypeA) 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 常量的定义格式：const identifier [type] = value，例如： 1const Pi = 3.14159 在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 显式类型定义： const b string = &quot;abc&quot; 隐式类型定义： const b = &quot;abc&quot; 12var n intf(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。 正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出 声明变量的一般形式是使用 var 关键字：var identifier type。 Go 编译器的智商已经高到可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程。因此，你还可以使用下面的这些形式来声明及初始化变量： 123var a = 15var b = falsevar str = "Go says hello to the world!" 或： 1234567var ( a = 15 b = false str = "Go says hello to the world!" numShips = 50 city string) 你可以通过 &amp;i 来获取变量 i 的内存地址（第 4.9 节），例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。 在 Go 语言中，指针（第 4.9 节）属于引用类型，其它的引用类型还包括 slices（第 7 章），maps（第 8 章）和 channel（第 13 章）。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。 变量的类型也可以在运行时实现自动推断，例如： 12345var ( HOME = os.Getenv("HOME") USER = os.Getenv("USER") GOROOT = os.Getenv("GOROOT")) 这种写法主要用于声明 包级别 的全局变量，当你在函数体内声明 局部变量 时，应使用简短声明语法 :=(即只能在函数体内用)，例如： 1a := 1 打印 函数 Printf 可以在 fmt 包外部使用，这是因为它以大写字母 P 开头，该函数主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数： 1func Printf(format string, list of variables to be printed) 这个格式化字符串可以含有一个或多个的格式化标识符，例如：%..，其中 .. 可以被不同类型所对应的标识符替换，如 %s 代表字符串标识符、%v 代表使用类型的默认输出格式的标识符。这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加，如果参数超过 1 个则同样需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。 函数 fmt.Print 和 fmt.Println 会自动使用格式化标识符 %v 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。例如： 1fmt.Print("Hello:", 23) 将输出：Hello: 23。 如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a： 1234func main() &#123; var a string = "abc" fmt.Println("hello, world")&#125; 尝试编译这段代码将得到错误 a declared and not used。 此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用 fmt.Println(&quot;hello, world&quot;, a) 会移除错误。 同一类型的多个变量可以声明在同一行，如： 1var a, b, c int (这是将类型写在标识符后面的一个重要原因) 多变量可以在同一行进行赋值，如： 1a, b, c = 5, 7, "abc" 上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用： 1a, b, c := 5, 7, "abc" 右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 &quot;abc&quot;。 这被称为 并行 或 同时 赋值。 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a。 (在 Go 语言中，这样省去了使用交换函数的必要) 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习]]></title>
    <url>%2Fostlo%2F2019%2F04%2F15%2FC-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[转载至： 天千 CSDN专家博主，西安邮电大学硕士研究生，BAT某厂C研发工程师，热爱Linux内核、C、喜欢写博客。 如何学好 Linux、C++，并搞定 BAT 面试gitbook.cn C++从小白到入门 C++我是从研究生入学前的二个月开始学习，基本算是零基础吧，就大学那会学了一些C的知识，经常写一个程序一堆&quot;烫烫烫&quot;，真的是到了本科毕业还没搞懂C语言。然后在这个二个月我开窍了，突然发现对C语言融汇贯通了， 而这一切要归功于《C和指针》这本书，总结一下，我认为C语言要学好必须理解三个概念。 什么是指针?，指针和数组的关系。 程序分为哪几个段，能说清楚全局变量，局部变量，静态变量等分别属于哪个段，各个段的特点是什么? C语言的编译和链的接过程 真心不推荐在Windows上来学习C语言，因为它屏蔽了太多的细节，而这些细节却又是C程序员不可或缺的一部分。C语言这个阶段过去后，我开始学习Linux C系统编程这个部分，最开始接触的一本书就是《Unix/Linux编程实践教程》强力推荐给大家，这本书会给你介绍如何通过man手册来帮助编程，如何去实现who、cat、ls、ps等系统命令。通过这本书的学习会让你对Linux上很多的原理有一个深刻的认识。 这本书学完后我就开始看UNP和APUE，其中APUE我并不推荐给大家，我推荐给大家的是《Linux/UNIX系统编程手册》这本书的内容更全面，更新。建议大家在看这些书的时候可以做详细的笔记和代码练习，在我的博客上就有我总结的文章。系统编程ok后，就要重点看UNP了，看这本书的时候要找重点看，里面有的章节已经过时了，还有一些章节对于我们目前来说用途并不大，比如STCP的部分。对于这本书重点有三个部分。 各个socket API的对应到OS，做了哪些事情，比如connect后，做了哪些事情?，accept呢?，什么是RST报文?，什么是SIGPIPE，如何触发的? 网络IO模型，同步和异步，阻塞和非阻塞的概念，Linux上各种网络IO模型的优缺点对比，epoll、select、信号驱动IO等 服务器的网络编程模型，多线程、多进程、线程池等，各自优缺点 在我的博客上也有一篇文章介绍了相关的内容，学完这个后，剩下的就靠多实践和多读一些开源的项目来积累自己的经验了，这里推荐cjson、webbench、Tinyhttpd等，代码量都不大，很容易读懂，在读懂的基础上可以进行适当的改造和重写。 C语言和Linux系统编程这个部分结束后，就要开始踏入C的世界了，自从C11出来后，我觉得C易学了，但是苦于现存的老的C代码还是有很多，所以我们不得不去学习C98相关的知识，这里我推荐《C primer》一书，注意是C++ primer，不是《C++ primer plus》我看书的方法都比较老套，第一遍力求看懂，第二遍开始抄代码，练习，第三遍开始总结写博客。所以这本书我前前后后看了大半年， 后面又看了C编程思想上册，Effective C、深度理解C对象模型、Exceptional C、深入理解C11等经典书籍，看书的模式基本上都是二到三遍，通过抄书上的代码和写博客来加深记忆。看完这些书说真的，我觉得我的C还只是一个小白，我真正蜕变要从读《Linux C服务端编程》陈硕的这本书开始，通过这本书我觉得我的C水平有了一个质的飞跃。我理解C++有以下几个要点(只是部分): RAII，这个很重要，是C的核心，很多学习了C的人都不知道RAII 值语义和对象语义，这个决定了你如何写好一个C++类 对象的生命周期，类的生命周期要清晰 智能指针，现代C++编程几乎不太可能出现delete语句，内存泄漏的问题真的很少会出现 各种STL和C的一些坑，比如迭代器遍历过程中如何删除元素、std::list的size接口的复杂度居然是O(N)（C11已经修正）等等 善用std::bind和std::function 基于对象编程和面向对象编程的区别 移动语义很重要 Lambda的捕获表达式 搞清楚C++的三五法则 std::string的实现方式，是否是线程安全的 std::map和std::set的底层数据结构等 到了这个阶段后我就开始找工作了，上面的全部过程花费了研究生二年的时间，后来找到了某BAT实习的工作后，我就一边实习，一边读《Effective Modern C++》，这本书我重点推荐给大家，在我的博客上也有全部的总结，这本书讲了很多C++11种的一些实现细节、坑以及建议。最后推荐一些linux内核相关的书籍和学习方法 《深入理解Linux内核架构》 《Linux环境编程 从应用到内核》 http://lwn.net 重点找自己感兴趣的模块来看，比如我就对文件系统 通过内核模块来探索，不能只看代码不练习 网络上有很多从头开始编写一个内存文件系统的文章，在我的博客上也有一个系列讲解Linux内核模块编程入门的文章，通过编写Linux内核模块可以做很多有趣的事情，比如系统调用拦截、网络拦截、做安全审计等等，通过编写内核模块可以提高对Linux内核学习的兴趣。 BAT求职之路 研究生阶段我主要面试了阿里巴巴、腾讯、网易都是C研发工程师，只有网易拿到的是实习的Offer，其他的都是拿到了实习和正式的Offer，就C这个岗位来说，阿里巴巴的要求明显高于腾讯和网易，网易的C面试相对容易一些，问的很基础，感觉就是走个过场，都没问什么太难的问题，可能是因为是招实习吧，腾讯的C面试偏基础从OS、网络、编译原理、算法等。问题都不太难，问的比较广，阿里巴巴更侧重知识面、底层原理、解决问题的能力等。我阿里巴巴一共面了五面，问了很多C++、算法、Linux内核等知识，在整个求职过程中，我做了以下几件事: 刷leetcode的题目 从牛客网和google上搜集面试题，分门别类的进行整理，每天都回顾一下 拓宽自己的知识面，学习一些新的知识，比如当时流行的docker，更侧重学习其原理 加深自己对一些底层的OS知识的理解，比如epoll的原理、docker的cgroup机制和namespace机制的实现、文件系统VFS的实现、Linux信号、管道等的实现。 整理面试题和学习一些底层的OS知识对我整个面试过程中帮助很大，正常情况下如果你只学习Java或者C是很难拿到阿里巴巴的Offer，阿里巴巴对应届生的知识面、知识的理解程度要求还是比较高的，在我的整个C面试过程中，问的最多的就是IO复用、智能指针、内存泄漏的问题如何解决、如何排查Load高的问题、Linux内核相关的知识等，而这些问题对我来说早已得心应手，在搜集面试题的时候很多问题都是反复被提及到的，我只需要好好总结即可。 另外一点就是大家在准备面试题的时候不能只记一个结论，多问问为什么，举个例子，TCP/IP的三次握手和四次挥手的过程是什么样的，我们不光光要知道这个问题的结论，还要知道为什么是三次握手，四次挥手，为什么不是二次？当被问及到epoll、select的区别时，你应该从使用方法、可移植性、性能、优缺点、内核实现等多个方面分析和总结。而不是简简单单的就提及一个优缺点就完事了。 你擅长的地方你应该多多引导你的面试官去问。 工作心得 在公司实习了大约1年，今年七月份正式入职，在这整个过程中我也零散的做了很多小需求，对C++的理解更加深刻，尤其是对软件工程有了一个新的理解，在此我想分享给大家。 要有造轮子的能力，但是不要轻易的去造轮子 单元测试的重要性，通过单元测试也可以提高程序员的信心，为了更好的写单测，会逼迫我们将模块之间的耦合降到最低，这样可以方便单测。 写易读的、可维护的代码 Google的C++编程规范，每一条都值得细细品味 Chromium开源项目有很多值得我们借鉴的地方 画UML图是程序员的基本素质，要有好的设计，设计要做评审 CodeReview一定要有的 类名和变量名的易读性 可能对于很多人来说编码规范、CodeReview、UML、单测好像都是说说而已，我起初也是这么认为，感触并不是很深刻，直到我的同事开始带我的时候，我自己亲身去体验的时候才发现这其中奥妙无穷， 我们团队使用Chromium的base库作为自己的基础库，编码规范、全都follow Chromium，至于为什么不用boost，我的理由则是，boost是一个我无法驾驭的怪兽，而chromium的base库是我可以驾驭的，可以打组合拳，代码的稳定性已经经过上亿人的考验，值得我们信赖。推荐大家看看chromium的base库，源代码很易读。通过阅读它的代码可以学习到很多知识。推荐一本书给大家《C++ API设计》，讲解了很多软件工程、设计层面的知识。 总结 上面说了很多，更侧重分享了我的学习经历，和一些感悟，可能我说的比较简单，实际上理解上面这些东西，是存在一个过程的，是一个从量变到质变的过程，在整个过程中我理解到，学习要坚持，不是一蹴而就的，要经历量变到质变的过程。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>语言学习</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lfu and lru]]></title>
    <url>%2Fostlo%2F2019%2F04%2F14%2Fsuanfa-1%2F</url>
    <content type="text"><![CDATA[leetcode 146 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 这道题让我们实现一个LRU缓存器，LRU是Least Recently Used的简写，就是最近最少使用的意思。那么这个缓存器主要有两个成员函数，get和put，其中get函数是通过输入key来获得value，如果成功获得后，这对(key, value)升至缓存器中最常用的位置（顶部），如果key不存在，则返回-1。而put函数是插入一对新的(key, value)，如果原缓存器中有该key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。具体实现时我们需要三个私有变量，cap, l和m，其中cap是缓存器的容量大小，l是保存缓存器内容的列表，m是HashMap，保存关键值key和缓存器各项的迭代器之间映射，方便我们以O(1)的时间内找到目标项。 然后我们再来看get和put如何实现，get相对简单些，我们在HashMap中查找给定的key，若不存在直接返回-1。如果存在则将此项移到顶部，这里我们使用C++ STL中的函数splice，专门移动链表中的一个或若干个结点到某个特定的位置，这里我们就只移动key对应的迭代器到列表的开头，然后返回value。这里再解释一下为啥HashMap不用更新，因为HashMap的建立的是关键值key和缓存列表中的迭代器之间的映射，get函数是查询函数，如果关键值key不在HashMap，那么不需要更新。如果在，我们需要更新的是该key-value键值对儿对在缓存列表中的位置，而HashMap中还是这个key跟键值对儿的迭代器之间的映射，并不需要更新什么。 对于put，我们也是现在HashMap中查找给定的key，如果存在就删掉原有项，并在顶部插入新来项，然后判断是否溢出，若溢出则删掉底部项(最不常用项)。 技巧，用map保存iteration指针来删除数组 12345678910111213141516171819202122232425262728293031323334353637383940414243class LRUCache&#123;public: LRUCache(int capacity) &#123; maxSize = capacity; &#125; int get(int key) &#123; if (index.find(key) == index.end()) return -1; int value=index[key]-&gt;second; data.erase(index[key]); data.push_front(make_pair(key,value)); index[key]=data.begin(); return value; &#125; void put(int key, int value) &#123; if (index.find(key) != index.end()) &#123; data.erase(index[key]); data.push_front(make_pair(key,value)); index[key]=data.begin(); &#125; else &#123; if (data.size() == maxSize) &#123; index.erase(data.back().first); data.pop_back(); &#125; data.push_front(make_pair(key,value)); index[key] = data.begin(); &#125; &#125; private: int maxSize; list&lt;pair&lt;int, int&gt;&gt; data; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; index;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940static const auto _ = []() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); return 0;&#125;();class LRUCache final &#123; const int capacity; list&lt;int&gt; keys; unordered_map&lt;int, pair&lt;int, list&lt;int&gt;::iterator&gt;&gt; values;public: LRUCache(const int capacity) noexcept : capacity(capacity) &#123;&#125; int get(const int key) noexcept &#123; const auto it = values.find(key); if (it == values.end()) return -1; if (it-&gt;second.second != keys.begin()) keys.splice(keys.begin(), keys, it-&gt;second.second); return it-&gt;second.first; &#125; void put(const int key, const int value) noexcept &#123; if (!capacity) return; const auto it = values.find(key); if (it != values.end()) &#123; if (it-&gt;second.second != keys.begin()) keys.splice(keys.begin(), keys, it-&gt;second.second); it-&gt;second.first = value; return; &#125; if (keys.size() == capacity) &#123; values.erase(keys.back()); if (capacity &gt; 1) keys.splice(keys.begin(), keys, prev(keys.end())); keys.front() = key; &#125; else keys.push_front(key); values[key] = &#123;value, keys.begin()&#125;; return; &#125;&#125;; leetcode 460 Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted. Follow up: Could you do both operations in O(1) time complexity? Example: 123456789101112LFUCache cache = new LFUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.get(3); // returns 3.cache.put(4, 4); // evicts key 1.cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 由于需要删除最少次数的数字，那么我们必须要统计每一个key出现的次数，所以我们用一个哈希表m来记录当前数据{key, value}和其出现次数之间的映射，这样还不够，为了方便操作，我们需要把相同频率的key都放到一个list中，那么需要另一个哈希表freq来建立频率和一个里面所有key都是当前频率的list之间的映射。由于题目中要我们在O(1)的时间内完成操作了，为了快速的定位freq中key的位置，我们再用一个哈希表iter来建立key和freq中key的位置之间的映射。最后当然我们还需要两个变量cap和minFreq，分别来保存cache的大小，和当前最小的频率。 为了更好的讲解思路，我们还是用例子来说明吧，我们假设cache的大小为2，假设我们已经按顺序put进去5，4，那么来看一下内部的数据是怎么保存的，由于value的值并不是很重要，为了不影响key和frequence，我们采用value#来标记： m: 5 -&gt; {value5, 1} 4 -&gt; {value4, 1} freq: 1 -&gt; {5，4} iter: 4 -&gt; list.begin() + 1 5 -&gt; list.begin() 这应该不是很难理解，m中5对应的频率为1，4对应的频率为1，然后freq中频率为1的有4和5。iter中是key所在freq中对应链表中的位置的iterator。然后我们的下一步操作是get(5)，下面是get需要做的步骤： 如果m中不存在5，那么返回-1 从freq中频率为1的list中将5删除 将m中5对应的frequence值自增1 将5保存到freq中频率为2的list的末尾 在iter中保存5在freq中频率为2的list中的位置 如果freq中频率为minFreq的list为空，minFreq自增1 返回m中5对应的value值 经过这些步骤后，我们再来看下此时内部数据的值： m: 5 -&gt; {value5, 2} 4 -&gt; {value4, 1} freq: 1 -&gt; {4} 2 -&gt; {5} iter: 4 -&gt; list.begin() 5 -&gt; list.begin() 这应该不是很难理解，m中5对应的频率为2，4对应的频率为1，然后freq中频率为1的只有4，频率为2的只有5。iter中是key所在freq中对应链表中的位置的iterator。然后我们下一步操作是要put进去一个7，下面是put需要做的步骤： 如果调用get(7)返回的结果不是-1，那么在将m中7对应的value更新为当前value，并返回 如果此时m的大小大于了cap，即超过了cache的容量，则： a）在m中移除minFreq对应的list的首元素的纪录，即移除4 -&gt; {value4, 1} b）在iter中清除4对应的纪录，即移除4 -&gt; list.begin() c）在freq中移除minFreq对应的list的首元素，即移除4 在m中建立7的映射，即 7 -&gt; {value7, 1} 在freq中频率为1的list末尾加上7 在iter中保存7在freq中频率为1的list中的位置 minFreq重置为1 经过这些步骤后，我们再来看下此时内部数据的值： m: 5 -&gt; {value5, 2} 7 -&gt; {value7, 1} freq: 1 -&gt; {7} 2 -&gt; {5} iter: 7 -&gt; list.begin() 5 -&gt; list.begin() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class LFUCache &#123;public: int capacity; int size; int minFreq; unordered_map&lt;int, pair&lt;int, int&gt;&gt; m; unordered_map&lt;int, list&lt;int&gt;::iterator&gt; indexMap; unordered_map&lt;int, list&lt;int&gt;&gt; freqMap; LFUCache(int capacity) &#123; this-&gt;capacity = capacity; size = 0; &#125; int get(int key) &#123; if(m.find(key) != m.end())&#123; freqMap[m[key].second].erase(indexMap[key]); m[key].second++; freqMap[m[key].second].push_back(key); indexMap[key] = --freqMap[m[key].second].end(); if(freqMap[minFreq].size() == 0) minFreq++; return m[key].first; &#125;else return -1; &#125; void put(int key, int value) &#123; if(capacity == 0) return; if(get(key) == -1)&#123; if(size &gt;= capacity)&#123; m.erase(freqMap[minFreq].front()); indexMap.erase(freqMap[minFreq].front()); freqMap[minFreq].pop_front(); size--; &#125; minFreq = 1; m[key] = pair&lt;int, int&gt;&#123;value, 1&#125;; freqMap[1].push_back(key); indexMap[key] = --freqMap[1].end(); size++; &#125;else &#123; m[key].first = value; &#125; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static int x = []() &#123; ios::sync_with_stdio(false); cin.tie(NULL); return 0; &#125;();class LFUCache &#123;private: typedef pair&lt;int, int&gt; P; typedef list&lt;P&gt; L; typedef L::iterator I; typedef unordered_map&lt;int, L&gt; C2L; typedef unordered_map&lt;int, I&gt; K2I; typedef unordered_map&lt;int, int&gt; K2C; C2L countToEntryList; K2I keyToIter; K2C keyToCount; int maxSize, minCount = 0;public: /* time: O(1), space: O(1) auxiliary (i.e. does not count cache capacity itself) */ LFUCache(int capacity) : maxSize(capacity) &#123; &#125; /* time: O(1), space: O(1) auxiliary (i.e. does not count cache capacity itself) */ int get(int key) &#123; if (!keyToIter.count(key)) return -1; const int oldCount = keyToCount[key], newCount = oldCount + 1; auto&amp; oldEntryList = countToEntryList[oldCount]; auto&amp; newEntryList = countToEntryList[newCount]; newEntryList.splice(newEntryList.begin(), oldEntryList, keyToIter[key]); keyToIter[key] = newEntryList.begin(), keyToCount[key] = newCount; if (oldEntryList.empty()) &#123; countToEntryList.erase(oldCount); if (minCount == oldCount) minCount = newCount; &#125; return keyToIter[key]-&gt;second; &#125; /* time: O(1), space: O(1) auxiliary (i.e. does not count cache capacity itself) */ void put(int key, int value) &#123; if (!maxSize) return; if (get(key) != -1) &#123; keyToIter[key]-&gt;second = value; return; &#125; if (keyToIter.size() == maxSize) &#123; auto&amp; entryList = countToEntryList[minCount]; const int LRFKey = entryList.back().first; keyToIter.erase(LRFKey), keyToCount.erase(LRFKey); entryList.pop_back(); if (entryList.empty()) countToEntryList.erase(minCount); &#125; minCount = 1; auto&amp; entryList = countToEntryList[minCount]; entryList.emplace_front(key, value); keyToIter[key] = entryList.begin(), keyToCount[key] = minCount; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>lru</tag>
        <tag>lfu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节跳动 面试]]></title>
    <url>%2Fostlo%2F2019%2F04%2F14%2Fsuanfa%2F</url>
    <content type="text"><![CDATA[后端 1 给一个数组，定义X为某个区间的最小值乘上这个区间内所有元素的和，求最大的X。如数组为3 1 6 4 5，则最大的X=4*（6+4+5）=60 三次握手，TCP连接的本质 同步IO和异步IO 进程和线程的区别，创建线程和进程的开销指什么 死锁及如何避免 什么是面向对象 C++多态和实现方法 设计题：设计一个购物车，给出应该有哪些数据表，每个表包含哪些字段 求数组的中位数。数组由一个升序数组翻转形成，如1 2 3 4 5 6 7可以从5处翻转，形成5 6 7 1 2 3 4，求5 6 7 1 2 3 4的中位数。要求时间复杂度低于O(n)。 InnoDB的索引类型 B树和B+树的区别 事务的四个隔离级别 拥塞控制及对应方法的使用场景 session和cookie的区别 设计题：设计一个任务定时器，给定时间和任务，到时间了自动执行对应的任务。 堆里面如何控制并发安全 死锁 内存溢出 设计线程安全类流程： 1、找出构成对象状态的所有变量。 2、找出约束状态变量的不变性条件。 3、建立对象状态的并发访问管理策略。 定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性，线程封闭，与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁保护。 一个单链表，奇数位置升序，偶数位置降序，将这个链表调整为整体升序，写出代码。 2 找一个无序数组的中位数 写了个快排，然后让我找到无序数组第k大的一个数，我说先排序再找，实际上可以用快排的partition函数。 快排的时间复杂度，最坏情况呢，最好情况呢，堆排序的时间复杂度呢，建堆的复杂度是多少，nlgn。 说说Linux的磁盘管理，一脸懵逼 Linux有哪些进程通信方式，五大件 Linux的共享内存如何实现，大概说了一下。 共享内存实现的具体步骤，我说没用过 socket网络编程，说一下TCP的三次握手和四次挥手，中间网络不好，面试官都没听清楚，很尴尬 跳过网络，问了项目的一些东西 问我如何把docker讲的很清楚，我从物理机，虚拟机到容器具体实现稍微说了下。 问我cgroup在linux的具体实现，不会。 多线程用过哪些 Java的集合类哪些是线程安全 分别说说这些集合类，hashmap怎么实现的 MySQL索引的实现，innodb的索引，b+树索引是怎么实现的，为什么用b+树做索引节点，一个节点存了多少数据，怎么规定大小，与磁盘页对应。 MySQL的事务隔离级别，分别解决什么问题。 Redis了解么，如果Redis有1亿个key，使用keys命令是否会影响线上服务，我说会，因为是单线程模型，可以部署多个节点。 问我知不知道有一条命令可以实现上面这个功能 Redis的持久化方式，aod和rdb，具体怎么实现，追加日志和备份文件，底层实现原理的话知道么，不清楚。 Redis的list是怎么实现的，我说用ziplist+quicklist实现的，ziplist压缩空间，quicklist实现链表。 sortedset怎么实现的，使用dict+skiplist实现的，问我skiplist的数据结构，大概说了下是个实现简单的快速查询结构。 了解什么消息队列，rmq和kafka 写一个层序遍历。 写一个插入树节点到一颗排序树的插入方法，使用递归方式找到插入位置即可。 一个有向图用邻接矩阵表示，并且是有权图，现在问怎么判断图中有没有环。 拓扑图 一个二叉树，找到二叉树中最长的一条路径。 操作系统的进程通信方式，僵尸进程和孤儿进程是什么，如何避免僵尸进程 那父进程怎么知道子进程结束了 计算机网络TCP和UDP有什么区别，为什么迅雷下载是基于UDP的，我说FTP是基于TCP，而迅雷是p2p不需要TCP那么可靠的传输保证。 他说不对，我说是不是因为要建立连接，开销比较大，他说不对 我说p2p的发送节点很多，所以不是那么需要各种传输保证，他说不对。 我说TCP会自动分包而TCP可以自己定义数据长度。。他还是说不对。 是NAT穿透问题吧，P2P网络使用UDP打洞穿透NAT，虽然现在也能用TCP打洞 没用拥塞控制，下的快吧。可能尽可能的利用带宽 操作系统的死锁必要条件，如何避免死锁。 写一个LRU的缓存，需要完成超时淘汰和LRU淘汰。 算法岗 Q：Batch Normalization是什么意思 Q：简单说一下LDA的思想 Q：T-SNE算法呢 Q：写一下相对熵的公式 A: PijlogqijpijP_{ij}log\frac{q_{ij}}{p_{ij}}Pij​logpij​qij​​ Q：有两个字符串，你只可以进行删除操作，问你最少进行多少次操作可以使两个字符串相等。例:sea,eat需要两次删除操作 A：这个简单，思路就是用动态规划求两个字符串的最大公共字串的长度。然后使用每一个字符串的长度减去公共子字符串的长度。 Q：那咱们再加一点，如果我想要知道每个字符串需要删除的字符是那些呢， A：那我们就需要求出最大公共字串具体是由什么字符构成的，思路也是动态规划。(很快就写完了) Q：给你一个二叉查找树，还有一个数K。如果能找到，就返回节点，如果找不到，就返回空 Q：你是用递归的形式实现的，那么和非递归，递归怎么样? Q：那递归有什么缺点 A:当递归层数很多的时候，容易造成内存溢出 Q：你刚刚说了鞍点，你知道鞍点的定义么，鞍点有什么特点？ Q：好的，下面我们来一个开放式的问题:现在有一组数，其中有m对数是两两有序的，请你设计一种算法来对这一组数排序。 Q：有M个有序链表（从大到小）。现在我们要取出前K大的元素。 Q：好的，那我们先来问一点C语言的。C语言中结构体struct{int i; bool b}一共占几个字节 A：如果int类型占4个字节的话，那么这个结构体一共需要8个字节。 Q：好的，那offset(b)在结构体中偏移几个字节 A：4个字节 Q：那么你会计算结构体中每个变量相对于结构体偏移几个字节么。 A：这个不太会 Q：好的。那么union了解么 A：了解，和struct类似，但是是共享内存。 Q：OK，那问一道概率方面的题把,几何分布知道什么意思么 A：听名字有点忘了，但是概念还记得 Q：那伯努利分布知道么 A：嗯，了解 Q：现在我有抛一枚硬币，正面朝上的概率是p,反面是1-p。那么第k次抛的时候出现第一次正面的概率是多少? A: P(1−p)k−1P(1-p)^{k-1}P(1−p)k−1 Q：好的，那么我们设 f(z=k)=p(1−p)k−1f(z=k)=p(1-p)^{k-1}f(z=k)=p(1−p)k−1，那你计算一下 E(z)E(z)E(z) （求个均值） A：(想了一会) E(z)=p+2p(1−p)+3p(1−p)2+...+mp(1−p)m−1E(z)=p+2p(1-p)+3p(1-p)^{2}+...+mp(1-p)^{m-1}E(z)=p+2p(1−p)+3p(1−p)2+...+mp(1−p)m−1 Q：能不能计算一下 E(z)E(z)E(z)的数学表达式 A：好的，思考了一会，可以使用 E(z)−(1−p)E(z)=AE(z)-(1-p)E(z)=AE(z)−(1−p)E(z)=A 。其中A是一个等比数列。然后就可以求出 E(z)E(z)E(z)。 Q：ok,来做一道编程题把 A：好的 Q：我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。 A：好的，我想想(其实完全没思路，但是明显这种题有时间复杂度为O(1)的解)，说了几种想法，都被否了 Q：那你说一种时间复杂度为O(k)的算法也可以 A：（思索一会）O(k)的话就相当于我们将前k大个元素都求了出来。（然后开始写代码） 5分钟过去了，写好了]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>字节跳动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[守护进程]]></title>
    <url>%2Fostlo%2F2019%2F04%2F08%2F%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是守护进程？ 守护进程也称精灵进程（Daemon），是一种运行在后台的一种特殊的进程，它独立于控制终端并且周期性的执 行某种任务或等待处理某些发生的事件。由于在Linux中，每个系统与用户进行交流的界面成为终端，每一个从此终端 开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，当控制终端被关闭的时候，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。它从被执行的时候开始运转，知道整个系统关闭才退出（当然可以人为的杀死相应的守护进程，例：kill -9 +守护进程ID）。如果想让某个进程不因为用户或中断或其他变化而影响，那么就必须把这个进程变成一个守护进程。 怎样查看哪些进程属于守护进程？ 我们可以使用ps axj命令查看系统中的进程，参数a表示不仅列出当前用户的进程,也列出所有其他用户的进程,参数x表示不仅列出有控制终端的进程,也列出所有无控制终端的进程,参数j表示列出与作业控制相关的信息。 凡是在TPGID一栏写着 -1 的都是没有控制终端的进程,也就是守护进程。在COMMAND⼀一列用[]括起来的名字表示内核线程,这些线程在内核里创建,没有用户空间代码,因此没有程序文件名和命令行, 通常采用以k开头的名字,表示Kernel。udevd负责维护/dev目录下的设备文件,acpid负责电源管理,syslogd负责维护/var/log下的日志⽂文件,可以看出,守护进程通 常采用以d结尾的名字,表示Daemon。 如何创建一个守护进程？ 方法一： 守护进程实现的步骤： 重设文件权限掩码： 文件权限掩码是屏蔽掉文件权限中的对应位。由于使用fork（）函数新创建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带了很多的麻烦（比如父进程中的文件没有执行文件的权限，然而在子进程中希望执行相应的文件这个时候就会出问题）。因此在子进程中要把文件的权限掩码设置成为0，即在此时有最大的权限，这样可以大大增强该守护进程的灵活性。设置的方法是：umask（0）。 创建子进程，父进程退出（使子进程成为孤儿进程）： 这是编写守护进程的第一步，由于守护进程是脱离终端的，因此完成第一步后就会在shell终端里造成一个程序已经运行完毕的假象。之后的所有工作在子进程中完成，而用户在shell终端里则可以执行其他命令，从而在形式上做到了与控制终端脱离。实现的语句如下：if(fork()&gt;0){exit(0);}是父进程结束，然后子进程继续执行。 在子进程中创建新的会话（脱离控制终端）： 这步是创建守护进程中最重要的一步，虽然实现起来很简单，但是它的意义非常重要，在这里使用的是系统函数setsid（）来创建一个新的会话，并且担任该会话组的组长。在这里有两个概念需要解释一下，进程组合会话期。 进程组：是一个或多个进程的集合。进程组有进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且该进程组ID不会因组长进程的退出而受到影响。 会话周期：会话期是一个或者多个进程的集合。通常一个会话开始于用户的登录，终止于用户的退出，在此期间该用户运行的所有进程都属于这个会话期。 setsid（）函数的作用：创建一个新的会话，并且担任该会话组的组长。具体作用包括：让一个进程摆脱原会话的控制，让进程摆脱原进程的控制，让进程摆脱原控制终端的控制。 创建守护进程要调用setsid（）函数的原因：由于创建守护进程的第一步是调用fork（）函数来创建子进程，再将父进程退出。由于在调用了fork（）函数的时候，子进程拷贝了父进程的会话期、进程组、控制终端等资源、虽然父进程退出了，但是会话期、进程组、控制终端等并没有改变，因此，需要用setsid（）韩式来时该子进程完全独立出来，从而摆脱其他进程的控制。 改变当前目录为根目录： 使用fork（）创建的子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。因此通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其他的别的目录来作为守护进程的工作目录。 关闭不再需要的文件描述符： 同文件权限码一样，用fork（）函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些文件被打开的文件可能永远不会被守护进程读写，如果不进行关闭的话将会浪费系统的资源，造成进程所在的文件系统无法卸下以及引起预料的错误。按照如下方法关闭它们： for(i=0;i 关闭打开的文件描述符close(i); 守护进程的退出： 上面建立了守护进程，当用户需要外部停止守护进程运行时，往往需要使用kill命令来停止该守护进程，所以守护进程中需要编码来实现kill发出的signal信号处理，达到进程的正常退出。实现该过程的函数是signal函数： signal(SIGCHLD,SIG_IGN); 实现代码： 123456789101112131415161718192021222324252627282930#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;void mydaemon()&#123; umask(0);//1 if(fork()&gt;0)&#123;//father 2 exit(0); &#125; setsid();//3 chdir(&quot;/&quot;);//4 close(0);//5 close(1); close(2); signal(SIGCHLD,SIG_IGN);//6&#125;int main()&#123; mydaemon(); while(1) &#123; sleep(1); &#125; return 0;&#125; 存在一个名为mydaemon的守护进程。 方法二： 直接调用daemon函数。 daemon函数的作用：将此进程精灵化。 int daemon(int nochair,int noclose); nochdir：这个值为0的话，表示将当前进程的工作目录设值为”/”目录。 noclose:这个值 为0的话表示将所有的文件描述符都写入”/dev/null”中。”/dev/null”表示黑洞，写入里面的所有信息都被内核丢弃。 1234567891011#include&lt;unistd.h&gt;int main()&#123; daemon(0,0); while(1) &#123; sleep(1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>守护进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针]]></title>
    <url>%2Fostlo%2F2019%2F04%2F07%2FC%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针的概念 指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。 先声明几个指针放着做例子： 例一： 12345int *ptr; char *ptr; int **ptr; int (*ptr)[3]; int *(*ptr)[4]; 指针的类型 从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型： 12345int *ptr; //指针的类型是int * char *ptr; //指针的类型是char * int **ptr; //指针的类型是 int ** int (*ptr)[3]; //指针的类型是 int(*)[3] int *(*ptr)[4]; //指针的类型是 int *(*)[4] 怎么样？找出指针的类型的方法是不是很简单？ 指针所指向的类型 当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。 从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如： 12345int *ptr; //指针所指向的类型是int char *ptr; //指针所指向的的类型是char int **ptr; //指针所指向的的类型是 int * int (*ptr)[3]; //指针所指向的的类型是 int()[3] int *(*ptr)[4]; //指针所指向的的类型是 int *()[4] 在指针的算术运算中，指针所指向的类型有很大的作用。 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。 指针的值 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。 指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 指针所指向的内存区和指针所指向的类型是两个完全不同的概念。 在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？ 指针本身所占据的内存区 指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。 指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int a[100];int main()&#123; char* t[] = &#123;"p3423d","wewr","234"&#125;; char* p="ewer"; int b[100]; int* B=new int[10]; cout&lt;&lt;"t "&lt;&lt;sizeof(t)&lt;&lt;endl; cout&lt;&lt;"p "&lt;&lt;sizeof(p)&lt;&lt;endl; cout&lt;&lt;"*t "&lt;&lt;sizeof(*t)&lt;&lt;endl; cout&lt;&lt;"*p "&lt;&lt;sizeof(*p)&lt;&lt;endl; cout&lt;&lt;"B "&lt;&lt;sizeof(B)&lt;&lt;endl; cout&lt;&lt;"*B "&lt;&lt;sizeof(*B)&lt;&lt;endl; cout&lt;&lt;"a "&lt;&lt;sizeof(a)&lt;&lt;" b "&lt;&lt;sizeof(b)&lt;&lt;endl; char k[]="abcdef"; cout&lt;&lt;dec&lt;&lt;(unsigned int)k[3]&lt;&lt;" "&lt;&lt;sizeof(k)&lt;&lt;endl; string s="abcdef"; cout&lt;&lt;dec&lt;&lt;(unsigned int)s[6]&lt;&lt;" "&lt;&lt;sizeof(s)&lt;&lt;endl; k[3]='\0'; cout&lt;&lt;k&lt;&lt;endl; s[6]='g'; cout&lt;&lt;s&lt;&lt;endl; int a1=0; cout&lt;&lt;sizeof(a1=3)&lt;&lt;endl; cout&lt;&lt;a1&lt;&lt;endl; return 0;&#125;t 24 一个指针8 3个就是24p 8 *t 8 指向了一个数组，还是个指针，如果是*t[1] 就是1*p 1 一个char是1B 8 指针*B 4 inta 400 b 400 数组100 7 0 24 string的sizeof在不同编译器中不一样，但char是可以的，strlen区别abcabcdef40 指针的算术运算 指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如： 例二： 12345 char a[20]; int *ptr=a; ... ... ptr++; 在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。 由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。 我们可以用一个指针和一个循环来遍历一个数组，看例子： 例三： 12345678910int array[20]; int *ptr=array; ... //此处略去为整型数组赋值的代码。 ... for(i=0;i&lt;20;i++) &#123; (*ptr)++; ptr++； &#125; 这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。再看例子： 例四： 12345char a[20]; int *ptr = a; ... ... ptr += 5; 在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。 如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。 总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。 运算符&amp;和* 这里&amp;是取地址运算符，* 是…书上叫做“间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个* ，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。p的运算结果就五花八门了。总之p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。 例五： 123456789int a=12; int b; int *p; int **ptr; p=&amp;a;//&amp;a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。 *p=24;//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。ptr=&amp;p;//&amp;p的结果是个指针，该指针的类型是p的类型加个*，在这里是int**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。 *ptr=&amp;b;//*ptr是个指针，&amp;b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以?amp;b来给*ptr赋值就是毫无问题的了。**ptr=34;//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。 指针表达式 一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子： 例六： 12345678int a,b; int array[10]; int *pa; pa=&amp;a;//&amp;a是一个指针表达式。 int **ptr=&amp;pa;//&amp;pa也是一个指针表达式。 *ptr=&amp;b;//*ptr和&amp;b都是指针表达式。 pa=array; pa++;//这也是指针表达式。 例七： 123456char *arr[20]; char **parr=arr;//如果把arr看作指针的话，arr也是指针表达式 char *str; str=*parr;//*parr是指针表达式 str=*(parr+1);//*(parr+1)是指针表达式 str=*(parr+2);//*(parr+2)是指针表达式 由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。 好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。 在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。ptr是一个左值，因为ptr这个指针已经占据了内存，其实ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么ptr当然也有了自己的位置。 数组和指针的关系 数组的数组名其实可以看作一个指针。看下例： 例八： 123456int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value; ... ... value=array[0];//也可写成：value=*array; value=array[3];//也可写成：value=*(array+3); value=array[4];//也可写成：value=*(array+4); 上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int ，所指向的类型是数组单元的类型即int。因此array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。 例九： 123456789char *str[3]=&#123; &quot;Hello,this is a sample!&quot;, &quot;Hi,good morning.&quot;, &quot;Hello world&quot; &#125;; char s[80]； strcpy(s,str[0]);//也可写成strcpy(s,*str); strcpy(s,str[1]);//也可写成strcpy(s,*(str+1)); strcpy(s,str[2]);//也可写成strcpy(s,*(str+2)); 上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char**，它指向的类型是char 。 str也是一个指针，它的类型是char，它所指向的类型是char，它指向的地址是字符串&quot;Hello,this is a sample!&quot;的第一个字符的地址，即’H’的地址。 str+1也是一个指针，它指向数组的第1号单元，它的类型是char*，它指向的类型是char 。 (str+1)也是一个指针，它的类型是char，它所指向的类型是char，它指向&quot;Hi,good morning.&quot;的第一个字符’H’，等等。 下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。 在不同的表达式中数组名array可以扮演不同的角色。 在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。 在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(array)测出的是数组单元的大小。 表达式array+n（其中n=0，1，2，…。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。 例十： 123int array[10]; int (*ptr)[10]; ptr=&amp;array; 上例中ptr是一个指针，它的类型是int (*)[10]，他指向的类型是int [10]，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array代表数组本身。 本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如： 1int (*ptr)[10]; 则在32位程序中，有： 123sizeof(int(*)[10])==4 sizeof(int [10])==40 sizeof(ptr)==4 实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。 指针和结构类型的关系 可以声明一个指向结构类型对象的指针。 例十一： 12345678910struct MyStruct &#123; int a; int b; int c; &#125; MyStruct ss=&#123;20,30,40&#125;;//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。MyStruct *ptr=&amp;ss;//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。int *pstr=(int*)&amp;ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。 请问怎样通过指针ptr来访问ss的三个成员变量？ 答案： 123ptr-&gt;a; ptr-&gt;b; ptr-&gt;c; 又请问怎样通过指针pstr来访问ss的三个成员变量？ 答案： 123*pstr；//访问了ss的成员a。 *(pstr+1);//访问了ss的成员b。 *(pstr+2)//访问了ss的成员c。 呵呵，虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元： 例十二： 12int array[3]=&#123;35,56,37&#125;; int *pa=array; 通过指针pa访问数组array的三个单元的方法是： 123*pa;//访问了第0号单元 *(pa+1);//访问了第1号单元 *(pa+2);//访问了第2号单元 从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。 所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个“填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。 所以，在例十二中，即使pstr访问到了结构对象ss的第一个成员变量a，也不能保证(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 通过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。 指针和函数的关系 可以把一个指针声明成为一个指向函数的指针。 123456int fun1(char*,int); int (*pfun1)(char*,int); pfun1=fun1; .... .... int a=(*pfun1)("abcdefg",7);//通过函数指针调用函数。 可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。 THANKS]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2Fostlo%2F2019%2F04%2F07%2F%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[迭代开发 敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。 那么什么是&quot;迭代开发&quot;呢？迭代的英文是 iterative，直译为&quot;重复&quot;，迭代开发其实就是&quot;重复开发&quot;。 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次&quot;大开发&quot;；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次&quot;大开发&quot;变成多次&quot;小开发&quot;，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 **迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。**开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。 增量开发 迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用&quot;增量开发&quot;（incremental development）划分迭代。 所谓&quot;增量开发&quot;，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼…每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶… 增量开发加上迭代开发，才算真正的敏捷开发。 敏捷开发的好处 早期交付 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的&quot;瀑布开发模式&quot;，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。 降低风险 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？ 对于软件项目来说，先有一个原型产品，了解市场的接受程度，往往是项目成功的关键。有一本书叫做《梦断代码》，副标题就是&quot;20+个程序员，三年时间，4732个bug，100+万美元，最后失败的故事&quot;，这就是没有采用敏捷开发的结果。相反的，Instagram 最初是一个地理位置打卡 App，后来发现用户不怎么在乎地理位置，更喜欢上传照片，就改做照片上传软件，结果成了独角兽。 由于敏捷开发可以不断试错，找出对业务最重要的功能，然后通过迭代，调整软件方向。相比传统方式，大大增加了产品成功的可能性。如果市场需求不确定，或者你对该领域不熟悉，那么敏捷开发几乎是唯一可行的应对方式。 如何进行每一次迭代 虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。 具体来说，每次迭代都必须依次完成以下五个步骤。 需求分析（requirements analysis） 设计（design） 编码（coding） 测试（testing） 部署和评估（deployment / evaluation） 每个迭代大约持续2~6周。 敏捷开发的价值观 《敏捷软件开发宣言》里面提到四个价值观。 程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。 软件能够运行，优于详尽的文档。 跟客户的密切协作，优于合同和谈判。 能够响应变化，优于遵循计划。 十二条原则 该宣言还提出十二条敏捷开发的原则。 通过早期和持续交付有价值的软件，实现客户满意度。 欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。 不断交付可用的软件，周期通常是几周，越短越好。 项目过程中，业务人员与开发人员必须在一起工作。 项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。 面对面交谈是最好的沟通方式。 可用性是衡量进度的主要指标。 提倡可持续的开发，保持稳定的进展速度。 不断关注技术是否优秀，设计是否良好。 简单性至关重要，尽最大可能减少不必要的工作。 最好的架构、要求和设计，来自团队内部自发的认识。 团队要定期反思如何更有效，并相应地进行调整。 来源：阮一峰]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-面试]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2Fmysql%2F</url>
    <content type="text"><![CDATA[Mysql中有哪几种锁？ 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 Mysql中有哪些不同的表格？ 共有5种类型的表格： MyISAM Heap Merge INNODB ISAM 另 简述在MySQL数据库中MyISAM和InnoDB的区别 MyISAM： 不支持事务，但是每次查询都是原子的；支持表级锁，即每次操作是对整个表加锁；存储表的总行数； 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件； MyIASM基于了IASM代码，应该可以说是IASM的衍生品，不过增加了不少有用的扩展。它是MySQL的默认数据表类型，基于了传统的ISAM类型，ISAM是Indexed Sequential Access Method（有索引的顺序访问方法）的缩写，一般来说，它是存储记录和文件的标准方法。与其他存储引擎比较，MyISAM具有检查和修复表格的大多数工具。ISAM表格可以被压缩，而且它们支持全文搜索，不过它们是事务不安全的，而且也不支持外键。如果事务回滚将会造成不完全回滚，从而不具备原子性。所以假如忽略事务以及访问并发性的话，并且需要执行大量的SELECT检索语句的话，MyISAM将是最好的选择。 MyISAM表(TYPE=MYISAM)是ISAM类型的一种延伸，具有很多优化和增强的特性。 是MySQL的默认表类型。 MyISAM优化了压缩比例和速度，并且可以很方便的在不同的操作系统和平台之间进行移植。 MyISAM支持大表文件(大于4G) 允许对BLOB和TEXT列进行索引 支持使用键前缀和使用完整的键搜索记录 表数据和表索引文件可以依存在不同的位置，甚至是不同的文件系统中。 即使是具有相当多的插入、更新和删除操作的表，智能防碎片逻辑也能保证其高性能的协作性。 InnoDb： InnoDB表(TYPE=INNODB)，是一个完全兼容ACID（事务的原子性、一致性、独立性及持久性）的、高效率的表完全支持MySQL的事务处理。精细的（行级和表级）锁提高了MySQL事务处理的带走度，同时其也支持无锁定读操作（以前只在Oracle中包含）和多版本的特性。 支持行级锁及外键约束：因此可以支持写并发 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制； 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。 异步输入/输出和一系列的读缓冲将提高数据检索速度，同时可以进行文件的优化和内存的管理。需要的基础上支持自动在内存上创建散列索引来提高性能，使用缓冲来提高可靠性和数据库操作的速度。InnoDB表可以和MyISAM相媲美，甚至已经超过了MyISAM。 在不同的操作系统和体系结构上是完全可移植的。由于一直处于一致的状态（MySQL通过在启动时检查错误并修复错误来使它们更加健壮）。对外键、提交、回滚和前滚的操作的支持，使其成为MySQL中最完善的表格式。 thanks Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？ SQL标准定义的四个隔离级别为： read uncommited ：读到未提交数据 read committed：脏读，不可重复读 repeatable read：可重读 serializable ：串行事物 CHAR和VARCHAR的区别？ 1.CHAR和VARCHAR类型在存储和检索方面有所不同 2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255 当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。 主键和候选键有什么区别？ 表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 myisamchk是用来做什么的？ 它用来压缩MyISAM表，这减少了磁盘或内存使用。 MyISAM Static和MyISAM Dynamic有什么区别？ 在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。 MyISAM Static在受损情况下更容易恢复。 如果一个表有一列定义为TIMESTAMP，将发生什么？ 每当行被更改时，时间戳字段将获取当前时间戳。 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？ 它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。 怎样才能找出最后一次插入时分配了哪个自动增量？ LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。 你怎么看到为表格定义的所有索引？ 索引是通过以下方式为表格定义的： SHOW INDEX FROM &lt; tablename &gt; ; LIKE声明中的％和_是什么意思？ ％对应于0个或更多字符，_只是LIKE语句中的一个字符。 如何在Unix和Mysql时间戳之间进行转换？ UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令 FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令 列对比运算符是什么？ 在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。 mysql_fetch_array和mysql_fetch_object的区别是什么？ 以下是mysql_fetch_array和mysql_fetch_object的区别： mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。 mysql_fetch_object – 从数据库返回结果行作为对象。 MyISAM表格将在哪里存储，并且还提供其存储格式？ 每个MyISAM表格以三种格式存储在磁盘上： “.frm”文件存储表定义 数据文件具有“.MYD”（MYData）扩展名 索引文件具有“.MYI”（MYIndex）扩展名 Mysql如何优化DISTINCT？ DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。 SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a; 如何显示前50行？ 在Mysql中，使用以下代码查询显示前50行： SELECT … FROM … LIMIT 0,50; 可以使用多少列创建索引？ 任何标准表最多可以创建16个索引列。 NOW（）和CURRENT_DATE（）有什么区别? NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 CURRENT_DATE（）仅显示当前年份，月份和日期。 什么是通用SQL函数？ CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。 FORMAT(X, D)- 格式化数字X到D有效数字。 CURRDATE(), CURRTIME()- 返回当前日期或时间。 NOW（） – 将当前日期和时间作为一个值返回。 MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。 HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。 DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄 SUBTIMES（A，B） – 确定两次之间的差异。 FROMDAYS（INT） – 将整数天数转换为日期值。 MYSQL支持事务吗？ 在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。 但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。 mysql里记录货币用什么字段类型好 NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。 例如： salary DECIMAL(9,2) 在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。 因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。 mysql有关权限的表都有哪几个？ Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。 列的字符串类型可以是什么？ 字符串类型是： SET BLOB 大二进制文件 ENUM CHAR TEXT 字符串类型 字节 描述及存储需求 CHAR(M) M M为0~255之间的整数 VARCHAR(M) M为0~65536之间的整数 TINYBLOB 允许长度0~255字节 BLOB 允许长度0~65535字节 MEDUIMBLOB 允许长度0~167772150字节 LONGBLOB 允许长度0~4294967295 TINYTEXT 允许长度0~255字节 TEXT 允许长度0~65535字节 MEDIUMTEXT 允许长度0~167772150字节 LONGTEXT 允许长度0~4294967295字节 VARBINARY(M) M 允许长度0~M个字节的边长字节字符集 BINARY(M) M 允许长度0~M个字节的定长字节字符集 CHAR于VARCHAR类型 CHAR和VARCHAR很类似，都是用来保存Mysql中较短的字符串，主要区别在于:CHAR列的长度固定为创建表时声明的长度，长度可以为从0255的任何值，而VARCHAR的值可以是变长字符串，长度可以指定065535之间的值，在检索的时候，CHAR列会删除尾部的空格而VARCHAR则保留了这些空格。 ENUM类型 枚举类型，忽略大小写，它的值范围需要在创建表时通过枚举方式显示指定，对1255个成员的枚举需要1个字节存储，对于25565535个成员，需要2个字节存储，最多允许65535个成员。 SET类型 SET和enum非常相似，里面可以包含0~64个成员，根据成员的不用，存储上也有不同。 1~8成员的集合，占1个字节 9~16成员的集合，占2个字节 17~24成员的集合，占3个字节 25~32成员的集合，占4个字节 33~64成员的集合，占8个字节 set类型一次可以选取多个成员，而ENUM则只能选一个，就相当于ENUM是单选，而set是复选。 什么是非标准字符串类型？ TINYTEXT TEXT MEDIUMTEXT LONGTEXT BLOB和TEXT有什么区别？ BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。 BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。 MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？ a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。 b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。 c. mysql库主从读写分离。 d. 找规律分表，减少单表中的数据量提高查询速度。 e。添加缓存机制，比如memcached，apc等。 f. 不经常改动的页面，生成静态页面。 g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 锁的优化策略 读写分离 分段加锁 减少锁持有的时间 多个线程尽量以相同的顺序去获取资源 不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。 索引的底层实现原理和优化 B+树，经过优化的B+树 主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。 什么情况下设置了索引但无法使用 以“%”开头的LIKE语句，模糊匹配 OR语句前后没有同时使用索引 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型） 实践中如何优化MySQL 最好是按照以下顺序优化： SQL语句及索引的优化 数据库表结构的优化 系统配置的优化 硬件的优化 详细可以查看 阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结 优化数据库的方法 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM 使用连接(JOIN)来代替子查询 适用联合(UNION)来代替手动创建的临时表 事务处理 锁定表、优化事务处理 适用外键，优化锁定表 建立索引 优化查询语句 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面） 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。 普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。 主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。 索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。 数据库中的事务是什么? 事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。 事务特性： （1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。 （2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态 （3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， （4）持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 或者这样理解： 事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 SQL注入漏洞产生的原因？如何防止？ SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。 防止SQL注入的方式： 开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置 执行sql语句时使用addslashes进行sql语句转换 Sql语句书写尽量不要省略双引号和单引号。 过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。 提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。 为表中得字段选择合适得数据类型 字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text 优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型 存储时期 Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，占用8个字节得存储空间，datatime类型与时区无关 Timestamp:以时间戳格式存储，占用4个字节，范围小1970-1-1到2038-1-19，显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改timestamp列得值 Date:（生日）占用得字节数比使用字符串.储存要少，使用date只需要3个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算 Time:存储时间部分得数据 注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，在进行查找过滤可以利用日期得函数） 使用int存储日期时间不如使用timestamp类型 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题： 索引的目的是什么？ 快速访问数据表中的特定信息，提高检索速度 创建唯一性索引，保证数据库表中每一行数据的唯一性。 加速表和表之间的连接 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 索引对数据库系统的负面影响是什么？ 负面影响： 创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。 为数据表建立索引的原则有哪些？ 在最频繁使用的、用以缩小查询范围的字段上建立索引。 在频繁使用的、需要排序的字段上建立索引 什么情况下不宜建立索引？ 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。 对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等 解释MySQL外连接、内连接与自连接的区别 先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。 内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。 外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中 的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。 左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。 Myql中的事务回滚机制概述 事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。 要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚 SQL语言包括哪几部分？每部分都有哪些操作关键字？ SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。 数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等 数据操纵：Select ,insert,update,delete, 数据控制：grant,revoke 数据查询：select 完整性约束包括哪些？ 数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类： 实体完整性：规定表的每一行在表中是惟一的实体。 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 什么是锁？ 数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。 基本锁类型 锁包括行级锁、表级锁、页面锁（见开头） 什么叫视图？游标是什么？ 视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改影响基本表。它使得我们获取数据更容易，相比多表查询。另不能在一张由多张关联表连接而成的视图上做同时修改两张表的操作；视图与表是一对一关系时如果没有其它约束（如视图中没有的字段，在基本表中是必填字段情况），是可以进行增删改数据操作；修改操作时要小心，不经意间你已经修改了基本表里的多条数据，对视图的创建与删除不影响基本表。 1234567891011121314151617181920DROP VIEWIF EXISTS `view_user_course`;CREATE ALGORITHM = UNDEFINED DEFINER = `root`@`localhost` SQL SECURITY DEFINER VIEW `view_user_course` AS ( SELECT `uc`.`id` AS `id`, `u`.`name` AS `username`, `c`.`name` AS `coursename` FROM ( ( `user` `u` LEFT JOIN `user_course` `uc` ON ((`u`.`id` = `uc`.`userid`)) ) LEFT JOIN `course` `c` ON ((`uc`.`courseid` = `c`.`id`)) )); 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 需要强调的是，游标必须在定义处理程序之前被定义，但变量必须在定义游标之前被定义，顺序就是变量定义-游标定义-处理程序。 定义游标：DECLARE cursor_name CURSOR FOR select_statement 这个语句声明一个游标。也可以在子程序中定义多个游标，一个块中的每一个游标必须命名唯一。声明游标后也是单条操作的。 游标OPEN：OPEN cursor_name 这个语句打开先前声明的游标。 游标FETCH：FETCH cursor_name INTO var_name [, var_name] … 这个语句用指定的打开游标读取下一行（如果有下一行的话），并且前进游标指针至该行。 游标CLOSE：CLOSE cursor_name 这个语句关闭先前打开的游标，注意，用完后必须关闭。 什么是存储过程？用什么来调用？ 答：存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。 如何通俗地理解三个范式？ 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性,为实现区分通常需要我们设计一个主键来实现 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。很多时候，我们为了满足第三范式往往会把一张表分成多张表。 范式化设计优缺点: 优点: 可以尽量得减少数据冗余，使得更新快，体积小 缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化 反范式化: 优点:可以减少表得关联，可以更好得进行索引优化 缺点:数据冗余以及数据异常，数据得修改需要更多的成本 什么是基本表？什么是视图？ 基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表 试述视图的优点？ 视图能够简化用户的操作。 视图使用户能以多种角度看待同一数据。 视图对重构数据库提供了一定程度的逻辑独立性。 视图能够对机密数据提供安全保护。 适当利用视图可以更清晰的表达查询。 NULL是什么意思 NULL这个值表示UNKNOWN(未知):它不表示 &quot; &quot; (空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。 使用IS NULL来进行NULL判断 主键、外键和索引的区别？ 定义： 主键–唯一标识一条记录，不能有重复的，不允许为空 外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值 索引–该字段没有重复值，但可以有一个空值 作用： 主键–用来保证数据完整性 外键–用来和其他表建立联系用的 索引–是提高查询排序的速度 个数： 主键–主键只能有一个 外键–一个表可以有多个外键 索引–一个表可以有多个唯一索引 你可以用什么来确保表格里的字段只接受特定范围里的值? 答：Check限制，它在数据库表格里被定义，用来限制输入该列的值。 触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。 说说对SQL语句优化有哪些方法？（选择几条） （1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。 （2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。 （3）避免在索引列上使用计算 （4）避免在索引列上使用IS NULL和IS NOT NULL （5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 （6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 （7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描 on与where sql连接方式为嵌套循环连接。一层一层的连接，循环用外层结果集的记录行和内层的所有符合条件ON条件的记录依次连接，内层没有符合条件的生成所有字段为null的记录行，当不存在ON条件是以“笛卡尔积”的形式连接。连接过后where过滤，再连接，在过滤，直到左右表均连接完毕。连接完毕后有group by字句则执行分组，有having字句的则对分组后的结果集再过滤，所以having执行在where之后，因此有些条件放where字句内能缩小分组前的结果集，提高执行效率。之后还有order by字句的则执行排序，最后得到查询的结果。 where里可能有关于每张表的筛选条件，不同表的条件生效时期不同。对于驱动表，在执行一开始就会通过where上关于词表的条件筛选一条或者一批记录，然后通过on条件关联下一张表，将得到的结果集再用where上第二张表的条件做过滤，然后重复此过程直到所有表关联完毕。也就是对于驱动表，因为只有where生效，对于其他被驱动表，先被on关联，也就是on先生效，然后再用where过滤关联的结果集。同时对于外表连接，比如left join和right join，把条件放在on上，如果被关联表没有匹配上，那么外表还是能放入结果集的；而如果将条件放在where上，因为where是对关联后的结果做过滤，此时之前匹配的记录也会被筛选掉。thanks sql and nosql SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL，PostgreSQL。 NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB，Redis，CouchDB。 sql优点 事务处理—保持数据的一致性 由于以标准化为前提，数据更新的开销很小（相同的字段基本上只有一处） 可以进行Join等复杂查询 sql缺点 扩展困难：由于存在类似Join这样多表查询机制，使得数据库在扩展方面很艰难; 读写慢：这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重 成本高：企业级数据库的License价格很惊人，并且随着系统的规模，而不断上升 nosql优点 Nosql的存储方式灵活，NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。 简单的扩展：典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群 快速的读写：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作 低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本 thanks]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2F%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[什么是并发： 并发是指多个执行任务同时、在一个较长的时间段内可认为是并行被执行。 什么是并行： 并行就是指多个任务同时执行 什么是竞态： 字面意思是竞争，并发的执行单元对共享资源（硬件资源和软件上的全局变量，静态变量等）的访问容易发生竞态。 对于一个虚拟的字符设备驱动，假设一个执行单元A对其写入300个字符‘a’，而另一个执行单元B对其写入300个字符‘b’，第三个执行单元读取所有字符。如果A、B被顺序串行执行那么C读出的则不会出错，但如果A、B并发执行，那结果则是我们不可料想的。 竞态发生的情况 对称多处理器（SMP）的多个CPU： SMP是一种紧耦合、共享存储的系统模型，它的特点是多个CPU使用共同的系统总线，因此可以访问共同的外设和存储器。 单CPU内进程与抢占它的进程： Linux 2.6的内核支持抢占调度，一个进程在内核执行的时候可能被另一高优先级进程打断。 中断（硬中断、软中断、tasklet、低半部）与进程之间：中断可以打断正在执行的进程，处理中断的程序和被打断的进程间也可能发生竞态。 竞态的解决办法 解决竞态问题的途径是保证对共享资源的互斥访问。访问共享资源的代码区域称为临界区，临界区要互斥机制保护。Linux设备驱动中常见的互斥机制有以下方式：中断屏蔽、原子操作、自旋锁和信号量等。 临界区 Most readers would agree that this scenario is best avoided. Therefore, the core rule that applies to spinlocks is that any code must, while holding a spinlock, be atomic.It cannot sleep; in fact, it cannot relinquish the processor for any reason except toservice interrupts (and sometimes not even then). 互斥锁和自旋锁、信号量的区别 互斥锁和互斥量 在我的理解里没啥区别，不同叫法。广义上讲可以值所有实现互斥作用的同步机制。狭义上讲指的就是mutex这种特定的二元锁机制。互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的 。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。 信号量（semaphore） 是一种更高级的同步机制，mutex（互斥锁） 可以说是 semaphore（信号量） 在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。 程序运行状态 开始 运行 就绪 阻塞 结束 互斥锁：常用，使用后需要的程序进入就绪态，通常情况下锁操作失败会将该线程睡眠等待锁释放时被唤醒，用于互斥，信号量用于同步 自旋锁：相比一般的互斥锁会在等待期间放弃cpu，使用硬件提供的swap指令或test_and_set指令实现，自旋锁则是不断循环并测试锁的状态，这样就一直占着cpu。所以相比于自旋锁和信号量，在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒休眠的线程。可以联想到程序查询中断方式。 递归锁：严格上讲递归锁只是互斥锁的一个特例，同样只能有一个线程访问该对象，但允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作，直到一个线程所有的acquire都被release，其他的线程才能获得资源。 windows下的临界区默认是支持递归锁的，而linux下的互斥量则需要设置参数PTHREAD_MUTEX_RECURSIVE_NP，默认则是不支持。 读写锁(rwlock)：高级别锁，区分读和写，符合条件时允许多个线程访问对象。处于读锁操作时可以允许其他线程和本线程的读锁， 但不允许写锁， 处于写锁时则任何锁操作都会睡眠等待；常见的操作系统会在写锁等待时屏蔽后续的读锁操作以防写锁被无限孤立而等待，在操作系统不支持情况下可以用引用计数加写优先等待来用互斥锁实现。 读写锁适用于大量读少量写的环境，但由于其特殊的逻辑使得其效率相对普通的互斥锁和自旋锁要慢一个数量级；值得注意的一点是按POSIX标准 在线程申请读锁并未释放前本线程申请写锁是成功的，但运行后的逻辑结果是无法预测 另外注意并发时候stl的改变]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务的四大特性以及事务的隔离级别]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数据库的四个特性 如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性： 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。 持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题： 问题 脏读 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下 123update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’; 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。 不可重复读 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了…… 虚读(幻读) 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 范式 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性,为实现区分通常需要我们设计一个主键来实现 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。很多时候，我们为了满足第三范式往往会把一张表分成多张表。 隔离级别 现在来看看MySQL数据库为我们提供的四种隔离级别： Serializable (串行化) 可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读) 可避免脏读、不可重复读的发生。 Read committed (读已提交) 可避免脏读的发生。 Read uncommitted (读未提交) 最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。 在MySQL数据库中查看当前事务的隔离级别： 1select @@tx_isolation; 在MySQL数据库中设置事务的隔离 级别： 123set [glogal | session] transaction isolation level 隔离级别名称;set tx_isolation=’隔离级别名称;’ 例1：查看当前事务的隔离级别： 例2：将事务的隔离级别设置为Read uncommitted级别： 或： 记住：设置数据库的隔离级别一定要是在开启事务之前！ 如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段： 在JDBC中设置隔离级别的部分代码： 后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 参考博客： http://www.zhihu.com/question/23989904 http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html http://www.cnblogs.com/xdp-gacl/p/3984001.html 来源]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试--抛棋子]]></title>
    <url>%2Fostlo%2F2019%2F04%2F06%2F%E9%9D%A2%E8%AF%95-%E6%8A%9B%E6%A3%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[问题 有一个一百层高的大厦，从这个大厦的某一层扔下棋子恰好就会碎（称这一层为临界层）。请你用手中的两个玻璃围棋子，找出一个最优的策略来得出那个最优层。 分析：题目要求策略最优，因而要使得在最坏的情况下投掷的总次数 Tmax​T_{max}​Tmax​​ 最少。首先考虑只有一个棋子的情况，条件若为多个棋子则可转化为一个棋子的情况。 解答 一个棋子 棋子必须在临界层扔下的时候碎，所以唯一的策略是从1层往上逐层投掷，此时Tmax=99T_{max} =99Tmax​=99，临界层为99层或100层（因为题目告诉100层肯定会碎，如果99层没碎，那表示临界层即为100） 两个棋子 利用多的这个棋子缩小查找的范围，因而把100层分成若干段：先利用一个棋子来确定临界层所在的段，再利用另一个棋子确定临界层，总的投掷次数等于确定临界段的次数n1n_{1}n1​和确定临界层的次数n2n_{2}n2​的和 现把100层平均分成n段（n是100的正因数），有Tmax=(n−1)+100n−1=n+100n−2T_{max}= (n-1) + \frac{100}{n-1} = n + \frac{100}{n}-2Tmax​=(n−1)+n−1100​=n+n100​−2由均值不等式可知n=10时，Tmax=18T_{max} =18Tmax​=18为最小值，此时临界段为第80~90层，临界层为第89层。如果把100层分成12段(100=9×11+1)(100=9\times 11+1)(100=9×11+1)：19,1018,…91~99,100,与上述n=10的情况相比虽然每段的层数在减少（从而n1n_{1}n1​在减少），但所分的段数在增加（从而n2n_{2}n2​在增加），因而TmaxT_{max}Tmax​并没有减少。如果把100层分成其他段（比如9段：100=12×8+4100=12\times 8+4100=12×8+4，情况也是如此. 根据上面的讨论，如何把100层合理地分段是关键。上述对100层所分段数的调整并没有使得Tmax=18T_{max} =18Tmax​=18减少的原因在于每段包含的层数比较均匀(图1)，因而出现n1n_{1}n1​和n2n_{2}n2​此消彼长的情况。鉴于此我们做出以下方式的调整： 把100层分成若干段，从下往上，每段的层数逐渐少1（图2），这样就使得在最坏的情况下，n1n_{1}n1​增加1的同时n2n_{2}n2​减少1，因而n1n_{1}n1​与n2n_{2}n2​的总和不变（等于第一段的层数n）,为确定n的值，只需要解不等式n+(n−1)+(n−2)+...+1≥100n+(n-1)+(n-2)+...+1\geq 100n+(n−1)+(n−2)+...+1≥100,从而得到n=14 从第14层开始扔第一枚棋子，如果没有碎则从第14+13=27层开始扔，如果还没有碎则从14+13+12=39层开始扔，以此类推，此时Tmax=14T_{max} =14Tmax​=14,临界层可为第27层，第39层，…第99层。 拓展： 对于m层楼高，k个球的扔棋子问题，又该怎么做？ 答案是用动态规划的思想：如果是三个棋子，100层楼，我扔了一次棋子碎了以后，就变成2个棋子的问题了，因此可以利用上面的结果： $（x*(x-1)/2+((x-1)*(x-2)/2)+…+3+1&gt;=100. $ 推广 从上面的讨论可以发现此题的关键是（高阶）等差数列： 两个棋子：1 2 3 4 5… $ \sum_{i=1}{n}{C_{i}{1} \geq }100 $ ! 三个棋子：1 3 6 10 15… $ \sum_{i=2}{n}{C_{i}{2} }\geq 100 $ 因而我们还可以考虑大楼有m层，棋子有k个的情况 ∑i=knCik≥m\sum_{ i=k}^{n}{C_{i}^{k} } \geq m∑i=kn​Cik​≥m 算法证明：对 mmm 层楼，k个棋子的问题，存在复杂度为O(my)O(\sqrt[y]{m})O(ym​)的算法。 thanks]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>建模</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie 与 session 的区别]]></title>
    <url>%2Fostlo%2F2019%2F04%2F04%2Fcookie-%E4%B8%8E-session-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[原文链接：mp.weixin.qq.com 本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有一个更深入的了解，并对自己的开发工作中灵活运用带来启示。 cookie机制 Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。 具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。 session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。 session机制 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。 Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。 不同 1、存取方式的不同 Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。 而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 2、隐私策略的不同 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。 假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。 3、有效期上的不同 使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。 由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。 4、服务器压力的不同 Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。 而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。 5、浏览器支持的不同 Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。 假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。 假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干） 6、跨域支持上的不同 Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。 仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[同步异步阻塞非阻塞]]></title>
    <url>%2Fostlo%2F2019%2F04%2F04%2F%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[同步： 所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事 异步： 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕 阻塞： 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。 有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。 非阻塞： 非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 再简单点理解就是： 同步，就是我调用一个功能，该功能没有结束前，我死等结果。 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞 阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回 综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 安装]]></title>
    <url>%2Fostlo%2F2019%2F04%2F04%2F%E5%AE%89%E8%A3%85-Hexo%2F</url>
    <content type="text"><![CDATA[安装 首先安装如下两个包 Node.js Git 安装好之后初次运行Git需要做一些配置： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 文档 npm安装时改源 npm 安装报错 rollbackFailedOptional verb npm-session 解决办法 npm config set registry http://registry.npm.taobao.org 建站 Hexo安装好了之后，就开始进行建站。打开终端cd到桌面并使用如下命令即可建好 hexo init name cd name 常用参数 clean Remove generated files and cache. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. new Create a new post. server Start the server. deploy注意事项 1:排查-&gt;是否安装一下hexo-deployer-git这个模块 没有安装:npm install hexo-deployer-git --save使用指令安装 2:排查-&gt;_config.yml 这个文件的deploy写了没有;写全了没有 我的就是因为_config.yml中deploy下的type等前面没有空格导致。。。。。 hexo d 提示You should configure deployment settings in _config.yml first! 123deploy: type: repo: hexo d/deploy 时遇到问题再试一次，可能是用户名密码没有来得及输入，， 主题 next主题 deploy后github上未显示主题 If your site is put in a subdirectory, set url as ‘http://yoursite.com/child’ and root as ‘/child/’ url: https://ghostlo.github.io/ostlo root: /ostlo/ 后续 后续的修改只需要重复第5步就可以了，代码如下： 1234cd 本地库目录git add .git commit -m &quot;版本日志&quot;git push -u origin master Hexo 配置1 Hexo 配置2 GitHub还有很多好功能有待开发，善于利用搜索引擎，have fun~ 推荐阅读]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
