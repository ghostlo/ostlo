{"meta":{"title":"Ostlo's Blog","subtitle":null,"description":null,"author":"Ostlo_TL","url":"https://ghostlo.github.io","root":"/ostlo/"},"pages":[{"title":"categories","date":"2019-04-04T01:39:49.000Z","updated":"2019-04-04T01:40:05.000Z","comments":true,"path":"categories/index.html","permalink":"https://ghostlo.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-04-07T11:50:34.000Z","updated":"2019-04-07T11:50:34.000Z","comments":true,"path":"about/index-1.html","permalink":"https://ghostlo.github.io/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2019-04-04T01:58:55.000Z","updated":"2019-04-04T01:59:11.000Z","comments":true,"path":"about/index.html","permalink":"https://ghostlo.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-04T01:37:18.000Z","updated":"2019-04-04T01:39:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://ghostlo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"守护进程","slug":"守护进程","date":"2019-04-08T08:16:36.000Z","updated":"2019-04-08T08:19:50.000Z","comments":true,"path":"2019/04/08/守护进程/","link":"","permalink":"https://ghostlo.github.io/2019/04/08/守护进程/","excerpt":"","text":"什么是守护进程？ 守护进程也称精灵进程（Daemon），是一种运行在后台的一种特殊的进程，它独立于控制终端并且周期性的执 行某种任务或等待处理某些发生的事件。由于在Linux中，每个系统与用户进行交流的界面成为终端，每一个从此终端 开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，当控制终端被关闭的时候，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。它从被执行的时候开始运转，知道整个系统关闭才退出（当然可以人为的杀死相应的守护进程，例：kill -9 +守护进程ID）。如果想让某个进程不因为用户或中断或其他变化而影响，那么就必须把这个进程变成一个守护进程。 怎样查看哪些进程属于守护进程？ 我们可以使用ps axj命令查看系统中的进程，参数a表示不仅列出当前用户的进程,也列出所有其他用户的进程,参数x表示不仅列出有控制终端的进程,也列出所有无控制终端的进程,参数j表示列出与作业控制相关的信息。 凡是在TPGID一栏写着 -1 的都是没有控制终端的进程,也就是守护进程。在COMMAND⼀一列用[]括起来的名字表示内核线程,这些线程在内核里创建,没有用户空间代码,因此没有程序文件名和命令行, 通常采用以k开头的名字,表示Kernel。udevd负责维护/dev目录下的设备文件,acpid负责电源管理,syslogd负责维护/var/log下的日志⽂文件,可以看出,守护进程通 常采用以d结尾的名字,表示Daemon。 如何创建一个守护进程？ 方法一： 守护进程实现的步骤： 重设文件权限掩码： 文件权限掩码是屏蔽掉文件权限中的对应位。由于使用fork（）函数新创建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带了很多的麻烦（比如父进程中的文件没有执行文件的权限，然而在子进程中希望执行相应的文件这个时候就会出问题）。因此在子进程中要把文件的权限掩码设置成为0，即在此时有最大的权限，这样可以大大增强该守护进程的灵活性。设置的方法是：umask（0）。 创建子进程，父进程退出（使子进程成为孤儿进程）： 这是编写守护进程的第一步，由于守护进程是脱离终端的，因此完成第一步后就会在shell终端里造成一个程序已经运行完毕的假象。之后的所有工作在子进程中完成，而用户在shell终端里则可以执行其他命令，从而在形式上做到了与控制终端脱离。实现的语句如下：if(fork()&gt;0){exit(0);}是父进程结束，然后子进程继续执行。 在子进程中创建新的会话（脱离控制终端）： 这步是创建守护进程中最重要的一步，虽然实现起来很简单，但是它的意义非常重要，在这里使用的是系统函数setsid（）来创建一个新的会话，并且担任该会话组的组长。在这里有两个概念需要解释一下，进程组合会话期。 进程组：是一个或多个进程的集合。进程组有进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且该进程组ID不会因组长进程的退出而受到影响。 会话周期：会话期是一个或者多个进程的集合。通常一个会话开始于用户的登录，终止于用户的退出，在此期间该用户运行的所有进程都属于这个会话期。 setsid（）函数的作用：创建一个新的会话，并且担任该会话组的组长。具体作用包括：让一个进程摆脱原会话的控制，让进程摆脱原进程的控制，让进程摆脱原控制终端的控制。 创建守护进程要调用setsid（）函数的原因：由于创建守护进程的第一步是调用fork（）函数来创建子进程，再将父进程退出。由于在调用了fork（）函数的时候，子进程拷贝了父进程的会话期、进程组、控制终端等资源、虽然父进程退出了，但是会话期、进程组、控制终端等并没有改变，因此，需要用setsid（）韩式来时该子进程完全独立出来，从而摆脱其他进程的控制。 改变当前目录为根目录： 使用fork（）创建的子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。因此通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其他的别的目录来作为守护进程的工作目录。 关闭不再需要的文件描述符： 同文件权限码一样，用fork（）函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些文件被打开的文件可能永远不会被守护进程读写，如果不进行关闭的话将会浪费系统的资源，造成进程所在的文件系统无法卸下以及引起预料的错误。按照如下方法关闭它们： for(i=0;i 关闭打开的文件描述符close(i); 守护进程的退出： 上面建立了守护进程，当用户需要外部停止守护进程运行时，往往需要使用kill命令来停止该守护进程，所以守护进程中需要编码来实现kill发出的signal信号处理，达到进程的正常退出。实现该过程的函数是signal函数： signal(SIGCHLD,SIG_IGN); 实现代码： 123456789101112131415161718192021222324252627282930#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;void mydaemon()&#123; umask(0);//1 if(fork()&gt;0)&#123;//father 2 exit(0); &#125; setsid();//3 chdir(&quot;/&quot;);//4 close(0);//5 close(1); close(2); signal(SIGCHLD,SIG_IGN);//6&#125;int main()&#123; mydaemon(); while(1) &#123; sleep(1); &#125; return 0;&#125; 存在一个名为mydaemon的守护进程。 方法二： 直接调用daemon函数。 daemon函数的作用：将此进程精灵化。 int daemon(int nochair,int noclose); nochdir：这个值为0的话，表示将当前进程的工作目录设值为”/”目录。 noclose:这个值 为0的话表示将所有的文件描述符都写入”/dev/null”中。”/dev/null”表示黑洞，写入里面的所有信息都被内核丢弃。 1234567891011#include&lt;unistd.h&gt;int main()&#123; daemon(0,0); while(1) &#123; sleep(1); &#125; return 0;&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://ghostlo.github.io/categories/操作系统/"}],"tags":[{"name":"守护进程","slug":"守护进程","permalink":"https://ghostlo.github.io/tags/守护进程/"}]},{"title":"C++指针","slug":"C指针","date":"2019-04-07T06:40:56.000Z","updated":"2019-04-07T10:58:55.000Z","comments":true,"path":"2019/04/07/C指针/","link":"","permalink":"https://ghostlo.github.io/2019/04/07/C指针/","excerpt":"","text":"指针的概念 指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。 先声明几个指针放着做例子： 例一： 12345int *ptr; char *ptr; int **ptr; int (*ptr)[3]; int *(*ptr)[4]; 指针的类型 从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型： 12345int *ptr; //指针的类型是int * char *ptr; //指针的类型是char * int **ptr; //指针的类型是 int ** int (*ptr)[3]; //指针的类型是 int(*)[3] int *(*ptr)[4]; //指针的类型是 int *(*)[4] 怎么样？找出指针的类型的方法是不是很简单？ 指针所指向的类型 当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。 从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如： 12345int *ptr; //指针所指向的类型是int char *ptr; //指针所指向的的类型是char int **ptr; //指针所指向的的类型是 int * int (*ptr)[3]; //指针所指向的的类型是 int()[3] int *(*ptr)[4]; //指针所指向的的类型是 int *()[4] 在指针的算术运算中，指针所指向的类型有很大的作用。 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。 指针的值 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。 指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 指针所指向的内存区和指针所指向的类型是两个完全不同的概念。 在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？ 指针本身所占据的内存区 指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。 指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int a[100];int main()&#123; char* t[] = &#123;\"p3423d\",\"wewr\",\"234\"&#125;; char* p=\"ewer\"; int b[100]; int* B=new int[10]; cout&lt;&lt;\"t \"&lt;&lt;sizeof(t)&lt;&lt;endl; cout&lt;&lt;\"p \"&lt;&lt;sizeof(p)&lt;&lt;endl; cout&lt;&lt;\"*t \"&lt;&lt;sizeof(*t)&lt;&lt;endl; cout&lt;&lt;\"*p \"&lt;&lt;sizeof(*p)&lt;&lt;endl; cout&lt;&lt;\"B \"&lt;&lt;sizeof(B)&lt;&lt;endl; cout&lt;&lt;\"*B \"&lt;&lt;sizeof(*B)&lt;&lt;endl; cout&lt;&lt;\"a \"&lt;&lt;sizeof(a)&lt;&lt;\" b \"&lt;&lt;sizeof(b)&lt;&lt;endl; char k[]=\"abcdef\"; cout&lt;&lt;dec&lt;&lt;(unsigned int)k[3]&lt;&lt;\" \"&lt;&lt;sizeof(k)&lt;&lt;endl; string s=\"abcdef\"; cout&lt;&lt;dec&lt;&lt;(unsigned int)s[6]&lt;&lt;\" \"&lt;&lt;sizeof(s)&lt;&lt;endl; k[3]='\\0'; cout&lt;&lt;k&lt;&lt;endl; s[6]='g'; cout&lt;&lt;s&lt;&lt;endl; int a1=0; cout&lt;&lt;sizeof(a1=3)&lt;&lt;endl; cout&lt;&lt;a1&lt;&lt;endl; return 0;&#125;t 24 一个指针8 3个就是24p 8 *t 8 指向了一个数组，还是个指针，如果是*t[1] 就是1*p 1 一个char是1B 8 指针*B 4 inta 400 b 400 数组100 7 0 24 string的sizeof在不同编译器中不一样，但char是可以的，strlen区别abcabcdef40 指针的算术运算 指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如： 例二： 12345 char a[20]; int *ptr=a; ... ... ptr++; 在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。 由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。 我们可以用一个指针和一个循环来遍历一个数组，看例子： 例三： 12345678910int array[20]; int *ptr=array; ... //此处略去为整型数组赋值的代码。 ... for(i=0;i&lt;20;i++) &#123; (*ptr)++; ptr++； &#125; 这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。再看例子： 例四： 12345char a[20]; int *ptr = a; ... ... ptr += 5; 在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。 如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。 总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。 运算符&amp;和* 这里&amp;是取地址运算符，* 是…书上叫做“间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个* ，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。p的运算结果就五花八门了。总之p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。 例五： 123456789int a=12; int b; int *p; int **ptr; p=&amp;a;//&amp;a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。 *p=24;//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。ptr=&amp;p;//&amp;p的结果是个指针，该指针的类型是p的类型加个*，在这里是int**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。 *ptr=&amp;b;//*ptr是个指针，&amp;b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以?amp;b来给*ptr赋值就是毫无问题的了。**ptr=34;//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。 指针表达式 一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子： 例六： 12345678int a,b; int array[10]; int *pa; pa=&amp;a;//&amp;a是一个指针表达式。 int **ptr=&amp;pa;//&amp;pa也是一个指针表达式。 *ptr=&amp;b;//*ptr和&amp;b都是指针表达式。 pa=array; pa++;//这也是指针表达式。 例七： 123456char *arr[20]; char **parr=arr;//如果把arr看作指针的话，arr也是指针表达式 char *str; str=*parr;//*parr是指针表达式 str=*(parr+1);//*(parr+1)是指针表达式 str=*(parr+2);//*(parr+2)是指针表达式 由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。 好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。 在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。ptr是一个左值，因为ptr这个指针已经占据了内存，其实ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么ptr当然也有了自己的位置。 数组和指针的关系 数组的数组名其实可以看作一个指针。看下例： 例八： 123456int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value; ... ... value=array[0];//也可写成：value=*array; value=array[3];//也可写成：value=*(array+3); value=array[4];//也可写成：value=*(array+4); 上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int ，所指向的类型是数组单元的类型即int。因此array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。 例九： 123456789char *str[3]=&#123; &quot;Hello,this is a sample!&quot;, &quot;Hi,good morning.&quot;, &quot;Hello world&quot; &#125;; char s[80]； strcpy(s,str[0]);//也可写成strcpy(s,*str); strcpy(s,str[1]);//也可写成strcpy(s,*(str+1)); strcpy(s,str[2]);//也可写成strcpy(s,*(str+2)); 上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char**，它指向的类型是char 。 str也是一个指针，它的类型是char，它所指向的类型是char，它指向的地址是字符串&quot;Hello,this is a sample!&quot;的第一个字符的地址，即’H’的地址。 str+1也是一个指针，它指向数组的第1号单元，它的类型是char*，它指向的类型是char 。 (str+1)也是一个指针，它的类型是char，它所指向的类型是char，它指向&quot;Hi,good morning.&quot;的第一个字符’H’，等等。 下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。 在不同的表达式中数组名array可以扮演不同的角色。 在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。 在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(array)测出的是数组单元的大小。 表达式array+n（其中n=0，1，2，…。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。 例十： 123int array[10]; int (*ptr)[10]; ptr=&amp;array; 上例中ptr是一个指针，它的类型是int (*)[10]，他指向的类型是int [10]，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array代表数组本身。 本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如： 1int (*ptr)[10]; 则在32位程序中，有： 123sizeof(int(*)[10])==4 sizeof(int [10])==40 sizeof(ptr)==4 实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。 指针和结构类型的关系 可以声明一个指向结构类型对象的指针。 例十一： 12345678910struct MyStruct &#123; int a; int b; int c; &#125; MyStruct ss=&#123;20,30,40&#125;;//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。MyStruct *ptr=&amp;ss;//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。int *pstr=(int*)&amp;ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。 请问怎样通过指针ptr来访问ss的三个成员变量？ 答案： 123ptr-&gt;a; ptr-&gt;b; ptr-&gt;c; 又请问怎样通过指针pstr来访问ss的三个成员变量？ 答案： 123*pstr；//访问了ss的成员a。 *(pstr+1);//访问了ss的成员b。 *(pstr+2)//访问了ss的成员c。 呵呵，虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元： 例十二： 12int array[3]=&#123;35,56,37&#125;; int *pa=array; 通过指针pa访问数组array的三个单元的方法是： 123*pa;//访问了第0号单元 *(pa+1);//访问了第1号单元 *(pa+2);//访问了第2号单元 从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。 所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个“填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。 所以，在例十二中，即使pstr访问到了结构对象ss的第一个成员变量a，也不能保证(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 通过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。 指针和函数的关系 可以把一个指针声明成为一个指向函数的指针。 123456int fun1(char*,int); int (*pfun1)(char*,int); pfun1=fun1; .... .... int a=(*pfun1)(\"abcdefg\",7);//通过函数指针调用函数。 可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。 THANKS","categories":[{"name":"C++","slug":"C","permalink":"https://ghostlo.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ghostlo.github.io/tags/C/"},{"name":"指针","slug":"指针","permalink":"https://ghostlo.github.io/tags/指针/"}]},{"title":"敏捷开发","slug":"敏捷开发","date":"2019-04-07T02:51:02.000Z","updated":"2019-04-07T02:56:31.000Z","comments":true,"path":"2019/04/07/敏捷开发/","link":"","permalink":"https://ghostlo.github.io/2019/04/07/敏捷开发/","excerpt":"","text":"迭代开发 敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。 那么什么是&quot;迭代开发&quot;呢？迭代的英文是 iterative，直译为&quot;重复&quot;，迭代开发其实就是&quot;重复开发&quot;。 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次&quot;大开发&quot;；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次&quot;大开发&quot;变成多次&quot;小开发&quot;，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 **迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。**开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。 增量开发 迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用&quot;增量开发&quot;（incremental development）划分迭代。 所谓&quot;增量开发&quot;，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼…每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶… 增量开发加上迭代开发，才算真正的敏捷开发。 敏捷开发的好处 早期交付 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的&quot;瀑布开发模式&quot;，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。 降低风险 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？ 对于软件项目来说，先有一个原型产品，了解市场的接受程度，往往是项目成功的关键。有一本书叫做《梦断代码》，副标题就是&quot;20+个程序员，三年时间，4732个bug，100+万美元，最后失败的故事&quot;，这就是没有采用敏捷开发的结果。相反的，Instagram 最初是一个地理位置打卡 App，后来发现用户不怎么在乎地理位置，更喜欢上传照片，就改做照片上传软件，结果成了独角兽。 由于敏捷开发可以不断试错，找出对业务最重要的功能，然后通过迭代，调整软件方向。相比传统方式，大大增加了产品成功的可能性。如果市场需求不确定，或者你对该领域不熟悉，那么敏捷开发几乎是唯一可行的应对方式。 如何进行每一次迭代 虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。 具体来说，每次迭代都必须依次完成以下五个步骤。 需求分析（requirements analysis） 设计（design） 编码（coding） 测试（testing） 部署和评估（deployment / evaluation） 每个迭代大约持续2~6周。 敏捷开发的价值观 《敏捷软件开发宣言》里面提到四个价值观。 程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。 软件能够运行，优于详尽的文档。 跟客户的密切协作，优于合同和谈判。 能够响应变化，优于遵循计划。 十二条原则 该宣言还提出十二条敏捷开发的原则。 通过早期和持续交付有价值的软件，实现客户满意度。 欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。 不断交付可用的软件，周期通常是几周，越短越好。 项目过程中，业务人员与开发人员必须在一起工作。 项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。 面对面交谈是最好的沟通方式。 可用性是衡量进度的主要指标。 提倡可持续的开发，保持稳定的进展速度。 不断关注技术是否优秀，设计是否良好。 简单性至关重要，尽最大可能减少不必要的工作。 最好的架构、要求和设计，来自团队内部自发的认识。 团队要定期反思如何更有效，并相应地进行调整。 来源：阮一峰","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://ghostlo.github.io/categories/软件工程/"}],"tags":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"https://ghostlo.github.io/tags/敏捷开发/"}]},{"title":"mysql-面试","slug":"mysql","date":"2019-04-06T14:19:09.000Z","updated":"2019-04-07T12:14:53.000Z","comments":true,"path":"2019/04/06/mysql/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/mysql/","excerpt":"","text":"Mysql中有哪几种锁？ 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 Mysql中有哪些不同的表格？ 共有5种类型的表格： MyISAM Heap Merge INNODB ISAM 另 简述在MySQL数据库中MyISAM和InnoDB的区别 MyISAM： 不支持事务，但是每次查询都是原子的；支持表级锁，即每次操作是对整个表加锁；存储表的总行数； 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件； MyIASM基于了IASM代码，应该可以说是IASM的衍生品，不过增加了不少有用的扩展。它是MySQL的默认数据表类型，基于了传统的ISAM类型，ISAM是Indexed Sequential Access Method（有索引的顺序访问方法）的缩写，一般来说，它是存储记录和文件的标准方法。与其他存储引擎比较，MyISAM具有检查和修复表格的大多数工具。ISAM表格可以被压缩，而且它们支持全文搜索，不过它们是事务不安全的，而且也不支持外键。如果事务回滚将会造成不完全回滚，从而不具备原子性。所以假如忽略事务以及访问并发性的话，并且需要执行大量的SELECT检索语句的话，MyISAM将是最好的选择。 MyISAM表(TYPE=MYISAM)是ISAM类型的一种延伸，具有很多优化和增强的特性。 是MySQL的默认表类型。 MyISAM优化了压缩比例和速度，并且可以很方便的在不同的操作系统和平台之间进行移植。 MyISAM支持大表文件(大于4G) 允许对BLOB和TEXT列进行索引 支持使用键前缀和使用完整的键搜索记录 表数据和表索引文件可以依存在不同的位置，甚至是不同的文件系统中。 即使是具有相当多的插入、更新和删除操作的表，智能防碎片逻辑也能保证其高性能的协作性。 InnoDb： InnoDB表(TYPE=INNODB)，是一个完全兼容ACID（事务的原子性、一致性、独立性及持久性）的、高效率的表完全支持MySQL的事务处理。精细的（行级和表级）锁提高了MySQL事务处理的带走度，同时其也支持无锁定读操作（以前只在Oracle中包含）和多版本的特性。 支持行级锁及外键约束：因此可以支持写并发 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制； 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。 异步输入/输出和一系列的读缓冲将提高数据检索速度，同时可以进行文件的优化和内存的管理。需要的基础上支持自动在内存上创建散列索引来提高性能，使用缓冲来提高可靠性和数据库操作的速度。InnoDB表可以和MyISAM相媲美，甚至已经超过了MyISAM。 在不同的操作系统和体系结构上是完全可移植的。由于一直处于一致的状态（MySQL通过在启动时检查错误并修复错误来使它们更加健壮）。对外键、提交、回滚和前滚的操作的支持，使其成为MySQL中最完善的表格式。 thanks Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？ SQL标准定义的四个隔离级别为： read uncommited ：读到未提交数据 read committed：脏读，不可重复读 repeatable read：可重读 serializable ：串行事物 CHAR和VARCHAR的区别？ 1.CHAR和VARCHAR类型在存储和检索方面有所不同 2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255 当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。 主键和候选键有什么区别？ 表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 myisamchk是用来做什么的？ 它用来压缩MyISAM表，这减少了磁盘或内存使用。 MyISAM Static和MyISAM Dynamic有什么区别？ 在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。 MyISAM Static在受损情况下更容易恢复。 如果一个表有一列定义为TIMESTAMP，将发生什么？ 每当行被更改时，时间戳字段将获取当前时间戳。 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？ 它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。 怎样才能找出最后一次插入时分配了哪个自动增量？ LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。 你怎么看到为表格定义的所有索引？ 索引是通过以下方式为表格定义的： SHOW INDEX FROM &lt; tablename &gt; ; LIKE声明中的％和_是什么意思？ ％对应于0个或更多字符，_只是LIKE语句中的一个字符。 如何在Unix和Mysql时间戳之间进行转换？ UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令 FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令 列对比运算符是什么？ 在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。 mysql_fetch_array和mysql_fetch_object的区别是什么？ 以下是mysql_fetch_array和mysql_fetch_object的区别： mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。 mysql_fetch_object – 从数据库返回结果行作为对象。 MyISAM表格将在哪里存储，并且还提供其存储格式？ 每个MyISAM表格以三种格式存储在磁盘上： “.frm”文件存储表定义 数据文件具有“.MYD”（MYData）扩展名 索引文件具有“.MYI”（MYIndex）扩展名 Mysql如何优化DISTINCT？ DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。 SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a; 如何显示前50行？ 在Mysql中，使用以下代码查询显示前50行： SELECT … FROM … LIMIT 0,50; 可以使用多少列创建索引？ 任何标准表最多可以创建16个索引列。 NOW（）和CURRENT_DATE（）有什么区别? NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 CURRENT_DATE（）仅显示当前年份，月份和日期。 什么是通用SQL函数？ CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。 FORMAT(X, D)- 格式化数字X到D有效数字。 CURRDATE(), CURRTIME()- 返回当前日期或时间。 NOW（） – 将当前日期和时间作为一个值返回。 MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。 HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。 DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄 SUBTIMES（A，B） – 确定两次之间的差异。 FROMDAYS（INT） – 将整数天数转换为日期值。 MYSQL支持事务吗？ 在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。 但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。 mysql里记录货币用什么字段类型好 NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。 例如： salary DECIMAL(9,2) 在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。 因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。 mysql有关权限的表都有哪几个？ Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。 列的字符串类型可以是什么？ 字符串类型是： SET BLOB 大二进制文件 ENUM CHAR TEXT 字符串类型 字节 描述及存储需求 CHAR(M) M M为0~255之间的整数 VARCHAR(M) M为0~65536之间的整数 TINYBLOB 允许长度0~255字节 BLOB 允许长度0~65535字节 MEDUIMBLOB 允许长度0~167772150字节 LONGBLOB 允许长度0~4294967295 TINYTEXT 允许长度0~255字节 TEXT 允许长度0~65535字节 MEDIUMTEXT 允许长度0~167772150字节 LONGTEXT 允许长度0~4294967295字节 VARBINARY(M) M 允许长度0~M个字节的边长字节字符集 BINARY(M) M 允许长度0~M个字节的定长字节字符集 CHAR于VARCHAR类型 CHAR和VARCHAR很类似，都是用来保存Mysql中较短的字符串，主要区别在于:CHAR列的长度固定为创建表时声明的长度，长度可以为从0255的任何值，而VARCHAR的值可以是变长字符串，长度可以指定065535之间的值，在检索的时候，CHAR列会删除尾部的空格而VARCHAR则保留了这些空格。 ENUM类型 枚举类型，忽略大小写，它的值范围需要在创建表时通过枚举方式显示指定，对1255个成员的枚举需要1个字节存储，对于25565535个成员，需要2个字节存储，最多允许65535个成员。 SET类型 SET和enum非常相似，里面可以包含0~64个成员，根据成员的不用，存储上也有不同。 1~8成员的集合，占1个字节 9~16成员的集合，占2个字节 17~24成员的集合，占3个字节 25~32成员的集合，占4个字节 33~64成员的集合，占8个字节 set类型一次可以选取多个成员，而ENUM则只能选一个，就相当于ENUM是单选，而set是复选。 什么是非标准字符串类型？ TINYTEXT TEXT MEDIUMTEXT LONGTEXT BLOB和TEXT有什么区别？ BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。 BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。 MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？ a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。 b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。 c. mysql库主从读写分离。 d. 找规律分表，减少单表中的数据量提高查询速度。 e。添加缓存机制，比如memcached，apc等。 f. 不经常改动的页面，生成静态页面。 g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 锁的优化策略 读写分离 分段加锁 减少锁持有的时间 多个线程尽量以相同的顺序去获取资源 不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。 索引的底层实现原理和优化 B+树，经过优化的B+树 主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。 什么情况下设置了索引但无法使用 以“%”开头的LIKE语句，模糊匹配 OR语句前后没有同时使用索引 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型） 实践中如何优化MySQL 最好是按照以下顺序优化： SQL语句及索引的优化 数据库表结构的优化 系统配置的优化 硬件的优化 详细可以查看 阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结 优化数据库的方法 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM 使用连接(JOIN)来代替子查询 适用联合(UNION)来代替手动创建的临时表 事务处理 锁定表、优化事务处理 适用外键，优化锁定表 建立索引 优化查询语句 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面） 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。 普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。 主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。 索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。 数据库中的事务是什么? 事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。 事务特性： （1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。 （2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态 （3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， （4）持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 或者这样理解： 事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 SQL注入漏洞产生的原因？如何防止？ SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。 防止SQL注入的方式： 开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置 执行sql语句时使用addslashes进行sql语句转换 Sql语句书写尽量不要省略双引号和单引号。 过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。 提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。 为表中得字段选择合适得数据类型 字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text 优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型 存储时期 Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，占用8个字节得存储空间，datatime类型与时区无关 Timestamp:以时间戳格式存储，占用4个字节，范围小1970-1-1到2038-1-19，显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改timestamp列得值 Date:（生日）占用得字节数比使用字符串.储存要少，使用date只需要3个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算 Time:存储时间部分得数据 注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，在进行查找过滤可以利用日期得函数） 使用int存储日期时间不如使用timestamp类型 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题： 索引的目的是什么？ 快速访问数据表中的特定信息，提高检索速度 创建唯一性索引，保证数据库表中每一行数据的唯一性。 加速表和表之间的连接 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 索引对数据库系统的负面影响是什么？ 负面影响： 创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。 为数据表建立索引的原则有哪些？ 在最频繁使用的、用以缩小查询范围的字段上建立索引。 在频繁使用的、需要排序的字段上建立索引 什么情况下不宜建立索引？ 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。 对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等 解释MySQL外连接、内连接与自连接的区别 先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。 内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。 外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中 的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。 左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。 Myql中的事务回滚机制概述 事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。 要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚 SQL语言包括哪几部分？每部分都有哪些操作关键字？ SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。 数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等 数据操纵：Select ,insert,update,delete, 数据控制：grant,revoke 数据查询：select 完整性约束包括哪些？ 数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类： 实体完整性：规定表的每一行在表中是惟一的实体。 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 什么是锁？ 数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。 基本锁类型 锁包括行级锁、表级锁、页面锁（见开头） 什么叫视图？游标是什么？ 视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。另不能在一张由多张关联表连接而成的视图上做同时修改两张表的操作；视图与表是一对一关系时如果没有其它约束（如视图中没有的字段，在基本表中是必填字段情况），是可以进行增删改数据操作；修改操作时要小心，不经意间你已经修改了基本表里的多条数据； 1234567891011121314151617181920DROP VIEWIF EXISTS `view_user_course`;CREATE ALGORITHM = UNDEFINED DEFINER = `root`@`localhost` SQL SECURITY DEFINER VIEW `view_user_course` AS ( SELECT `uc`.`id` AS `id`, `u`.`name` AS `username`, `c`.`name` AS `coursename` FROM ( ( `user` `u` LEFT JOIN `user_course` `uc` ON ((`u`.`id` = `uc`.`userid`)) ) LEFT JOIN `course` `c` ON ((`uc`.`courseid` = `c`.`id`)) )); 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 需要强调的是，游标必须在定义处理程序之前被定义，但变量必须在定义游标之前被定义，顺序就是变量定义-游标定义-处理程序。 定义游标：DECLARE cursor_name CURSOR FOR select_statement 这个语句声明一个游标。也可以在子程序中定义多个游标，一个块中的每一个游标必须命名唯一。声明游标后也是单条操作的。 游标OPEN：OPEN cursor_name 这个语句打开先前声明的游标。 游标FETCH：FETCH cursor_name INTO var_name [, var_name] … 这个语句用指定的打开游标读取下一行（如果有下一行的话），并且前进游标指针至该行。 游标CLOSE：CLOSE cursor_name 这个语句关闭先前打开的游标，注意，用完后必须关闭。 什么是存储过程？用什么来调用？ 答：存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。 如何通俗地理解三个范式？ 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性,为实现区分通常需要我们设计一个主键来实现 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。很多时候，我们为了满足第三范式往往会把一张表分成多张表。 范式化设计优缺点: 优点: 可以尽量得减少数据冗余，使得更新快，体积小 缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化 反范式化: 优点:可以减少表得关联，可以更好得进行索引优化 缺点:数据冗余以及数据异常，数据得修改需要更多的成本 什么是基本表？什么是视图？ 基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表 试述视图的优点？ 视图能够简化用户的操作 视图使用户能以多种角度看待同一数据 视图为数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护。 NULL是什么意思 NULL这个值表示UNKNOWN(未知):它不表示 &quot; &quot; (空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。 使用IS NULL来进行NULL判断 主键、外键和索引的区别？ 主键、外键和索引的区别 定义： 主键–唯一标识一条记录，不能有重复的，不允许为空 外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值 索引–该字段没有重复值，但可以有一个空值 作用： 主键–用来保证数据完整性 外键–用来和其他表建立联系用的 索引–是提高查询排序的速度 个数： 主键–主键只能有一个 外键–一个表可以有多个外键 索引–一个表可以有多个唯一索引 你可以用什么来确保表格里的字段只接受特定范围里的值? 答：Check限制，它在数据库表格里被定义，用来限制输入该列的值。 触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。 说说对SQL语句优化有哪些方法？（选择几条） （1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。 （2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。 （3）避免在索引列上使用计算 （4）避免在索引列上使用IS NULL和IS NOT NULL （5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 （6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 （7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描 on与where sql连接方式为嵌套循环连接。一层一层的连接，循环用外层结果集的记录行和内层的所有符合条件ON条件的记录依次连接，内层没有符合条件的生成所有字段为null的记录行，当不存在ON条件是以“笛卡尔积”的形式连接。连接过后where过滤，再连接，在过滤，直到左右表均连接完毕。连接完毕后有group by字句则执行分组，有having字句的则对分组后的结果集再过滤，所以having执行在where之后，因此有些条件放where字句内能缩小分组前的结果集，提高执行效率。之后还有order by字句的则执行排序，最后得到查询的结果。 where里可能有关于每张表的筛选条件，不同表的条件生效时期不同。对于驱动表，在执行一开始就会通过where上关于词表的条件筛选一条或者一批记录，然后通过on条件关联下一张表，将得到的结果集再用where上第二张表的条件做过滤，然后重复此过程直到所有表关联完毕。也就是对于驱动表，因为只有where生效，对于其他被驱动表，先被on关联，也就是on先生效，然后再用where过滤关联的结果集。同时对于外表连接，比如left join和right join，把条件放在on上，如果被关联表没有匹配上，那么外表还是能放入结果集的；而如果将条件放在where上，因为where是对关联后的结果做过滤，此时之前匹配的记录也会被筛选掉。thanks sql and nosql SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL，PostgreSQL。 NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB，Redis，CouchDB。 sql优点 事务处理—保持数据的一致性 由于以标准化为前提，数据更新的开销很小（相同的字段基本上只有一处） 可以进行Join等复杂查询 sql缺点 扩展困难：由于存在类似Join这样多表查询机制，使得数据库在扩展方面很艰难; 读写慢：这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重 成本高：企业级数据库的License价格很惊人，并且随着系统的规模，而不断上升 nosql优点 Nosql的存储方式灵活，NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。 简单的扩展：典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群 快速的读写：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作 低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本 thanks","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ghostlo.github.io/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ghostlo.github.io/tags/mysql/"},{"name":"面试","slug":"面试","permalink":"https://ghostlo.github.io/tags/面试/"}]},{"title":"并发","slug":"并发","date":"2019-04-06T13:47:29.000Z","updated":"2019-04-06T14:03:01.000Z","comments":true,"path":"2019/04/06/并发/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/并发/","excerpt":"","text":"什么是并发： 并发是指多个执行任务同时、在一个较长的时间段内可认为是并行被执行。 什么是并行： 并行就是指多个任务同时执行 什么是竞态： 字面意思是竞争，并发的执行单元对共享资源（硬件资源和软件上的全局变量，静态变量等）的访问容易发生竞态。 对于一个虚拟的字符设备驱动，假设一个执行单元A对其写入300个字符‘a’，而另一个执行单元B对其写入300个字符‘b’，第三个执行单元读取所有字符。如果A、B被顺序串行执行那么C读出的则不会出错，但如果A、B并发执行，那结果则是我们不可料想的。 竞态发生的情况 对称多处理器（SMP）的多个CPU： SMP是一种紧耦合、共享存储的系统模型，它的特点是多个CPU使用共同的系统总线，因此可以访问共同的外设和存储器。 单CPU内进程与抢占它的进程： Linux 2.6的内核支持抢占调度，一个进程在内核执行的时候可能被另一高优先级进程打断。 中断（硬中断、软中断、tasklet、低半部）与进程之间：中断可以打断正在执行的进程，处理中断的程序和被打断的进程间也可能发生竞态。 竞态的解决办法 解决竞态问题的途径是保证对共享资源的互斥访问。访问共享资源的代码区域称为临界区，临界区要互斥机制保护。Linux设备驱动中常见的互斥机制有以下方式：中断屏蔽、原子操作、自旋锁和信号量等。 临界区 Most readers would agree that this scenario is best avoided. Therefore, the core rule that applies to spinlocks is that any code must, while holding a spinlock, be atomic.It cannot sleep; in fact, it cannot relinquish the processor for any reason except toservice interrupts (and sometimes not even then). 互斥锁和自旋锁、信号量的区别 互斥锁和互斥量 在我的理解里没啥区别，不同叫法。广义上讲可以值所有实现互斥作用的同步机制。狭义上讲指的就是mutex这种特定的二元锁机制。互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的 。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。 信号量（semaphore） 是一种更高级的同步机制，mutex（互斥锁） 可以说是 semaphore（信号量） 在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。 程序运行状态 开始 运行 就绪 阻塞 结束 互斥锁：常用，使用后需要的程序进入就绪态，通常情况下锁操作失败会将该线程睡眠等待锁释放时被唤醒 自旋锁：相比一般的互斥锁会在等待期间放弃cpu，使用硬件提供的swap指令或test_and_set指令实现，自旋锁则是不断循环并测试锁的状态，这样就一直占着cpu。所以相比于自旋锁和信号量，在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒休眠的线程。可以联想到程序查询中断方式。 递归锁：严格上讲递归锁只是互斥锁的一个特例，同样只能有一个线程访问该对象，但允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作，直到一个线程所有的acquire都被release，其他的线程才能获得资源。 windows下的临界区默认是支持递归锁的，而linux下的互斥量则需要设置参数PTHREAD_MUTEX_RECURSIVE_NP，默认则是不支持。 读写锁(rwlock)：高级别锁，区分读和写，符合条件时允许多个线程访问对象。处于读锁操作时可以允许其他线程和本线程的读锁， 但不允许写锁， 处于写锁时则任何锁操作都会睡眠等待；常见的操作系统会在写锁等待时屏蔽后续的读锁操作以防写锁被无限孤立而等待，在操作系统不支持情况下可以用引用计数加写优先等待来用互斥锁实现。 读写锁适用于大量读少量写的环境，但由于其特殊的逻辑使得其效率相对普通的互斥锁和自旋锁要慢一个数量级；值得注意的一点是按POSIX标准 在线程申请读锁并未释放前本线程申请写锁是成功的，但运行后的逻辑结果是无法预测 另外注意并发时候stl的改变","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://ghostlo.github.io/categories/操作系统/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://ghostlo.github.io/tags/并发/"}]},{"title":"数据库事务的四大特性以及事务的隔离级别","slug":"数据库事务的四大特性以及事务的隔离级别","date":"2019-04-06T08:38:07.000Z","updated":"2019-04-08T08:20:56.000Z","comments":true,"path":"2019/04/06/数据库事务的四大特性以及事务的隔离级别/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/数据库事务的四大特性以及事务的隔离级别/","excerpt":"","text":"​ 如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性： 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。 持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题： 脏读 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下 123update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’; 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。 不可重复读 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了…… 虚读(幻读) 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 隔离级别 现在来看看MySQL数据库为我们提供的四种隔离级别： Serializable (串行化) 可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读) 可避免脏读、不可重复读的发生。 Read committed (读已提交) 可避免脏读的发生。 Read uncommitted (读未提交) 最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。 在MySQL数据库中查看当前事务的隔离级别： 1select @@tx_isolation; 在MySQL数据库中设置事务的隔离 级别： 123set [glogal | session] transaction isolation level 隔离级别名称;set tx_isolation=’隔离级别名称;’ 例1：查看当前事务的隔离级别： 例2：将事务的隔离级别设置为Read uncommitted级别： 或： 记住：设置数据库的隔离级别一定要是在开启事务之前！ 如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段： 在JDBC中设置隔离级别的部分代码： 后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 参考博客： http://www.zhihu.com/question/23989904 http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html http://www.cnblogs.com/xdp-gacl/p/3984001.html 来源","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ghostlo.github.io/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ghostlo.github.io/tags/数据库/"},{"name":"mysql","slug":"mysql","permalink":"https://ghostlo.github.io/tags/mysql/"}]},{"title":"面试--抛棋子","slug":"面试-抛棋子","date":"2019-04-06T08:36:07.000Z","updated":"2019-04-07T03:38:10.000Z","comments":true,"path":"2019/04/06/面试-抛棋子/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/面试-抛棋子/","excerpt":"","text":"问题 有一个一百层高的大厦，从这个大厦的某一层扔下棋子恰好就会碎（称这一层为临界层）。请你用手中的两个玻璃围棋子，找出一个最优的策略来得出那个最优层。 分析：题目要求策略最优，因而要使得在最坏的情况下投掷的总次数 $$T_{max}$$ 最少。首先考虑只有一个棋子的情况，条件若为多个棋子则可转化为一个棋子的情况。 解答 一个棋子 棋子必须在临界层扔下的时候碎，所以唯一的策略是从1层往上逐层投掷，此时$$T_{max} =99$$，临界层为99层或100层（因为题目告诉100层肯定会碎，如果99层没碎，那表示临界层即为100） 两个棋子 利用多的这个棋子缩小查找的范围，因而把100层分成若干段：先利用一个棋子来确定临界层所在的段，再利用另一个棋子确定临界层，总的投掷次数等于确定临界段的次数$$n_{1}$$和确定临界层的次数$$n_{2}$$的和 现把100层平均分成n段（n是100的正因数），有$$T_{max}= (n-1) + \\frac{100}{n-1} = n + \\frac{100}{n}-2$$由均值不等式可知n=10时，$$T_{max} =18$$为最小值，此时临界段为第80~90层，临界层为第89层。如果把100层分成12段$$(100=9\\times 11+1)$$：19,1018,…91~99,100,与上述n=10的情况相比虽然每段的层数在减少（从而$$n_{1}$$在减少），但所分的段数在增加（从而$$n_{2}$$在增加），因而$$T_{max}$$并没有减少。如果把100层分成其他段（比如9段：$$100=12\\times 8+4$$，情况也是如此. 根据上面的讨论，如何把100层合理地分段是关键。上述对100层所分段数的调整并没有使得$$T_{max} =18$$减少的原因在于每段包含的层数比较均匀(图1)，因而出现$$n_{1}$$和$$n_{2}$$此消彼长的情况。鉴于此我们做出以下方式的调整： 把100层分成若干段，从下往上，每段的层数逐渐少1（图2），这样就使得在最坏的情况下，$$n_{1}$$增加1的同时$$n_{2}$$减少1，因而$$n_{1}$$与$$n_{2}$$的总和不变（等于第一段的层数n）,为确定n的值，只需要解不等式$$n+(n-1)+(n-2)+…+1\\geq 100$$,从而得到n=14 从第14层开始扔第一枚棋子，如果没有碎则从第14+13=27层开始扔，如果还没有碎则从14+13+12=39层开始扔，以此类推，此时$$T_{max} =14$$,临界层可为第27层，第39层，…第99层。 拓展： 对于m层楼高，k个球的扔棋子问题，又该怎么做？ 答案是用动态规划的思想：如果是三个棋子，100层楼，我扔了一次棋子碎了以后，就变成2个棋子的问题了，因此可以利用上面的结果： （x∗(x−1)/2+((x−1)∗(x−2)/2)+…+3+1&gt;=100.（x*(x-1)/2+((x-1)*(x-2)/2)+…+3+1&gt;=100. （x∗(x−1)/2+((x−1)∗(x−2)/2)+…+3+1&gt;=100. 推广 从上面的讨论可以发现此题的关键是（高阶）等差数列： 两个棋子：1 2 3 4 5…$$\\sum_{i=1}{n}{C_{i}{1} \\geq }100$$! 三个棋子：1 3 6 10 15… $$\\sum_{i=2}{n}{C_{i}{2} }\\geq 100$$ 因而我们还可以考虑大楼有m层，棋子有k个的情况 $$\\sum_{ i=k}{n}{C_{i}{k} } \\geq m$$ 算法证明：对 $$m$$ 层楼，k个棋子的问题，存在复杂度为 $$O(\\sqrt[y]{m})$$ 的算法。 thanks","categories":[{"name":"面试","slug":"面试","permalink":"https://ghostlo.github.io/categories/面试/"}],"tags":[{"name":"建模","slug":"建模","permalink":"https://ghostlo.github.io/tags/建模/"},{"name":"数学","slug":"数学","permalink":"https://ghostlo.github.io/tags/数学/"}]},{"title":"cookie 与 session 的区别","slug":"cookie-与-session-的区别","date":"2019-04-04T12:26:55.000Z","updated":"2019-04-04T12:29:05.000Z","comments":true,"path":"2019/04/04/cookie-与-session-的区别/","link":"","permalink":"https://ghostlo.github.io/2019/04/04/cookie-与-session-的区别/","excerpt":"","text":"原文链接：mp.weixin.qq.com 本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有一个更深入的了解，并对自己的开发工作中灵活运用带来启示。 cookie机制 Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。 具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。 session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。 session机制 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。 Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。 不同 1、存取方式的不同 Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。 而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 2、隐私策略的不同 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。 假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。 3、有效期上的不同 使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。 由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。 4、服务器压力的不同 Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。 而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。 5、浏览器支持的不同 Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。 假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。 假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干） 6、跨域支持上的不同 Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。 仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。","categories":[],"tags":[]},{"title":"同步异步阻塞非阻塞","slug":"同步异步阻塞非阻塞","date":"2019-04-04T12:26:17.000Z","updated":"2019-04-04T12:26:41.000Z","comments":true,"path":"2019/04/04/同步异步阻塞非阻塞/","link":"","permalink":"https://ghostlo.github.io/2019/04/04/同步异步阻塞非阻塞/","excerpt":"","text":"同步： 所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事 异步： 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕 阻塞： 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。 有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。 非阻塞： 非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 再简单点理解就是： 同步，就是我调用一个功能，该功能没有结束前，我死等结果。 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞 阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回 综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。","categories":[],"tags":[]},{"title":"Hexo 安装","slug":"安装-Hexo","date":"2019-04-04T11:38:48.000Z","updated":"2019-04-07T11:57:54.000Z","comments":true,"path":"2019/04/04/安装-Hexo/","link":"","permalink":"https://ghostlo.github.io/2019/04/04/安装-Hexo/","excerpt":"","text":"安装 首先安装如下两个包 Node.js Git 安装好之后初次运行Git需要做一些配置： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 文档 npm安装时改源 npm 安装报错 rollbackFailedOptional verb npm-session 解决办法 npm config set registry http://registry.npm.taobao.org 建站 Hexo安装好了之后，就开始进行建站。打开终端cd到桌面并使用如下命令即可建好 hexo init name cd name 常用参数 clean Remove generated files and cache. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. new Create a new post. server Start the server. deploy注意事项 1:排查-&gt;是否安装一下hexo-deployer-git这个模块 没有安装:npm install hexo-deployer-git --save使用指令安装 2:排查-&gt;_config.yml 这个文件的deploy写了没有;写全了没有 我的就是因为_config.yml中deploy下的type等前面没有空格导致。。。。。 hexo d 提示You should configure deployment settings in _config.yml first! 123deploy: type: repo: hexo d/deploy 时遇到问题再试一次，可能是用户名密码没有来得及输入，， 主题 next主题 deploy后github上未显示主题 If your site is put in a subdirectory, set url as ‘http://yoursite.com/child’ and root as ‘/child/’ url: https://ghostlo.github.io/ostlo root: /ostlo/ 后续 后续的修改只需要重复第5步就可以了，代码如下： 1234cd 本地库目录git add .git commit -m &quot;版本日志&quot;git push -u origin master Hexo 配置1 Hexo 配置2 GitHub还有很多好功能有待开发，善于利用搜索引擎，have fun~ 推荐阅读","categories":[{"name":"建站","slug":"建站","permalink":"https://ghostlo.github.io/categories/建站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ghostlo.github.io/tags/hexo/"}]}]}