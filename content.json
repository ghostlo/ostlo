{"meta":{"title":"Ostlo's Blog","subtitle":null,"description":null,"author":"Ostlo_TL","url":"https://ghostlo.github.io","root":"/ostlo/"},"pages":[{"title":"about","date":"2019-04-04T01:58:55.000Z","updated":"2019-04-27T07:03:16.000Z","comments":true,"path":"about/index.html","permalink":"https://ghostlo.github.io/about/index.html","excerpt":"","text":"bug:mathjax加载还有点问题 C后为毛会出横线？？？ 记事本记录下来一些事吧，防止以后忘了 2015年，大学入学 2016年，加入北京市魏公村汽配维修服务站微纳物理实验中心，玩二维材料，准备测$MoTe_{2}$同质结的性质 2017年，春初，发现$MoTe_{2}$这个东西似乎也不是肖特基结哎，它tm是个欧姆接触（简称电阻），那还测个啥，正好导师要忙他的实验，我还菜，遂停止实验 2017年，夏末，嗯，别人测$MoTe_{2}$欧姆结性质发了篇SCI，似乎还是一区？？？ 2017年，秋天，感觉凝聚态物理不符合自己对未来的追求，去美国还得考GRE-sub，遂考虑转行，在金融和计算机之前摇摆不定 2017年，秋末，跟姐姐一番沟通之后，发现金融似乎也不是我想象的那样，小手一挥，千亿到手，于是放弃了继续读经济双学位 2017年，冬天，本着水一水的态度参加了圆明园职业技术学院的金融学院考研初试，不出意外，0分，但他们的暖气是真的好 2018年，春初，跟老哥一番沟通之后，感觉计算机很符合我对未来的要求，对人类目前最高成就cpu操作想想就刺激，下定决心搞计算机，考研 2018年，夏初，搞定数据结构，操作系统入门 2018年，夏天，学院要搞什么精（金？）工实习，还要换校区，耽搁了考研的准备。7月20日左右正式开始准备考研，虽然是很水的那种，期间发现宿舍有臭虫，吸血的那种，浑身被吸了很多包，最大的那个在5cm*7cm左右，图片过于恶心就不放了，不过后面还好联系了人把虫杀了。但，厕所还是有虫啊，各种各样的，难以直视，后面厕所也装修了。哦，对，这段时间还装了个空调，每天都跟我说今天来装，我就在宿舍傻待着等他来装空调，当时气温34度左右 2018年，夏末，厕所维修好，没虫了，真好。图书馆的空调也是美滋滋，除了蚊子多。考研至此大概比计划落后20天左右，用host关闭常上的网站，认真考研，6：45起，12点睡 2018年，秋天，我记得这个时候在浴室里滑了一跤，脚上破了贼长一道口子，贴好创口贴，一瘸一拐去图书馆。图书馆总有人把键盘敲得啪啪响，我也是服了。这个时候还填了考研志愿，思来想去不想去北理，最后选了地狱难度的五道口男子技校的计算机学院 2018年，冬天，考研前夕，是完全不想学，感觉自己可牛逼了，啥都会，但仔细想想啥都不会，肖大爷的资料是哭了都背不出来 2018年，冬天，24，25考研，吐槽一句，六教的暖气是真的不好，差点给我冻感冒了 2018年，冬天，考验后，感觉自己gg，数学一堆不会，虽然最后都做出来了，但感觉就是不太好，回去自由自在的玩 2019年，春天，发现自己竟然过了初试？数学分还不低？这老师咋改卷的？后来问了一下，大家分都比较高，可能是那帮老头发现卷子太难降低阅卷标准？既然过了初试，去联系下导师，但没一个说有名额，尴尬，最后有个老师对我挺感兴趣，美中不足是他只有学硕名额，而我只能报专硕。。。 2019年，春末，感觉五道口男子技校的计算机学院面试不太稳，况且五道口男子技校网研院的老师跟我说我这跨考，悬，遂报网研院的调剂，伤心的一批，读不了我最爱的人工智能，安心准备计算机网络的笔试。听说他们计算机学院笔试题还换了？算了，不操心了，反正我去网研院，美滋滋 2019年，笔试前一天晚，打电话通知我材料被刷了，？？？，我特么分在他们专业第二名刷我？问了一下说不要跨考的调剂，我内心mmp，前几天还把为了复试订的房间退了，哎，安心准备计算机学院笔试，关键是这笔试完全和我寒假准备的不一样啊，难道让我一天晚上学完两本书？想骂人 2019年3月15日 上机+笔试，让我们1：30来熟悉环境，于是让我们在走廊熟悉了1h走廊环境，2：30才上机，3点才考试，今年上机题真的是简单到爆炸，第一题15min搞定，可惜我做大数除法的时候脑袋抽风（可能与没有午休有关），非要把前面的0去掉，耽搁3h，遂上机gg。上机完每人发了一个小小的汉堡充饥，继续笔试，笔试勉强能背出来昨天抢记的东西，感觉也gg 2019年3月17日上午 参加专硕的面试，我是第二个面试，，然而我在外面整理我的材料的时候他们就叫我进去面试，英语面成功的忘了自己的台词，感觉又一次gg，后来外面的志愿者跟我说主要看教授想不想要我，重燃信心，继续参加专业面试，感觉在台上和台下的大佬谈笑风生，以为自己稳了，下午就去high 2019年3月17日晚上 群里说不录取名单出来了，我问了一下，我名字在榜上，嗯 2019年3月18日 发现清华校内已经没有多少调剂名额了，唯一的一个是微纳电子实验室的调剂，于是准备去那，交了调剂表，想着我逃了几年又回来了？？？ 2019年的后面几天吧，日期记不清了，那几天浑浑噩噩的，后面发生的一些事：群里一老哥发消息说有个生物的老师招调剂，直接联系就行，遂联系老师，当晚去老师办公室聊天，说是把我按计算机方向培养，她也需要人帮她设计深度学习模型，医疗器件那方面的，我感觉还不错，就决定去她的组，第二天上午交表的时候一个学生收的表说的好好的，下午来笔试就可以了，下午笔试的时候教务处的老师跟我说我之前没交调剂表，不能参加考试，还说给我联系其它地方的调剂。玩我呢，这是？然后问生物的那个教授，她跟我说去年可以直接来的。来之前我想着生物这边稳了，就把微电子那边的调剂给拒了，好了，接着腆着脸去微电子那边，微电子教务处也是个奇葩，她说我口头据了就不能参加面试了，我差点给他下跪才同意再把我名字加上。后面的微电子的面试不想谈了，反正就一奇葩学院。但是，我面试完之后感觉问题很坑，告诉了后面俩人，后来我才知道面试问题都是一样的。最后看录取名单，就他们俩录了，嗯 2019年3月25日 参加北京市魏公村汽配维修服务站计算机学院非全日制面试，上机很简单，一半时间都没用就全部ac，其它人还在那冥思苦想，想想未来跟他们一起就难受的一批，后面理所当然拿了非全第一名 2019年4月9日 老师联系我去她那读 2019年4月20日 被今日头条捞，开心，不用再考研了 2019年4月24日 跟清华一大佬吃饭，得知未来方向应该是*****，还有，清华的笔试试卷是**的哦，还有，调剂是\\**的哦，最后他说来清华玩，我说，我的心累了，不想再看到清华的校门，于是分开，回学校 2019年4月27日 接到一神秘电话，说是清华的老师，当时要我来着，分也给的很高，但后来可能其它老师给的分很低（我后来才知道他们导师之间关系也不好），就把我刷了，嗯，故事就到这里"},{"title":"tags","date":"2019-04-04T01:37:18.000Z","updated":"2019-04-04T01:39:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://ghostlo.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-16T02:21:54.000Z","updated":"2019-04-16T02:21:54.000Z","comments":true,"path":"wait/2019秋招补招 | 字节跳动-后端开发-补招一面面经.html","permalink":"https://ghostlo.github.io/wait/2019秋招补招 | 字节跳动-后端开发-补招一面面经.html","excerpt":"","text":"作者：Angus-Liu 链接：https://www.nowcoder.com/discuss/146848 来源：牛客网 15 号在牛客网上找到好心人帮忙内推后端开发（非常感谢！），今天获得了视频面试资格，下面是面试官问的一些问题： TCP 安全性体现在哪些方面，采用了哪些机制？ 发送大文件时客户端和服务端采取了什么机制？描述一下 Nagel 算法？ 要实现两台机器及时高效通讯应该怎么做？如何关闭 Nagel 算法？ socket 中 SO_REUSEPORT 和 SO_REUSEADDR 的区别？ select、epool 的区别？底层的数据结构是什么？ Python 中的协程了解吗？（简历上写了了解 Python） React 中如何实现双向数据绑定？（Vue 和 React 我都学了，不过 React 用得少） 直接 I/O 和缓冲 I/O 区别？ volatile 关键字的作用？Java 内存模型？ 讲一下垃圾回收算法？ Java 内存分配策略？多个线程同时请求内存，如何分配？ Redis 底层用到了哪些数据结构？使用 Redis 的 set 来做过什么？ Redis 使用过程中遇到什么问题？搭建过 Redis 集群吗？ MySQL 索引结构解释一下？（B+ 树） MySQL Hash 索引适用情况？举下例子？ 存储一个 Blob 文件，如何建索引？如果前缀部分大都相似怎么办？文件大小相差太多怎么办？ MySQL 索引是不是越多越好？为什么？ 如何分析“慢查询”日志进行 SQL/索引 优化？ Java 中 final 关键字实现原理？（怎么实现不可变性） 如何实现一个 HashMap？ 手写“反转链表”算法？（迭代和递归） 因为题目比较多，有可能部分我记错了（但大体是差不多的），大家就参考一下吧。最后我还问了一些问题，字节跳动的面试官很 Nice，都一一解答了。即使最后拿不到 Offer，对我来说也是一次提升了。非常感谢！ 与作者交流：https://www.nowcoder.com/discuss/146848 更多笔经面经：https://www.nowcoder.com/discuss?order=0&amp;type=2"},{"title":"","date":"2019-04-25T01:55:59.000Z","updated":"2019-04-25T01:55:59.000Z","comments":true,"path":"wait/VSCode 插件.html","permalink":"https://ghostlo.github.io/wait/VSCode 插件.html","excerpt":"","text":"装上这几个 VSCode 插件后，上班划水摸鱼不是梦 GitHub Daily 公众号 &amp; 微博：GitHubDaily 2,346 人赞同了该文章 最近在 微博 分享了几个 VSCode 划水插件，让我不禁感叹这班程序员也太会玩了吧。 今天我就花点时间，简单整理下这几个划水插件，让大家可以分享给朋友，一起愉快的划水摸鱼 👀 daily-anime如果你喜欢二次元，喜欢动漫，那这个插件就是为你量身定制的。 这款插件让开发者可以在 VSCode 上划水追番，第一时间知道番剧的更新。 GitHub 地址：https://github.com/deepred5/daily-anime read-vscode-e上学那会偷偷摸摸看小说被老师逮到的情景现今依旧历历在目，后面我们学精了，在小说本上套上一层课本封面，以此来掩盖上课划水的行为。 read-vscode-e 这个插件感觉跟上课看小说的经历有点像，他让开发者可以在 VSCode 上边写代码边看小说。 下次等产品经理路过你身旁的时候，以为你写了一堆密密麻麻的的代码，都不好意思再给你加需求。 GitHub 地址：https://github.com/my-soul/read-vscode-e vsc-netease-music美妙的音乐配合上 VSCode 更显极客范。 装上这款插件之后，你就可以使用 VSCode 愉快的听歌啦~ GitHub 地址：https://github.com/nondanee/vsc-netease-music vscode-maxPlus番剧、小说、音乐都齐了，还差什么？当然是游戏啦！ maxPlus 这个插件让你可以在 VSCode 上畅快浏览 Max+ 的游戏资讯，多重体验美滋滋~ GitHub 地址：AShujiao/vscode-maxPlus vscode-stocks据说最近股市行情不错，你那颗韭菜小心心又开始躁动不安了？ 来来来，请服下我为你开的这贴良药。 Stocks 是 VSCode 上的一个炒股插件，装上之后，你就可以很轻松的在 VSCode 上查看最新股市行情了。 GitHub 地址：roblourens/vscode-stocks vscode-leetcode如果你怕上面几个插件玩久了变得太过颓废，不思进取，那不妨装下 vscode-leetcode 这个插件。 这个插件让你可以在 VSCode 上刷 LeetCode，提醒你写代码的同时也不要忘了最爱的 LeetCode 哦。 GitHub 地址：https://github.com/jdneo/vscode-leetcode 如果你有什么其他好玩的 VSCode 插件，也欢迎在留言区进行评论，或到微博（GitHubDaily）私信分享给我，这篇文章后续还会保持不断更新的~ 推荐阅读： GitHub Daily：我在 GitHub 上都见过哪些沙雕项目？zhuanlan.zhihu.com GitHub Daily：这 10 款插件让你的 GitHub 更好用、更有趣zhuanlan.zhihu.com GitHub Daily：我是如何发现优质开源项目的？zhuanlan.zhihu.com"},{"title":"go学习（三）","date":"2019-04-23T01:32:28.000Z","updated":"2019-04-23T03:45:50.000Z","comments":true,"path":"wait/go学习3.html","permalink":"https://ghostlo.github.io/wait/go学习3.html","excerpt":"","text":"rune123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; s:= \"ostlo 测试！\" fmt.Println(s) for _,b:=range []byte(s)&#123; fmt.Printf(\"%x\\t\",b) &#125; fmt.Println() for i,ch :=range s&#123;// ch is a rune fmt.Printf(\"(%d %X)\",i,ch)//utf-8解码-&gt;unicode &#125; fmt.Println() fmt.Println(\"Rune count:\",utf8.RuneCountInString(s)) bytes:=[]byte(s) for len(bytes)&gt;0&#123; ch, size :=utf8.DecodeRune(bytes) bytes=bytes[size:] fmt.Printf(\"%c\",ch) &#125; fmt.Println() for i,ch :=range []rune(s)&#123; fmt.Printf(\"(%d %c)\", i, ch) &#125; fmt.Println()&#125;/*6f 73 74 6c 6f 20 e6 b5 8b e8 af 95 ef bc 81 (0 6F)(1 73)(2 74)(3 6C)(4 6F)(5 20)(6 6D4B)(9 8BD5)(12 FF01)Rune count: 9ostlo 测试！(0 o)(1 s)(2 t)(3 l)(4 o)(5 )(6 测)(7 试)(8 ！)*/ 12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"func lengthofNonRepeatingSubStr1(s string) int&#123; lastOccured:=make(map[rune] int) start:=0 maxLength:=0 for i,ch := range []rune(s)&#123;//range s每个中文算3个长 if lastI, ok :=lastOccured[ch];ok &amp;&amp;lastI&gt;=start&#123; start=lastI+1 &#125; if i-start+1&gt;maxLength&#123; maxLength=i-start+1 &#125; lastOccured[ch]=i &#125; return maxLength&#125;func main() &#123; fmt.Println(lengthofNonRepeatingSubStr1(\"abcba\")) fmt.Println(lengthofNonRepeatingSubStr1(\"\")) fmt.Println(lengthofNonRepeatingSubStr1(\"abcv3a\")) fmt.Println(lengthofNonRepeatingSubStr1(\"中文测试\")) fmt.Println(lengthofNonRepeatingSubStr1(\"中文中文测试测试\"))&#125;/*30544*/ struct123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport \"fmt\"type treeNode struct&#123; value int left,right *treeNode//没有构造函数&#125;//工程函数func creatNode(value int) *treeNode&#123; return &amp;treeNode&#123;value: value&#125;//可以直接返回局部变量的地址&#125;func (node treeNode) print()&#123;//node treeNode 相当于*this指针 fmt.Println(node.value)&#125;func (node treeNode) setvalue(value int)&#123;//拷贝 node.value=value&#125;func (node *treeNode) setvalue_p(value int)&#123;//使用指针才能改变结构的内容 if node==nil &#123; fmt.Println(\"set value to nil node\") return &#125; node.value=value&#125;func (node *treeNode) traverse()&#123; if node==nil&#123; return &#125; node.left.traverse() node.print() node.right.traverse()&#125;func main() &#123; var root treeNode root=treeNode&#123;value:3&#125; root.left = &amp;treeNode&#123;&#125; root.right = &amp;treeNode&#123;5,nil,nil&#125; root.right.left = new(treeNode) nodes := []treeNode&#123; &#123;value:3&#125;, &#123;&#125;, &#123;6,nil,&amp;root&#125;, &#125; fmt.Println(nodes) root.right.left=creatNode(2) root.print() root.right.left.setvalue(4) root.right.left.print() root.right.left.setvalue_p(4) root.right.left.print() var pRoot *treeNode pRoot.setvalue_p(10) //pRoot.print() pRoot = &amp;root pRoot.setvalue_p(20) pRoot.print() fmt.Print(\"开始遍历\\n\") root.traverse()&#125;/*[&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;6 &lt;nil&gt; 0xc000086000&#125;]324set value to nil node20开始遍历02045*/ 那么在堆上还是栈上呢，不需要知道，有编译器设置，如果发现了地址的引用之类的就在堆上，没有返回此引用的话就在栈上"},{"title":"go学习（二）","date":"2019-04-22T08:36:07.000Z","updated":"2019-04-22T13:46:15.000Z","comments":true,"path":"wait/go学习2.html","permalink":"https://ghostlo.github.io/wait/go学习2.html","excerpt":"","text":"Go语言特点 学习内容 项目学习 变量类型 rune是个字符型（char），与utf-8与unicode编码接轨，是32位 complex64 float32+float32 complex128 float64+float64 类型转换是强制的，没有隐式变量转换 变量与枚举iota if12345678910111213141516package mainimport ( \"fmt\" \"io/ioutil\")func main() &#123; const filename=\"trans/abc.txt\" if contents, err := ioutil.ReadFile(filename) ; err!=nil&#123; fmt.Println(err) &#125;else&#123; fmt.Printf(\"%s\\n\",contents) fmt.Println(contents) &#125;&#125; abc[97 98 99] switch for 死循环 123for &#123;&#125; 可变函数列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( \"fmt\" \"math\" \"reflect\" \"runtime\")func eval(a,b int, op string)(int, error)&#123; switch op &#123; case \"+\": return a+b,nil case \"-\": return a-b,nil case \"*\": return a*b,nil case \"/\": q, _ := div(a,b) return q,nil default: return 0,fmt.Errorf( \"unsupported operation:%s\",op) &#125;&#125;func div(a,b int)(q,r int)&#123; return a/b, a%b&#125;func apply(op func(int,int) int, a,b int)int &#123; p:=reflect.ValueOf(op).Pointer() opName := runtime.FuncForPC(p).Name() fmt.Printf(\"Calling function %s with args: \"+\"(%d %d)\\n\",opName,a,b) return op(a,b)&#125;func pow(a,b int) int &#123; return int(math.Pow(float64(a),float64(b)))&#125;func sum (numbers ... int) int&#123; s:=0 for i:=range numbers&#123; s+=numbers[i] &#125; return s&#125;func main() &#123; if result,err := eval(3,4,\"x\"); err!=nil&#123; fmt.Println(\"Error\",err) &#125;else &#123; fmt.Println(result) &#125; q, r :=div(13,3) fmt.Println(q,r) fmt.Println(apply(func(a int, b int) int &#123; return int(math.Pow( float64(a),float64(b))) &#125;,3,4)) fmt.Println(apply(pow,3,3)) fmt.Println(sum(1,2,4,12 ,3))&#125; 指针 12345678910package mainimport \"fmt\"func swap(a,b *int) &#123; *a,*b=*b,*a&#125;func main() &#123; a,b :=3,4 swap(&amp;a,&amp;b) fmt.Println(a,b)&#125; 12345678910package mainimport \"fmt\"func swap(a,b int)(int,int) &#123; return b,a&#125;func main() &#123; a,b :=3,4 a,b = swap(a,b) fmt.Println(a,b)&#125; 数组 可以用_省略一个值 123456789101112131415package mainimport \"fmt\"func main() &#123; var arr1 [5]int arr2 := [3]int&#123;1,3,5&#125; arr3 := [...]int&#123;2,4,6,8,10&#125; var grid [4][5]int fmt.Println(arr1,arr2,arr3) fmt.Println(grid) for i,v:=range arr3&#123; fmt.Println(i,v) &#125;&#125; 数组传入函数会拷贝 一般使用切片 切片内部是一个视图 s1[4]不存在，但slice可以view取出来 不超过cap就可以view扩展出来 123456789101112131415161718192021222324252627282930package mainimport \"fmt\"func updateSlice(s []int) &#123; s[0]=100&#125;func main() &#123; arr := [...]int&#123;0,1,2,3,4,5,6,7&#125; fmt.Println(arr[2:6]) fmt.Println(arr[:6]) fmt.Println(arr[2:]) fmt.Println(arr[:]) s1:=arr[2:] fmt.Println(s1) updateSlice(s1) fmt.Println(s1) s2:=arr[:] fmt.Println(s2) updateSlice(s2) fmt.Println(s2) s3 := append(s2,10) s4 := append(s3,11) s5 := append(s4,12) fmt.Println(\"s3, s4, s5 = \",s3,s4,s5) fmt.Println(\"arr =\", arr)&#125; 1234567891011121314151617181920212223242526package mainimport \"fmt\"func printSlice(s []int)&#123; fmt.Printf(\"len=%d, cap=%d\\n\", len(s), cap(s))&#125;func main() &#123; var s[] int for i:=0;i&lt;100;i++&#123; printSlice(s) s=append(s,2*i+1) &#125; fmt.Println(s) s1:=[]int&#123;2,4,6,8&#125; printSlice(s1) s2:=make([]int ,16) s3:=make([]int ,10 ,32) printSlice(s2) printSlice(s3) fmt.Println(\"Copying slice\") copy(s2,s1) printSlice(s2) fmt.Println(\"Deleting slements from slice\") s2=append(s2[:3],s2[4:]...) printSlice(s2)&#125; Map 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport \"fmt\"func main() &#123; m := map[string]string&#123;//hash map 无序 \"name\":\"ccmouse\", \"course\":\"golang\", \"site\":\"imooc\", \"quality\":\"notbad\", &#125; m2:=make(map[string]string)//m2==empty map var m3 map[string]int//m3==nil fmt.Println(m,m2,m3) for k,v:=range m&#123; fmt.Println(k,v) &#125; fmt.Println(\"Getting values\") courseName,ok:=m[\"course\"] fmt.Println(courseName,ok) if causeName,ok:=m[\"cause\"];ok&#123; fmt.Println(causeName) &#125;else &#123; fmt.Println(\"Key dosen't exist\") &#125; fmt.Println(\"Deleting values\") name,ok:=m[\"name\"] fmt.Println(name,ok) delete(m,\"name\") name,ok=m[\"name\"] fmt.Println(name,ok)&#125;/*map[course:golang name:ccmouse quality:notbad site:imooc] map[] map[]site imoocquality notbadname ccmousecourse golangGetting valuesgolang trueKey dosen't existDeleting valuesccmouse true false*/"},{"title":"","date":"2019-04-26T12:44:50.000Z","updated":"2019-04-26T12:44:50.000Z","comments":true,"path":"wait/go学习5.html","permalink":"https://ghostlo.github.io/wait/go学习5.html","excerpt":"","text":"运算符有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 12345678优先级 运算符 7 ^ ! 6 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 5 + - | ^ 4 == != &lt; &lt;= &gt;= &gt; 3 &lt;- 2 &amp;&amp; 1 || 字符类型严格来说，这并不是 Go 语言的一个类型，字符只是整数的特殊用例。byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。例如：var ch byte = &#39;A&#39;；字符使用单引号括起来。 在 ASCII 码表中，A 的值是 65，而使用 16 进制表示则为 41，所以下面的写法是等效的： 1var ch byte = 65 或 var ch byte = &apos;\\x41&apos; （\\x 总是紧跟着长度为 2 的 16 进制数） 另外一种可能的写法是 \\ 后面紧跟着长度为 3 的八进制数，例如：\\377。 不过 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。其实 rune 也是 Go 当中的一个类型，并且是 int32的别名。 在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 \\u 或者 \\U。 因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \\U前缀；前缀 \\u 则总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 示例 4.12 char.go 12345678910111213var ch int = '\\u0041'var ch2 int = '\\u03B2'var ch3 int = '\\U00101234'fmt.Printf(\"%d - %d - %d\\n\", ch, ch2, ch3) // integerfmt.Printf(\"%c - %c - %c\\n\", ch, ch2, ch3) // characterfmt.Printf(\"%X - %X - %X\\n\", ch, ch2, ch3) // UTF-8 bytesfmt.Printf(\"%U - %U - %U\", ch, ch2, ch3) // UTF-8 code point/*65 - 946 - 1053236A - β - r41 - 3B2 - 101234U+0041 - U+03B2 - U+101234*/ 格式化说明符 %c 用于表示字符；当和字符配合使用时，%v 或 %d 会输出用于表示该字符的整数；%U 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。 timetime 包为我们提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数。 当前时间可以使用 time.Now() 获取，或者使用 t.Day()、t.Minute() 等等来获取时间的一部分；你甚至可以自定义时间格式化字符串，例如： fmt.Printf(&quot;%02d.%02d.%4d\\n&quot;, t.Day(), t.Month(), t.Year()) 将会输出 21.07.2011。 Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。 包中的一个预定义函数 func (t Time) Format(layout string) string 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，你可以使用一些预定义的格式，如：time.ANSIC 或 time.RFC822。 一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，这听起来很奇怪，但看下面这个例子你就会一目了然： 1fmt.Println(t.Format(&quot;02 Jan 2006 15:04&quot;)) 输出： 121 Jul 2011 10:31 其它有关时间操作的文档请参阅 官方文档（ 译者注：国内用户可访问 该页面 ）。 示例 4.20 time.go 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"time\")var week time.Durationfunc main() &#123; t := time.Now() fmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011 fmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year()) // 21.12.2011 t = time.Now().UTC() fmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011 fmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011 // calculating times: week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec week_from_now := t.Add(time.Duration(week)) fmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011 // formatting times: fmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC fmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011 fmt.Println(t.Format(\"02 Jan 2006 15:04\")) // 21 Dec 2011 08:52 s := t.Format(\"20060102\") fmt.Println(t, \"=&gt;\", s) // Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221&#125; 输出的结果已经写在每行 // 的后面。 如果你需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 time.After 或者 time.Ticker：我们将会在第 14.5 节讨论这些有趣的事情。 另外，time.Sleep（Duration d） 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。"},{"title":"Go学习（四）","date":"2019-04-24T02:24:32.000Z","updated":"2019-04-24T08:55:58.000Z","comments":true,"path":"wait/go学习4.html","permalink":"https://ghostlo.github.io/wait/go学习4.html","excerpt":"","text":"包 duck typing retriever是一个对象，download是一个使用者，使用了retriever这个对象，retriever就是个duck typing的对象，运行时才知道retriever有没有get方法 python运行时知道（没有编译器），c++编译时知道 接口只规定实现接口的方法，由使用者再来定义方法"},{"title":"","date":"2019-04-16T02:22:27.000Z","updated":"2019-04-16T02:22:27.000Z","comments":true,"path":"wait/实习 | 字节跳动效率工程后端面经.html","permalink":"https://ghostlo.github.io/wait/实习 | 字节跳动效率工程后端面经.html","excerpt":"","text":"作者：≡如梦初醒 链接：https://www.nowcoder.com/discuss/149646 来源：牛客网 lz从11月中开始就在开始找寒假实习，正好头条效率工程团队来我们学校笔试招20届的实习生，抱着试一试的心态就去了，毕竟宇宙条。 笔试比较简单，手撸三道算法题。面试的话也许面试官看我是大三的学生，问的问题都比较基础，但是最终还是没有过，还是自己太菜了，下面就开始po题目啦 一面： 有一个岛，岛上有 n 只老虎和一只羊，老虎会吃羊，但吃完后会变成羊，请问，这只羊最后能活下来吗？条件： 老虎生存为第一要义 老虎在生存的前提下尽可能的吃羊一开始没有搞懂题意瞎说了一通，被驳回之后用1,2,3,4依次代入了一遍，发现答案其实很简单：奇数能存活偶数不能 给你一个数组，数组长度为 n。请找出数组中第 k 大的数n, A[i] int 范围内附件条件：不允许改变元素在数组中的位置。一开始想都没想就先说了用partition的思路，面试官听了之后加了一个附加条件…就完全没思路了，最后问了提示：“给你一个数你能找到是数组的第几大吗？”，才想出来并实现思路就是在int范围内取中位数，算出其在数组中是第几大元素，与k比较并不断二分 TCP三次握手 Http协议是一个无状态协议，那么有什么方法可以让用户保留登录的状态？又问了问看过Http的哪些书？答：《图解Http》和课本..low了点，面试官见状就不再问什么了 接下来又问了问学习成绩，学没学数据库操作系统什么的，数据结构熟悉哪些，也没什么技术上的问题就说可以了 二面：很奇怪的面试..没有打一行代码，全都是口述问题，还夹杂了一堆非技术问题 现在在上什么课程？ 问一下项目和具体的算法，调库还是手撸 B+树的原理 单向链表和双向链表的原理和特点、使用中（增删查）的优缺点 如何实现一个栈的类和对应的API C++的内存管理和回收的原理 索引的类型，什么是联合索引，使用联合索引时需要注意什么 关联查询用的关键字，左连接和右连接的概念，分别用到什么关键字 内连接和外连接 冒泡的实现和优缺点 成绩的排名，平时时间安排，毕业之后的规划，找工作的目标，对互联网的看法，互联网有哪些大平台和产品，接触比较多的产品，各自的特点，抖音为什么会这么受欢迎，最希望做的产品的类型，需要用到什么技术，平时的兴趣爱好，会关注哪一些比较感兴趣的技术领域，在看什么方面的资料，哪里人，实习时间，课程多不多，为什么想这么早出来，用三个词形容自己，相应的事例 与作者交流：https://www.nowcoder.com/discuss/149646 更多笔经面经：https://www.nowcoder.com/discuss?order=0&amp;type=2"},{"title":"","date":"2019-04-26T13:10:10.000Z","updated":"2019-04-26T13:10:10.000Z","comments":true,"path":"wait/待看.html","permalink":"https://ghostlo.github.io/wait/待看.html","excerpt":"","text":"旅行商问题https://blog.csdn.net/yjr3426619/article/details/83387962 https://www.jianshu.com/p/43aa80069265 深度学习[吴恩达斯坦福CS230第一名：图像超级补全效果惊艳（附代码）][https://zhuanlan.zhihu.com/p/40902853] [烧脑！CMU、北大等合著论文真的找到了神经网络的全局最优解][https://zhuanlan.zhihu.com/p/49530619] [github mechine learning打卡][https://github.com/Dikea/ML-Weekly-Learning] 算法圣经[算法圣经《算法导论》第三版习题答案开源！ ][https://mp.weixin.qq.com/s?__biz=MzUzNjA0MTE4NA==&amp;mid=2247484428&amp;idx=1&amp;sn=3f8bccbccc04e27f1eebb2b53c751039&amp;chksm=fafd0783cd8a8e95471f03fa3b1e37aa0ab1c7994371fd653352ab44ae9b3b40eb96e3ab98ce&amp;mpshare=1&amp;scene=23&amp;srcid=0417Yv88KHJSfzvAGGk31d0H#rd]另 [github][https://github.com/walkccc/CLRS]"},{"title":"","date":"2019-04-25T14:02:04.000Z","updated":"2019-04-25T14:02:04.000Z","comments":true,"path":"wait/机器学习进阶：我的竞赛之路.html","permalink":"https://ghostlo.github.io/wait/机器学习进阶：我的竞赛之路.html","excerpt":"","text":"机器学习进阶：我的竞赛之路 鱼遇雨欲语与余 武汉大学 计算机技术硕士在读 47 人赞同了该文章 首先将向大家推荐下我的首场知乎Live“如何进行一场数据挖掘算法竞赛”，本次Live的主要内容是由我和张杰（圈内人称杰少，毕业于南京大学，天池数据科学家，南京趋势科技资深算法工程师）合作完成。 如何进行一场数据挖掘算法竞赛www.zhihu.com Live将以我个人的竞赛经历和竞赛圈的情况为背景和大家聊聊如何一场数据挖掘算法竞赛，对于赛前、赛中和赛后需要做哪些事情。最后还将进行一个案例分享（TIANCHI-全球城市计算挑战赛），来看看我是如何进行一场比赛的。 写在前面作为一名研二即将毕业的学生，两年的研究生生活，有一年半的时间都在打比赛。我的第一个比赛是“天池精准医疗大赛——人工智能辅助糖尿病遗传风险预测”，那时候完全不晓得特征工程怎么做，而是各种堆模型，我从kaggle的泰坦尼克号比赛kernel分享中的模型直接拿来用，就这样最后得到200多名。接下来参加了“[印象盐城]数创未来大数据竞赛 - 乘用车零售量预测”，由于刚开始打比赛模型构造的慢，直接用上个月销量*1.x来替换，第二天直接前五，这也是我的第一次使用规则提交。经过两次试水，我经历了首个全程参与的比赛“IJCAI-18 阿里妈妈搜索广告转化预测”，基本每天都在提交。紧接着，参加了“2018腾讯广告算法大赛”，和队友租了台服务器，最后一周都待在宿舍，有时候直接通宵，最后拿到了11名，这也是第一次被邀请观摩答辩。同期还参加了“JDATA如期而至-用户购买时间预测”比赛，这是第一次参加答辩的比赛。 经历过很多第一次，踩了很多坑，学到很多知识，交了很多朋友，就这样，竞赛之路继续进行着。 在此将我的竞赛分享进行整理，希望你能从中有所收获。 竞赛方案分享文章 IJCAI-18 阿里妈妈搜索广告转化预测总结( 0.13939/Rank29 ) 2018腾讯广告算法大赛总结（0.772229/Rank11） 2018JDATA如期而至-用户购买时间预测Rank9 2018科大讯飞AI营销算法大赛总结（冠军） 2018 CCF《套餐个性化匹配模型》（亚军）分享 TIANCHI-OGeek算法挑战赛-完整方案及代码（亚军） DF消费者人群画像—信用智能评分方案分享（top5） TIANCHI-全球城市计算挑战赛-完整方案及关键代码分享（季军） 竞赛baseline文章 2018科大讯飞AI营销算法大赛Baseline0.4255 天池-OGeek算法挑战赛Baseline(0.7016) JDD2018-人口动态普查与预测Baseline0.1417 TIANCHI-津南数字制造算法挑战赛【赛场一】基本分析&amp;Baseline TIANCHI全球城市计算AI挑战赛baseline 机器学习理论知识 机器学习面试干货精讲 LDA线性判别分析 特征选择 奇异值分解(SVD)原理 PCA主成分分析学习总结 TF-IDF与余弦相似度 最后祝各位面试成功！并以下面一句话来勉励你我。 路漫漫其修远兮，吾将上下而求索。"},{"title":"categories","date":"2019-04-04T01:39:49.000Z","updated":"2019-04-04T01:40:05.000Z","comments":true,"path":"categories/index.html","permalink":"https://ghostlo.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-16T02:23:38.000Z","updated":"2019-04-16T02:23:38.000Z","comments":true,"path":"wait/阿里天猫团队Java研发岗技术四面-数据结构+MySQL+缓存雪崩+高并发等.html","permalink":"https://ghostlo.github.io/wait/阿里天猫团队Java研发岗技术四面-数据结构+MySQL+缓存雪崩+高并发等.html","excerpt":"","text":"阿里面试主要及经常问到技术点：数据结构，多线程，jvm，优化，消息框架，分布式，缓存等以及你使用过的框架且第一轮的基础很重要，通过会后录取可能性就相对高了！ 金三银四已经到来，在这也免费分享一些Java程序员面试常问架构面试专题和答案以及架构视频资料（文末领取），希望那些有需要朋友能在今年第一波招聘潮找到一个自己满意顺心的工作！ 面试题如下一面（主要是jvm，并发，锁，数据结构等基础） 自我介绍（说说自己的擅长及拿手的技术） 说说treemap和HashMap的区别？HashMap和ConcurrentHashMap的区别？ HashMap底层如何实现(JDK1.8有所改动)？ 说说Hash的一致算法？ 你知道的GC算法和回收策略有哪些？GC的机制是什么？ 垃圾回收器的基本原理？是否可以立即回收内存？怎么样主动的通知JVM进行垃圾回收？ 双亲委派模型机制 线程池创建的几个核心构造参数是什么？ 乐观锁和悲观锁？可重入锁和Synchronized？ 他们都是可重入锁吗？哪个效率更高？ CountDownLaunch和Cylicbarrior的区别以及分别是在哪样场景下使用的？ Http和Https的区别以及Https加密的方式？ 以后的职业规划和想法 二面（主要是数据库，协议，Spring等） 自我介绍，聊下自己认为做得很好的项目！ InnoDB支持的四种事务隔离级别名称是什么？ 之间的区别是什么？MySQL隔离级别是什么？ 说说事务的特性？讲讲对慢查询的分析？ 你理解的BTree机制？ 有哪些MySQL常用的优化方法？ Http请求过程，DNS解析的过程？ 三次握手和四次握手的过程？ B+树索引和Hash索引之间的区别？ Spring IOC如何管理Bean之间的依赖关系，怎么样避免循环依赖？ SpringBean创建过程中的设计模式？ 说说AOP的实现原理？ Tomcat的基本架构是什么？ 三面（主要是缓存，高并发，分布式） 自己项目中的总结的并发经验 说说MySQL的锁并发？加锁的机制是什么？ 高并发场景下如何防止死锁，保证数据的一致性？ 集群和负载均衡的算法与实现？ 说说分库与分表设计？ 分库分表带来的分布式困境与对应之策有哪些？ Redis和Setnx命令使如何实现分布式锁的？使用Redis怎么进行异步队列？会有什么缺点？ 缓存击穿的概念和解决方案? Redis的数据结构？ 线程模型？ Redis的数据淘汰机制？ Redis的数据一致性问题 MQ底层原理的实现？ 阻塞队列不用Java提供的该怎么实现？ 讲讲负载均衡的原理？ 如何实现高并发环境下的削峰、限流？ 四面（主要项目入手） 讲讲项目中用到的中间件(Dubbo/MQ/Zookeeper/Redis/Kafka)？ 什么情况下会造成雪崩？该怎么避免这种情况？ 高并发架构的设计思路？ 以前的项目中遇到的问题和解决策略？ 生活中遇到过哪些挫折？最后怎么解决的? BAT面试Java岗常问题锦集BAT2019最全Java面试168题汇总：并发编程+JVM+Spring+分布式+数据库+缓存等！ 总结一线互联网公司都比较注重实际的项目中解决问题的能力，另外面试点主要围绕JVM、多线程相关、基础知识的底层原理、处理高并发的能力。这里也不扯什么面试技巧了，轻松发挥就好，祝大家金三银四季能有个高薪满意的工作！ 最后针对于上面的面试问到的知识点我总结出了适合于工作2-5年以上开发经验的java程序员在面试中涉及到的绝大部分架构面试题及答案做成了文档和架构视频资料免费分享给大家（包括Dubbo、Redis、Netty、zookeeper、Spring cloud、分布式、高并发等架构技术资料），希望能帮助到您面试前的复习且找到一个好的工作，也节省大家在网上搜索资料的时间来学习，也可以关注我一下以后会有更多干货分享。 领取方式关注我的公众号**Java架构技术栈 后台回复关键“架构”，即可免费获取上述所有资源。你可以通过名字:”Java架构技术栈“搜索到或者直接扫描下方二维码。** ​"},{"title":"现代社会A","date":"2019-04-24T00:46:32.000Z","updated":"2019-04-24T00:47:27.000Z","comments":true,"path":"wait/资本-幸福.html","permalink":"https://ghostlo.github.io/wait/资本-幸福.html","excerpt":"","text":"有房有车成熟员工随便骂，这还不算狠。 有车有房，有妻有子的员工，不仅能随便骂，还能随便罚，随便整。 就算把他们开除，他们也会安安静静，按照着秩序排队去上天台。 在类似男女关系为什么越来越紧张，家庭关系为什么越来越紧张，大众为什么过得越来越不快乐，人们为什么越来越不想生孩子的提问下。 我都提到过一个现象，大众生活，婚姻的不幸，正是资本的大幸！ 资本的逻辑是不择手段的赚钱。 提高生产力很难，生产力发展在短暂突破后，很快就会陷入漫长的积累平台期。 每当生产力进入缓慢发展的平台阶段。 资本的增值的方式，就不再是发展生产力。 而是演变为剥夺人们拥有的东西，再逼迫人们高价赎回。 资本对人的奴役，是通过裹挟人所珍视的东西，逼迫人接受各种反人性的控制。 在奴隶社会，资本会剥夺奴隶的生命，自由。 逼迫奴隶去角斗，去当炮灰，用各种会丧命的自残，去赎回自己。 在封建社会，资本会剥夺农民的生命，土地，自由。 逼迫农民高强度劳作，卖儿卖女，用各种丧权辱国的行为，去赎回自己。 到了资本主义社会，这个玩法被使用得淋漓尽致。 被资本化的所有东西，都需要劳动者通过高强度的996，通过贩卖所有能贩卖的去赎回。 甚至不仅仅是贩卖掉所有自己有的，还要贩卖掉6个钱包有的。 最后连带着下一代也贩卖掉。 这是资本增殖，壮大的主要方式。 最初是房子，大家说房价自由化，房价市场化不可阻挡。 然后是医疗，大家说医疗自由化，医疗市场化不可阻挡。 马上是教育，大家说教育自由化，教育市场化不可阻挡。 资本尝到了甜头，通过房产，医疗，教育的各种私有化，获得了原始积累，掌握了力量。 紧接着，资本开始改造大众的全部生活，全部的价值观。 生存，自尊，自信，婚姻，爱情，家庭，这些人们追求的东西，都是资本大力改造的对象。 资本将人们的自尊，自信，统统打碎，彻底改造和磨灭，重新灌输资本定义的自尊和自信（钱）。 资本将人们期望，相信的爱情与婚姻，统统打碎，植入灌输资本定义的爱情与婚姻（钱）。 这时候，有些人终于感觉到痛了，可惜资本已经壮大成为了不可阻挡的怪物。 再也没有人能够阻挡资本的脚步了，越来越多人渴望成为资本的帮凶和代理人。 资本已经将现代的婚姻，爱情，房子，家庭所有的定义统统改造。 在当代，人们所追求的房子，家庭，婚姻，自尊。 任何一项人们渴望的追求。都需要劳动者通过高强度的996，通过贩卖所有能贩卖的去赎回。 人们所向往，所追求的生活，在资本改造之后，成为了资本用来裹挟大众的工具。 家庭是利益共同体，资本是韭菜割肉刀。 帮助家庭对抗资本，还是帮助资本收割家庭，这原本不难判断。 可一旦经资本改造，家庭变成了可以切割，可以轻易切换的财产。 资本反倒成了唯一能够依仗的后盾。 于是在当代，婚礼越来越奢侈，婚房越来越豪华。 人人都有了钻石，人人都接受资本的洗脑。 然后，婚姻变得更糟糕了，家庭变得让人无法忍受了。 80后90后离婚率高达40%，人们被资本洗脑着，用尽六个钱包的积蓄。 花最多的钱，买来随时可以切割，相互算计，相互斗争的糟糕婚姻生活。 现代人，接受最多教育，生产力最发达的一代人。 不仅离婚率飙升，连幸福婚姻的数量和比例都没有增加。 这就是被资本，被商业改造之后的大众生活。 很多人觉得自己不快乐，这是真的，因为大众婚姻，生活的不幸，正是资本的大幸。 如果让大众在婚姻，在家庭，在社会中获得了幸福，资本还怎么去榨取大众。 还怎么让大众主动背弃家庭，背弃家人，加入996，加入侍奉资本，壮大资本的行列？ 资本对人的改造和控制，并不局限于穷人。 不要以为暴富，成为资本家就能解决问题。 韩国财阀有组织性侵女明星，好莱坞大亨有组织性侵女明星，BBC明星主持人性侵上百名儿童。 这些各行各业的领袖，上流人士，资本家，他们缺钱吗？他们缺女人吗？ 他们能从婚姻，家庭，事业中获得幸福吗？ 上层阶级，功成名就，什么享受不到？ 为什么还要去强奸，还要去性侵？ 资本的代理人，顶级的大资本家，一样是资本的奴隶。 他们一样没法在婚姻家庭，事业工作中获得幸福。 穷人烦恼没钱，富人成为资本的载体，永远渴求更多特权。 欲望是没有尽头的，把欲望捧上去，穷人永远不幸。 富人玩遍了合法的，就变着法玩非法的。 玩腻了穷人的儿女，就开始强奸中产阶级和上层阶级的儿女。 你看，大家多幸福？ [来源][https://www.zhihu.com/question/320993860/answer/658122708]"},{"title":"c++-learn","date":"2019-04-20T01:33:13.000Z","updated":"2019-04-20T03:13:15.000Z","comments":true,"path":"wait/c-learn.html","permalink":"https://ghostlo.github.io/wait/c-learn.html","excerpt":"","text":"[先看看这个 来自stackoverflow][https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list] [知乎上这个也可以参考][https://www.zhihu.com/question/20410487] ​ 1. ​ 【原书名】 C++ Primer （4th Edition） ​ 【原出版社】 Addison Wesley/Pearson ​ 【作者】 （美）Stanley B.Lippman，Josée LaJoie，Barbara E.Moo ​ 【译者】 李师贤 ​ 【丛书名】 图灵计算机科学丛书 ​ 【出版社】人民邮电出版社 ​ 本书是久负盛名的C++经典教程，其内容是C++大师Stanley B. Lippman丰富的实践经验和C++标准委员会原负责人Josée Lajoie对C++标准深入理解的完美结合，已经帮助全球无数程序员学会了C++.本版对前一版进行了彻底的修订，内容经过了重新组织，更加入了C++先驱Barbara E. Moo在C++教学方面的真知灼见。既显著改善了可读性，又充分体现了C++语言的最新进展和当前的业界最佳实践。书中不但新增大量教学辅助内容，用于强调重要的知识点，提醒常见的错误，推荐优秀的编程实践，给出使用提示，还包含大量来自实战的示例和习题。对C++基本概念和技术全面而且权威的阐述，对现代C++编程风格的强调，使本书成为C++初学者的最佳指南；对于中高级程序员，本书也是不可或缺的参考书。本书的前言阐述了 第4版和前一版的不同之处。 ​ 难度：★★☆ ​ 质量：★★★★★ ​ 广度：★★★★★ ​ 深度：★★★★ ​ 性价：★★★☆ ​ 2. ​ 【原书名】 C++ Primer Plus ​ 【原出版社】 Sams ​ 【作者】 （美）Stephen Prata ​ 【译者】 孙建春 韦强 ​ 【丛书名】 Primer Plus 系列 ​ 【出版社】 人民邮电出版社 ​ 本书针对的是C++初学者，书中从C语言基础知识开始介绍，然后在此基础上详细阐述C++新增的特性，因此不要求读者有C语言方面的背景知识。本书可作为大中院校教授C++课程的教材，也可供初学者自学C++时使用。覆盖面较全，章节安排比较合理，由浅入深，也很容易，故因此失去了一些深度。价格比较便宜，但翻译质量略有不足。现在，第五版也出版了，不过还没有读，看章节都差不多。 ​ 难度：☆ ​ 质量：★★★☆ ​ 广度：★★★★ ​ 深度：★★★ ​ 性价：★★★☆ ​ 3. ​ 【原书名】 Essential C++ ​ 【原出版社】Pearson Education ​ 【作者】 （美）Stanley B.Lippman ​ 【丛书名】 深入C++系列 ​ 【出版社】 中国电力出版社 ​ lippman的一部面向初学者的作品。在他写了那么后一本primer之后，为何还要写这么薄这么浅的书呢？其实primer对于初学者来说太笨重了，而这本书却是从不同的方面——C++的本质和组织结构对语言进行阐释，可以帮助初学者对这门语言有一个大致的了解，但知识范围不很全面，不适合系统学习，读者需要一定的编程知识。 ​ 难度：★☆ ​ 质量：★★★★ ​ 广度：★★★☆ ​ 深度：★★★ ​ 性价：★★☆ ​ 4. ​ 【原书名】 Effective C++， Third Edition ​ 【原出版社】 Addison Wesley/Pearson ​ 【作者】 （美）Scott Meyers ​ 【出版社】 电子工业出版社 ​ ​ 【原书名】 More Effective C++： 35 New Ways to Improve Your Programs and Designs ​ 【原出版社】 Addison Wesley/Pearson ​ 【作者】 （美）Scott Meyers ​ 【丛书名】 C++设计新思维系列丛书 ​ 【出版社】 机械工业出版社 ​ C++真牛人大手笔，之以条款的形式回答了程序员在使用C++时经常提出的“因该注意些什么？”，“因该避免什么？”，“因该怎样去解决？”，“为什么？”等问题。C++程序员想要让自己的水平上更高的档次，此二书必看。价格稍贵，有一定难度，不适合初学者。 ​ 难度：★★★☆ ​ 质量：★★★★★ ​ 广度：★★★ ​ 深度：★★★★★ ​ 性价：★★ ​ 5. ​ 【原书名】 Thinking in C++ ​ 【原出版社】 McGraw Hill ​ 【作者】 Bruce Eckel ​ 【译者】 刘宗田 等 ​ 「丛书名」 计算机科学丛书 ​ 【出版社】 机械工业出版社 ​ 除了讲述语言之外，有一定的工程性，从设计者的角度来描述C++怎样应用在实际的项目中。语言描述的全面性欠佳，但还是有一定精度的，尤其是在一些小技巧方面。本书还引入了大量的战例，通过一个个的真实项目来引导你使用C++的思想去思考问题。翻译很差，有一定难度。 ​ 难度：★★☆ ​ 质量：★★★ ​ 广度：★★★☆ ​ 深度：★★★★ ​ 性价：★★★ ​ 6. ​ 【原书名】 The Complete C++ Training Course ​ 【作者】 （美）Harvey M.Deitel Paul James Deitel ​ 【译者】 邱仲潘 等 ​ 【丛书名】 国外计算机科学教材系列 ​ 【出版社】 电子工业出版社 ​ 正如其名，真正的大学教程，非常适合初学者学习，内容由浅入深，对C++各项特性的描述都很到位，章节的安排很有条理性，但深度略显不足，翻译质量不能称之为很好，有一定的疏漏，但对于厚度来讲，价格还算比较便宜。 ​ 难度：★ ​ 质量：★★★☆ ​ 广度：★★★★★ ​ 深度：★★★★ ​ 性价：★★★★☆ ​ 7. ​ 【原书名】 The Design and Evolution of C++ ​ 【原出版社】 Addison-Wesley ​ 【作者】 （美）Bjarne Stroustrup ​ 【译者】 裘宗燕 ​ 【丛书名】 计算机科学丛书 ​ 【出版社】 机械工业出版社 ​ 对于热爱C++的朋友来说，确实好书一本，可以当做小说来读，可以放在厕所或床头上以供消遣。本书对语言本身描述很少，并有一定难度。读者需要对C++有一定了解，不适合初学者阅读。本书也有英文版，如果不喜欢翻译的朋友可以看看。 ​ 难度：★★★ ​ 质量：★★★ ​ 广度：★★☆ ​ 深度：★★★★ ​ 性价：★★★ ​ 8. ​ 【原书名】 The C++ Programming Language， Special Edition ​ 【原出版社】 Addison Wesley ​ 【作者】 （美）Bjarne Stroustrup ​ 【译者】 裘宗燕 ​ 【丛书名】 计算机科学丛书 ​ 【出版社】 机械工业出版社 ​ C++之父所作，被称之为“C++圣经”。不仅对语言，而且对语言周边的一些如发展史、语义哲学都有比较详细的描述。对语言的描述较为全面，同时包含一部分和程序库相关联的知识，并有一定深度，适合有一定语言基础的初学者，翻译质量不错，价格适中。 ​ 难度：★☆ ​ 质量：★★★★☆ ​ 广度：★★★★☆ ​ 深度：★★★★ ​ 性价：★★★☆ ​ 9. ​ 【原书名】 Inside the C++ Object Model ​ 【原出版社】 Pearson Education ​ 【作者】 （美）Stanley B.Lippman ​ 【丛书名】 深入C++系列 ​ 【出版社】 中国电力出版社 ​ 第一代C++编译器开发主管所写。如果你想成为真正的C++高手，看这本书，他为你讲述了编译器在处理各种语法时在“后台”所做的事。对C++有较深入了解的读者会在读后有恍然大悟之感。候杰翻译，质量相当不错，但内容太深，只适合对C++有较深了解的读者，价格偏贵。 ​ 难度：★★★★☆ ​ 质量：★★★★★ ​ 广度：★★★ ​ 深度：★★★★★ ​ 性价：★★"},{"title":"","date":"2019-04-26T12:20:47.000Z","updated":"2019-04-26T12:20:47.000Z","comments":true,"path":"wait/go学习6.html","permalink":"https://ghostlo.github.io/wait/go学习6.html","excerpt":"","text":"判断运行 Go 程序的操作系统类型，这可以通过常量 runtime.GOOS 来判断(第 2.2 节)。 12345if runtime.GOOS == \"windows\" &#123; . ..&#125; else &#123; // Unix-like . ..&#125; 这段代码一般被放在 init() 函数中执行。这儿还有一段示例来演示如何根据操作系统来决定输入结束的提示： 123456789var prompt = \"Enter a digit, e.g. 3 \"+ \"or %s to quit.\"func init() &#123; if runtime.GOOS == \"windows\" &#123; prompt = fmt.Sprintf(prompt, \"Ctrl+Z, Enter\") &#125; else &#123; //Unix-like prompt = fmt.Sprintf(prompt, \"Ctrl+D\") &#125;&#125; 一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说您不需要特别使用 break 语句来表示结束。 因此，程序也不会自动地去执行下一个分支的代码。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 节和第 14.2.1 节）new() 是一个函数，不要忘记它的括号 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数（详见第 4.5.2.2 节） 在编程语言理论中，惰性求值（英语：Lazy Evaluation），又译为惰性计算、懒惰求值，也称为传需求调用（call-by-need），是一个计算机编程中的一个概念，它的目的是要最小化计算机要做的工作。它有两个相关而又有区别的含意，可以表示为“延迟求值”和“最小化求值”，本条目专注前者，后者请参见最小化计算条目。除可以得到性能的提升外，惰性计算的最重要的好处是它可以构造一个无限的数据类型。 短路求值（Short-circuit evaluation，又称最小化求值），是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。例如，当AND的第一个运算数的值为false时，其结果必定为false；当OR的第一个运算数为true时，最后结果必定为true，在这种情况下，就不需要知道第二个运算数的具体值。在一些语言中（如Lisp），默认的逻辑运算符就是短路运算符，而在另一些语言中（如Java，Ada），短路和非短路的运算符都存在。对于一些逻辑运算，如XOR，短路求值是不可能的 。 短路表达式*x* AND y，事实上等价于条件语句：if *x* then *y* else false。短路表达式*x* OR *y*，则等价于条件语句：if *x*then true else *y*。 HasPrefix 判断字符串 s 是否以 prefix 开头： 1strings.HasPrefix(s, prefix string) bool HasSuffix 判断字符串 s 是否以 suffix 结尾： 1strings.HasSuffix(s, suffix string) bool Contains 判断字符串 s 是否包含 substr： 1strings.Contains(s, substr string) bool Index 返回字符串 str 在字符串 s 中的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str： 1strings.Index(s, str string) int LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str： 1strings.LastIndex(s, str string) int 如果需要查询非 ASCII 编码的字符在父字符串中的位置，建议使用以下函数来对字符进行定位： 1strings.IndexRune(s string, r rune) int Replace 用于将字符串 str 中的前 n 个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 new： 1strings.Replace(str, old, new, n) string Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数： 1strings.Count(s, str string) int Repeat 用于重复 count 次字符串 s 并返回一个新的字符串： 1strings.Repeat(s, count int) string ToLower 将字符串中的 Unicode 字符全部转换为相应的小写字符： 1strings.ToLower(s) string ToUpper 将字符串中的 Unicode 字符全部转换为相应的大写字符： 1strings.ToUpper(s) string 你可以使用 strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号；如果你想要剔除指定字符，则可以使用 strings.Trim(s, &quot;cut&quot;) 来将开头和结尾的 cut 去除掉。该函数的第二个参数可以包含任何字符，如果你只想剔除开头或者结尾的字符串，则可以使用 TrimLeft 或者 TrimRight 来实现 strings.Fields(s) 将会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice。 strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。 因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理（第 7.3 节）。 Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串： 1strings.Join(sl []string, sep string) string 函数 strings.NewReader(str) 用于生成一个 Reader 并读取字符串中的内容，然后返回指向该 Reader 的指针，从其它类型读取内容的函数还有： Read() 从 []byte 中读取内容。 ReadByte() 和 ReadRune() 从字符串中读取下一个 byte 或者 rune。 与字符串相关的类型转换都是通过 strconv 包实现的。 该包包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：strconv.IntSize。 任何类型 T 转换为字符串总是成功的。 针对从数字类型转换到字符串，Go 提供了以下函数： strconv.Itoa(i int) string 返回数字 i 所表示的字符串类型的十进制数。 strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string 将 64 位浮点型的数字转换为字符串，其中 fmt 表示格式（其值可以是 &#39;b&#39;、&#39;e&#39;、&#39;f&#39; 或 &#39;g&#39;），prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64。 将字符串转换为其它类型 tp 并不总是可能的，可能会在运行时抛出错误 parsing &quot;…&quot;: invalid argument。 针对从字符串类型转换为数字类型，Go 提供了以下函数： strconv.Atoi(s string) (i int, err error) 将字符串转换为 int 型。 strconv.ParseFloat(s string, bitSize int) (f float64, err error) 将字符串转换为 float64 型。 利用多返回值的特性，这些函数会返回 2 个值，第 1 个是转换后的结果（如果转换成功），第 2 个是可能出现的错误，因此，我们一般使用以下形式来进行从字符串到其它类型的转换： 1val, err = strconv.Atoi(s) 常用的格式化字符串有： %v the value in a default formatwhen printing structs, the plus flag (%+v) adds field names%#v a Go-syntax representation of the value%T a Go-syntax representation of the type of the value 不同类型默认的%v 如下: bool: %tint, int8 etc.: %duint, uint8 etc.: %d, %#x if printed with %#vfloat32, complex64, etc: %gstring: %schan: %ppointer: %p 对于interface{}, %v会打印实际类型的值。 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\")type Power struct &#123; age int high int name string&#125;func main() &#123; var i Power = Power&#123;age: 10, high: 178, name: \"NewMan\"&#125; fmt.Printf(\"type:%T\\n\", i) fmt.Printf(\"value:%v\\n\", i) fmt.Printf(\"value+:%+v\\n\", i) fmt.Printf(\"value#:%#v\\n\", i) fmt.Println(\"========interface========\") var interf interface&#123;&#125; = i fmt.Printf(\"%v\\n\", interf) fmt.Println(interf)&#125;/*type:main.Powervalue:&#123;10 178 NewMan&#125;value+:&#123;age:10 high:178 name:NewMan&#125;value#:main.Power&#123;age:10, high:178, name:\"NewMan\"&#125;========interface========&#123;10 178 NewMan&#125;&#123;10 178 NewMan&#125;*/ 匿名函数同样被称之为闭包（函数式语言的术语）：它们被允许调用定义在其它环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。闭包经常被用作包装函数：它们会预先定义好 1 个或多个参数以用于包装。 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func main() &#123; // make an Add2 function, give it a name p2, and call it: p2 := Add2() fmt.Printf(\"Call Add2 for 3 gives: %v\\n\", p2(3)) // make a special Adder function, a gets value 2: TwoAdder := Adder(2) fmt.Printf(\"The result is: %v\\n\", TwoAdder(3))&#125;func Add2() func(b int) int &#123; return func(b int) int &#123; return b + 2 &#125;&#125;func Adder(a int) func(b int) int &#123; return func(b int) int &#123; return a + b &#125;&#125;/*Call Add2 for 3 gives: 5The result is: 5*/ 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var f = Adder() fmt.Print(f(1), \" - \") fmt.Print(f(20), \" - \") fmt.Print(f(300))&#125;func Adder() func(int) int &#123; var x int return func(delta int) int &#123; x += delta return x &#125;&#125;/*1 - 21 - 321*/ 我们可以看到，在多次调用中，变量 x 的值是被保留的，即 0 + 1 = 1，然后 1 + 20 = 21，最后 21 + 300 = 321：闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 123456789101112131415161718192021222324252627282930//斐波拉契数列练习package mainimport \"fmt\"func fib() func(a int) int &#123; var x, y int return func(a int) int &#123; if a == 0 &#123; x = 1 return x &#125; if a == 1 &#123; y = 1 return y &#125; z := y y = x + y x = z return y &#125;&#125;func main() &#123; g := fib() for i := 0; i &lt; 100; i++ &#123; fmt.Println(g(i)) &#125;&#125; 计算函数执行时间有时候，能够知道一个计算执行消耗的时间是非常有意义的，尤其是在对比和基准测试中。最简单的一个办法就是在计算开始之前设置一个起始时候，再由计算结束时的结束时间，最后取出它们的差值，就是这个计算所消耗的时间。想要实现这样的做法，可以使用 time 包中的 Now() 和 Sub 函数： 12345start := time.Now()longCalculation()end := time.Now()delta := end.Sub(start)fmt.Printf(\"longCalculation took this amount of time: %s\\n\", delta) 一般说内存缓存其实指的是动态规划"},{"title":"","date":"2019-04-16T02:14:12.000Z","updated":"2019-04-16T02:14:12.000Z","comments":true,"path":"wait/各种.html","permalink":"https://ghostlo.github.io/wait/各种.html","excerpt":"","text":"作者：jkgeekjack 链接：https://www.nowcoder.com/discuss/80156 来源：牛客网 个人简介本人是双非末流一本，大三，CS专业，有百度实习经历 过程先解释一下十面阿里，总共分为阿里云四面，蚂蚁两面，菜鸟四面；七面头条分为金融三面，抖音一面，效率工程三面；六个Offer分别是阿里、腾讯、头条、华为、蘑菇街、三七互娱。 从二月份在牛客网看到阿里云的招聘贴就投了，那是我最早投递的公司，当时也没什么经验，导致表现得很糟糕，最后四面跪，当时伤心到谷底，幸好跪得比较早，跪了之后简历被释放掉，还可以继续内推。整个春招持续了4个月，对自己意志也是一个很大的挑战。我也有幸能与那么多优秀的人一起并肩作战，让我坚持到最后一刻，感谢有你们。 这个春招也遇到了很多奇怪的公司，比如说美团不知为何不给内推，CVTE笔试刷掉有实习经历的，吉比特挂得莫名其妙，网易玄学招人，京东20分钟面试，华为聊天招人 结果 面经阿里巴巴一面（36分钟）芝麻信用1.hashmap和hashtable区别2.为什么产生死锁3.jvm类加载4.java反射获取私有属性，改变值5.反射用途6.所用数据库7.项目难点，问题8.如何解决项目中遇到的问题9.项目中遇到最自豪的地方10.会什么算法 二面（44分钟）支付宝创新1.讲项目2.数据库乐观锁使用3.状态机4.如何解决状态机不对问题5.如何分库分表6.MySQL极限7.HashMap源码8.设计一个线程安全的HashMap9.快排的实现，时间复杂度和空间复杂度10.会什么算法11.如何把项目变成SOA架构12.Spring源码，最深刻的模块，aop用途13.JVM内存模型14.垃圾回收机制15.项目中查看垃圾回收 三面(33分钟)菜鸟国际1.项目中的权限管理2.登录状态如何储存3.session和cookie的区别,session如何管理4.HashMap底层结构5.synchronized关键字的用法6.synchronized修饰类方法和普通方法的锁区别,获取类锁之后还能获取对象锁吗7.类加载器的双亲委派模型的作用,能重复加载某个类吗8.类加载器的类的缓存,key是什么9.介绍Redis10.如何将数据分布在不同的Redis11.有了解过取余算法?12.spring的apo实现13.字节码结构14.浏览器输入网址过程,结合springmvc 四面(36分钟)菜鸟国际供应链1.HashMap在大量哈希冲突该怎么处理2.红黑树比BST优点3.MySQL为什么使用B+树4.多个索引会有多份数据吗5.数据库的隔离级别和解决的问题6.数据库默认隔离级别,一定会产生幻读吗,怎么解决7.输入网址到展示的整个过程,结合springmvc来讲8.负载均衡的算法9.哈弗曼编码,如何解决译码问题10.实习会对工作有影响吗11.用英文介绍一个项目12.如何查看系统负载13.描述一个解决问题的过程14.如何把文件从服务器复制到本地,用什么命令 五面（27分钟）菜鸟技术部1.当时怎么找到百度这个机会的2.项目中用的哪些技术3.项目如何设计流程流转，如果是你的话该怎么设计4.MySQL使用的索引结构，查找效率5.MySQL查询优化6.MySQL慢查询开启，语句分析7.HashMap查找效率8.JVM内存模型9.设计模式，策略模式的使用场景10.如何确保单例线程安全11.Spring的bean的默认范围12.对Netty的了解13.未来发展规划14.如何让代码可读性更加复杂 六面（22分钟）HR面1.说一下发展方向2.说一下经验不足导致的问题3.说一下挑战杯的工作内容4.说一下你给挑战杯项目的主要贡献5.实习时间6.拿到了哪些offer，你是怎么考虑的7.为什么不选择腾讯8.腾讯技术栈和阿里技术栈的区别 腾讯一面（支付）1.jqc的介绍2.如何确保多台机器不会重复消费3.如何确保消费了反馈失效问题（用事务管理，先储存再消费，失败就回滚）4.如何防止数据库单点问题8.paxos算法9.raft算法10.spring的aop实现11.三种操作,a:++,b:—,c:/2(只能偶数)，求i变1的最少次数12.人才培养（轮流尝试，提出任务，鼓励实现）13.没有深度的广度没有意义，由广变宅，由浅入深14.设计时需要经验但堤防经验主义15.百度技术氛围比腾讯好 二面1.手写多线程买票代码2.手写ServerSocket使用代码3.java有多少种线程池，固定线程池是怎样的4.Collection的子接口5.Map的接口，HashMap应用场景6.Queue的父接口，使用场景7.数据库主从复制配置8.Spring的IOC优点，解决了什么问题（解耦）9.Bean的生命周期10.Bean的范围，gobal session的作用11.手写SpringMVC流程12.如何平衡生活和工作13.职业发展规划14.为何不考研15.redirect和forward区别16.大学中最大的挑战17.加密算法 HR面1.喜欢做什么2.喜欢看什么电影,带着什么心态去看3.会再回百度吗4.还有什么面试5.腾讯阿里选什么,为什么选腾讯6.是否独生7.家里人希望做什么 今日头条抖音一面1.手撕LFU，要求get和put都为O(1)2.在一个环状的城市，小偷可以选择偷或者不偷任意一家，但被偷的房子不能相连，求最大价值 效率工程一面1.储水题2.如何找项目性能瓶颈3.有多少种类型的缓存,从客户端到服务端4.如何查看系统性能,性能指标5.redis数据类型6.redis的aof太大如何优化7.mysql的主从复制8.mysql的引擎,区别9.https的建立链接过程10.https的传输数据是否是对称加密11.tcp拥塞控制12.epoll和select13.nginx如何处理连接14.nginx如何做性能优化15.apache和nginx区别16.两支不均匀香,测出15分钟 效率工程二面1.手写LRU2.查看系统负载3.进程通信方法4.管道如何使用5.socket建立过程6.如何高效处理socket7.NIO的原理和,连接切换方式8.使用什么命令查看系统负载,第一行是什么9.一个表user_id,order_date,要查用户订单,某一天订单,某个用户某天订单,如何建索引10.复合索引的结构11.redis的常用数据结构12.zset的底层数据结构,跳跃表如何实现13.redis如何持久化RDB 效率工程HR面1.怎么找到百度实习和第一份实习2.如何处理学业和实习3.讲一下项目中沟通协作的过程4.如何你是owner你是怎么设计这个项目5.拿到了什么offer，如何考虑 蘑菇街一面1.凤聆的权限管理如何设计2.如何将9s提升到0.3s3.用没有了解过其他搜索框架例如solr4.有了解过协程吗？轻在哪5.jvm查看gc命令6.如何解决jvm的问题7.mysql in，not in,like走不走索引8.开发环境，开发IDE9.使用什么命令查看cpu和内存情况10.如何查看进程的线程情况top -H -p11.秒杀场景设计12.秒杀时如果机器资源有限怎么办13.可以保证实习时间14.对自己未来的规划 二面(小程序部门)1.父母对来杭州有没有意见2.会考虑转正吗3.老师或者同学会怎么评价,如何体现技术比较强4.大学中最自豪的一件事5.项目中解决的一个问题6.Nginx超时怎么办7.mysql索引相关8.%匹配实现原理9.获取www.baidu.com最后一个点的内容”com”最优方法,为何,时间复杂度,如何实现 HR面1.深层介绍自己2.对你影响比较深的一个人3.想成为怎样的人4.最有成就感的事5.最近的挫折6.怎么发现瓶颈7.学校和工作环境有什么不同8.周围同学比较,有什么优势 京东一面1.快排原理2.HashMap底层结构3.ConcurrentHashMap线程安全原理4.类加载机制5.左连接和右连接区别6.tcp建立连接的方式7.close wait和time wait在什么情况下出现8.http组成9.http头部，keepalive的意义10.https流程11.如何确保密钥安全，是否非对称加密12.线程池的实现原理 二面1.在百度学习到什么2.对java的了解哪些方面3.还了解过其他语言吗，不同语言只是不同偏好4.aqs的具体实现5.并发包用到那些 HR面1.在百度学习到什么2.为什么从百度离职3.有什么优点和缺点4.遇到问题是偏向解决问题，还是抱怨问题5.能实习多久 网易邮箱一面1.java公司2.dfs和bfs实现原理和应用场景3.ArrayList的底层实现4.Elastisearch的索引如何储存5.JVM内存模型6.java堆分代，对象分配7.在项目中遇到什么问题，如和解决8.对自己这个项目打几分，为何转项目9.HashMao底层实现,介绍红黑树10.String a=”abc” String b=”a”+”bc” a==b?11.遇到紧急的需求该如何完成12.手写ArrayList添加11个元素13.n个0~9的数，找和为7的数对14.MySQL的引擎，所使用索引的结构15.B树和B+树的区别16.代码优化地方17.平时看什么论坛18.自研JQC的实现原理，和kafka的区别19.抢红包实现20.如何传输密码（非对称加密，https）21.https的证书在哪颁发 终面（HR+主管）1.如何找到两个实习2.学校允许实习吗3.项目中的挑战4.通过学习解决的最大一个困难5.如何处理项目，学习，实习的时间6.为什么离职百度7.为什么得不到上司的信任，当时有更好的选择吗 网易游戏1.如何保证项目扩展性,依赖问题2.消息队列同时消费问题3.进程的通讯方式？哪种最高效4.本机socket需要经过协议栈解包吗5.linux文件管理，文件类型6.一致性哈希实现7.统计海量词频最高10个单词，所用的数据结构8.强类型/弱类型和静态类型/动态类型9.JVM类加载器10.查看机器性能11.查看cpu负载，一般为多少，过高怎么解决12.机器性能是如何读取的 三七互娱一面1.Bean的生命周期2.Atom类实现原理3.多线程实现4.Thread和Runnable区别5.volatile特性6.happens-bofore原则7.消息队列，kafka8.如何确保形成安全9.HashMap初始大小，红黑树何时退化为链表10.Actor，Akka和RingBuffer11.冒泡排序12.JVM内存模型13.垃圾回收机制 HR面1.有没有面其他公司2.薪资待遇期待3.上一份工作为何离职 商汤一面1.看过JDK源码吗2.HashMap增删查和数据结构3.MySQL慢SQL查询和优化，如何排查问题4.MySQL引擎和区别，引用场景5.redis集群，如何拓展6.mongodb和redis区别7.单例模式的实现，是否只拥有一个实例8.SpringCloud生态9.介绍一下Elastisearch，原理和用途，分布式实时日志才需使用ELK10.有用过线程池吗11.介绍JVM垃圾回收机制 吉比特一面（游戏运营开发，账号安全）1.有参加acm吗2.怎么去百度的3.mysql用什么锁，行级锁有什么缺点4.mysql优化5.比较两个数相同位数6.如何体现对技术的热爱7.ArrayList和数组区别，调用add方法会调用哪些其他方法 个人感受春招是一个很刺激且很折磨人的过程，你可能会遇到各种奇奇怪怪的公司，但只有不断提升自己的实力，才有更大可能拿到Offer，拿不到Offer的小伙伴也不要气馁，毕竟秋招才是重头戏，还有那么长的时间可以准备，我相信你春招过后也知道自己哪方面比较薄弱。我自己也是很幸运，在春招的过程中不仅收获到了Offer，而且在我最紧张，最低落的时候遇到了我的现女友，一个可爱的妹子，感觉是她带给我幸运。最后祝大家收获更多的Offer，也能遇到对的人。 更多笔经面经：https://www.nowcoder.com/discuss?type=2&amp;order=3 与作者交流：[https://www.nowcoder.com/discuss/80156](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/80156"}],"posts":[{"title":"go学习(五)","slug":"Go学习5","date":"2019-04-25T00:46:32.000Z","updated":"2019-04-26T12:44:54.000Z","comments":true,"path":"2019/04/25/Go学习5/","link":"","permalink":"https://ghostlo.github.io/2019/04/25/Go学习5/","excerpt":"","text":"字符类型严格来说，这并不是 Go 语言的一个类型，字符只是整数的特殊用例。byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。例如：var ch byte = &#39;A&#39;；字符使用单引号括起来。 在 ASCII 码表中，A 的值是 65，而使用 16 进制表示则为 41，所以下面的写法是等效的： 1var ch byte = 65 或 var ch byte = &apos;\\x41&apos; （\\x 总是紧跟着长度为 2 的 16 进制数） 另外一种可能的写法是 \\ 后面紧跟着长度为 3 的八进制数，例如：\\377。 不过 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。其实 rune 也是 Go 当中的一个类型，并且是 int32的别名。 在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 \\u 或者 \\U。 因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \\U前缀；前缀 \\u 则总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 示例 4.12 char.go 12345678910111213var ch int = '\\u0041'var ch2 int = '\\u03B2'var ch3 int = '\\U00101234'fmt.Printf(\"%d - %d - %d\\n\", ch, ch2, ch3) // integerfmt.Printf(\"%c - %c - %c\\n\", ch, ch2, ch3) // characterfmt.Printf(\"%X - %X - %X\\n\", ch, ch2, ch3) // UTF-8 bytesfmt.Printf(\"%U - %U - %U\", ch, ch2, ch3) // UTF-8 code point/*65 - 946 - 1053236A - β - r41 - 3B2 - 101234U+0041 - U+03B2 - U+101234*/ 格式化说明符 %c 用于表示字符；当和字符配合使用时，%v 或 %d 会输出用于表示该字符的整数；%U 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。 timetime包为我们提供了一个数据类型time.Time`（作为值使用）以及显示和测量时间和日期的功能函数。 当前时间可以使用 time.Now() 获取，或者使用 t.Day()、t.Minute() 等等来获取时间的一部分；你甚至可以自定义时间格式化字符串，例如： fmt.Printf(&quot;%02d.%02d.%4d\\n&quot;, t.Day(), t.Month(), t.Year()) 将会输出 21.07.2011。 Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。 包中的一个预定义函数 func (t Time) Format(layout string) string 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，你可以使用一些预定义的格式，如：time.ANSIC 或 time.RFC822。 一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，这听起来很奇怪，但看下面这个例子你就会一目了然： 1fmt.Println(t.Format(&quot;02 Jan 2006 15:04&quot;)) 输出： 121 Jul 2011 10:31 其它有关时间操作的文档请参阅 官方文档（ 译者注：国内用户可访问 该页面 ）。 示例 4.20 time.go 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"time\")var week time.Durationfunc main() &#123; t := time.Now() fmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011 fmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year()) // 21.12.2011 t = time.Now().UTC() fmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011 fmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011 // calculating times: week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec week_from_now := t.Add(time.Duration(week)) fmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011 // formatting times: fmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC fmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011 fmt.Println(t.Format(\"02 Jan 2006 15:04\")) // 21 Dec 2011 08:52 s := t.Format(\"20060102\") fmt.Println(t, \"=&gt;\", s) // Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221&#125; 输出的结果已经写在每行 // 的后面。 如果你需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 time.After 或者 time.Ticker：我们将会在第 14.5 节讨论这些有趣的事情。 另外，time.Sleep（Duration d） 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。","categories":[{"name":"Go","slug":"Go","permalink":"https://ghostlo.github.io/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://ghostlo.github.io/tags/go/"},{"name":"语言学习","slug":"语言学习","permalink":"https://ghostlo.github.io/tags/语言学习/"}]},{"title":"go学习（四）","slug":"Go学习4","date":"2019-04-25T00:46:32.000Z","updated":"2019-04-26T12:42:49.000Z","comments":true,"path":"2019/04/25/Go学习4/","link":"","permalink":"https://ghostlo.github.io/2019/04/25/Go学习4/","excerpt":"","text":"封装驼峰命名法首字母大写：public首字母小写：private 包每个目录一个包main包包含可执行入口为结构定义的包必须放在一个文件内，可以是不同文件扩充系统类型： 定义别名 使用组合 duck typing python解释型语言 123def download(retriever):return retriever.get()#运行时才知道有没有get方法 c++编译型语言 12345template &lt;class T&gt;string download(const T&amp; retriever)&#123;return retriever.get();&#125;//编译时才知道有没有get方法 java 1234 &lt;T extends Retriever&gt; String download(T r)&#123;return r.get(); &#125; go apache polygene 接口只规定实现接口的方法，由使用者再来定义方法 采用值传递，几乎不用接口的指针 123456type Retriever interface&#123; Get(source string) string&#125;//接口变量 实现者类型 实现者的值 自带指针func download(retriever Retriever) string&#123; return retriever.Get()&#125; 运算符有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 12345678优先级 运算符 7 ^ ! 6 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 5 + - | ^ 4 == != &lt; &lt;= &gt;= &gt; 3 &lt;- 2 &amp;&amp; 1 ||","categories":[{"name":"Go","slug":"Go","permalink":"https://ghostlo.github.io/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://ghostlo.github.io/tags/go/"},{"name":"语言学习","slug":"语言学习","permalink":"https://ghostlo.github.io/tags/语言学习/"}]},{"title":"go学习（三）","slug":"Go学习3","date":"2019-04-23T01:32:28.000Z","updated":"2019-04-24T00:34:09.000Z","comments":true,"path":"2019/04/23/Go学习3/","link":"","permalink":"https://ghostlo.github.io/2019/04/23/Go学习3/","excerpt":"","text":"租房去了…真累 rune123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; s:= \"ostlo 测试！\" fmt.Println(s) for _,b:=range []byte(s)&#123; fmt.Printf(\"%x\\t\",b) &#125; fmt.Println() for i,ch :=range s&#123;// ch is a rune fmt.Printf(\"(%d %X)\",i,ch)//utf-8解码-&gt;unicode &#125; fmt.Println() fmt.Println(\"Rune count:\",utf8.RuneCountInString(s)) bytes:=[]byte(s) for len(bytes)&gt;0&#123; ch, size :=utf8.DecodeRune(bytes) bytes=bytes[size:] fmt.Printf(\"%c\",ch) &#125; fmt.Println() for i,ch :=range []rune(s)&#123; fmt.Printf(\"(%d %c)\", i, ch) &#125; fmt.Println()&#125;/*6f 73 74 6c 6f 20 e6 b5 8b e8 af 95 ef bc 81 (0 6F)(1 73)(2 74)(3 6C)(4 6F)(5 20)(6 6D4B)(9 8BD5)(12 FF01)Rune count: 9ostlo 测试！(0 o)(1 s)(2 t)(3 l)(4 o)(5 )(6 测)(7 试)(8 ！)*/ rune相当于go的char range遍历pos rune对 len字节长度 []byte字节 12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"func lengthofNonRepeatingSubStr1(s string) int&#123; lastOccured:=make(map[rune] int) start:=0 maxLength:=0 for i,ch := range []rune(s)&#123;//range s每个中文算3个长 if lastI, ok :=lastOccured[ch];ok &amp;&amp;lastI&gt;=start&#123; start=lastI+1 &#125; if i-start+1&gt;maxLength&#123; maxLength=i-start+1 &#125; lastOccured[ch]=i &#125; return maxLength&#125;func main() &#123; fmt.Println(lengthofNonRepeatingSubStr1(\"abcba\")) fmt.Println(lengthofNonRepeatingSubStr1(\"\")) fmt.Println(lengthofNonRepeatingSubStr1(\"abcv3a\")) fmt.Println(lengthofNonRepeatingSubStr1(\"中文测试\")) fmt.Println(lengthofNonRepeatingSubStr1(\"中文中文测试测试\"))&#125;/*30544*/ struct123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport \"fmt\"type treeNode struct&#123; value int left,right *treeNode//没有构造函数&#125;//工程函数func creatNode(value int) *treeNode&#123; return &amp;treeNode&#123;value: value&#125;//可以直接返回局部变量的地址&#125;func (node treeNode) print()&#123;//node treeNode 相当于*this指针 fmt.Println(node.value)&#125;func (node treeNode) setvalue(value int)&#123;//拷贝 node.value=value&#125;func (node *treeNode) setvalue_p(value int)&#123;//使用指针才能改变结构的内容 if node==nil &#123; fmt.Println(\"set value to nil node\") return &#125; node.value=value&#125;func (node *treeNode) traverse()&#123; if node==nil&#123; return &#125; node.left.traverse() node.print() node.right.traverse()&#125;func main() &#123; var root treeNode root=treeNode&#123;value:3&#125; root.left = &amp;treeNode&#123;&#125; root.right = &amp;treeNode&#123;5,nil,nil&#125; root.right.left = new(treeNode) nodes := []treeNode&#123; &#123;value:3&#125;, &#123;&#125;, &#123;6,nil,&amp;root&#125;, &#125; fmt.Println(nodes) root.right.left=creatNode(2) root.print() root.right.left.setvalue(4) root.right.left.print() root.right.left.setvalue_p(4) root.right.left.print() var pRoot *treeNode pRoot.setvalue_p(10) //pRoot.print() pRoot = &amp;root pRoot.setvalue_p(20) pRoot.print() fmt.Print(\"开始遍历\\n\") root.traverse()&#125;/*[&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;6 &lt;nil&gt; 0xc000086000&#125;]324set value to nil node20开始遍历02045*/ 自定义工厂函数 返回局部变量的地址 那么在堆上还是栈上呢，不需要知道，有编译器设置，如果发现了地址的引用之类的就在堆上，没有返回此引用的话就在栈上 值与指针传递","categories":[{"name":"Go","slug":"Go","permalink":"https://ghostlo.github.io/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://ghostlo.github.io/tags/go/"},{"name":"语言学习","slug":"语言学习","permalink":"https://ghostlo.github.io/tags/语言学习/"}]},{"title":"go学习（二）","slug":"Go学习2","date":"2019-04-22T08:36:07.000Z","updated":"2019-04-23T01:32:55.000Z","comments":true,"path":"2019/04/22/Go学习2/","link":"","permalink":"https://ghostlo.github.io/2019/04/22/Go学习2/","excerpt":"","text":"Go语言特点没有对象，没有继承多态，没有泛型，没有try/catch 有接口，函数是变成，csp并发模型 变量类型1234bool,string(u)int,(u)int8,(u)int16,(u)int32,(u)int64,uintptrbyte,runefloat32,float64,complex64,complex128 rune是个字符型（char），与utf-8与unicode编码接轨，是32位 complex64 float32+float32 complex128 float64+float64 在使用格式化说明符时，可以使用 %v 来表示复数，但当你希望只表示其中的一个部分的时候需要使用 %f。 类型转换是强制的，没有隐式变量转换 当进行类似 a32bitInt = int32(a32Float) 的转换时，小数点后的数字将被丢弃。这种情况一般发生当从取值范围较大的类型转换为取值范围较小的类型时，或者你可以写一个专门用于处理类型转换的函数来确保没有发生精度的丢失。 123456789101112131415161718//从 int 型转换为 int8：func Uint8FromInt(n int) (uint8, error) &#123; if 0 &lt;= n &amp;&amp; n &lt;= math.MaxUint8 &#123; // conversion is safe return uint8(n), nil &#125; return 0, fmt.Errorf(\"%d is out of the uint8 range\", n)&#125;//从 float64 转换为 int：func IntFromFloat64(x float64) int &#123; if math.MinInt32 &lt;= x &amp;&amp; x &lt;= math.MaxInt32 &#123; // x lies in the integer range whole, fraction := math.Modf(x) if fraction &gt;= 0.5 &#123; whole++ &#125; return int(whole) &#125; panic(fmt.Sprintf(\"%g is out of the int32 range\", x))&#125; 对于整数和浮点数，你可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀： 12i++ -&gt; i += 1 -&gt; i = i + 1i-- -&gt; i -= 1 -&gt; i = i - 1 同时，带有 ++ 和 -- 的只能作为语句，而非表达式，因此 n = i++ 这种写法是无效的，其它像 f(i++) 或者 a[i]=b[i++] 这些可以用于 C、C++ 和 Java 中的写法在 Go 中也是不允许的 在运算时 溢出 不会产生错误，Go 会简单地将超出位数抛弃。如果你需要范围无限大的整数或者有理数（意味着只被限制于计算机内存），你可以使用标准库中的 big 包，该包提供了类似 big.Int 和 big.Rat 这样的类型 if1234567891011121314151617181920package mainimport ( \"fmt\" \"io/ioutil\")func main() &#123; const filename=\"trans/abc.txt\" if contents, err := ioutil.ReadFile(filename) ; err!=nil&#123; fmt.Println(err) &#125;else&#123; fmt.Printf(\"%s\\n\",contents) fmt.Println(contents) &#125;&#125;/*abc[97 98 99]*/ switchswitch会自动break，除非使用fallthrough for不需要括号，条件里可以省略初始条件，结束条件，递增表达式，另外for没有小括号 死循环 123for &#123;&#125; iota1234567891011121314151617181920type ByteSize float64const ( _ = iota // 通过赋值给空白标识符来忽略值 KB ByteSize = 1&lt;&lt;(10*iota) MB GB TB PB EB ZB YB)type BitFlag intconst ( Active BitFlag = 1 &lt;&lt; iota // 1 &lt;&lt; 0 == 1 Send // 1 &lt;&lt; 1 == 2 Receive // 1 &lt;&lt; 2 == 4)flag := Active | Send // == 3 可变函数列表1234567func sumArgs(value ...int) int&#123; sum:=0 for i:= range values&#123; sum+=values[i] &#125; return sum&#125; 返回值写最后 可以返回多个值 函数可以作为参数 没有默认参数 可以选参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( \"fmt\" \"math\" \"reflect\" \"runtime\")func eval(a,b int, op string)(int, error)&#123; switch op &#123; case \"+\": return a+b,nil case \"-\": return a-b,nil case \"*\": return a*b,nil case \"/\": q, _ := div(a,b) return q,nil default: return 0,fmt.Errorf( \"unsupported operation:%s\",op) &#125;&#125;func div(a,b int)(q,r int)&#123; return a/b, a%b&#125;func apply(op func(int,int) int, a,b int)int &#123; p:=reflect.ValueOf(op).Pointer() opName := runtime.FuncForPC(p).Name() fmt.Printf(\"Calling function %s with args: \"+\"(%d %d)\\n\",opName,a,b) return op(a,b)&#125;func pow(a,b int) int &#123; return int(math.Pow(float64(a),float64(b)))&#125;func sum (numbers ... int) int&#123; s:=0 for i:=range numbers&#123; s+=numbers[i] &#125; return s&#125;func main() &#123; if result,err := eval(3,4,\"x\"); err!=nil&#123; fmt.Println(\"Error\",err) &#125;else &#123; fmt.Println(result) &#125; q, r :=div(13,3) fmt.Println(q,r) fmt.Println(apply(func(a int, b int) int &#123; return int(math.Pow( float64(a),float64(b))) &#125;,3,4)) fmt.Println(apply(pow,3,3)) fmt.Println(sum(1,2,4,12 ,3))&#125;/*Error unsupported operation:x4 1Calling function main.main.func1 with args: (3 4)81Calling function main.pow with args: (3 3)2722*/ 指针go函数是传值 12345678910package mainimport \"fmt\"func swap(a,b *int) &#123; *a,*b=*b,*a&#125;func main() &#123; a,b :=3,4 swap(&amp;a,&amp;b) fmt.Println(a,b)&#125; 12345678910package mainimport \"fmt\"func swap(a,b int)(int,int) &#123; return b,a&#125;func main() &#123; a,b :=3,4 a,b = swap(a,b) fmt.Println(a,b)&#125; 数组可以用_省略一个值 123456789101112131415package mainimport \"fmt\"func main() &#123; var arr1 [5]int arr2 := [3]int&#123;1,3,5&#125; arr3 := [...]int&#123;2,4,6,8,10&#125; var grid [4][5]int fmt.Println(arr1,arr2,arr3) fmt.Println(grid) for i,v:=range arr3&#123; fmt.Println(i,v) &#125;&#125; 数组传入函数会拷贝 一般使用切片 切片内部是一个视图 s1[4]不存在，但slice可以view取出来 不超过cap就可以view扩展出来 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"func updateSlice(s []int) &#123; s[0]=100&#125;func main() &#123; arr := [...]int&#123;0,1,2,3,4,5,6,7&#125; fmt.Println(arr[2:6]) fmt.Println(arr[:6]) fmt.Println(arr[2:]) fmt.Println(arr[:]) s1:=arr[2:] fmt.Println(s1) updateSlice(s1) fmt.Println(s1) s2:=arr[:] fmt.Println(s2) updateSlice(s2) fmt.Println(s2) s3 := append(s2,10) s4 := append(s3,11) s5 := append(s4,12) fmt.Println(\"s3, s4, s5 = \",s3,s4,s5) fmt.Println(\"arr =\", arr)&#125;/*[2 3 4 5][0 1 2 3 4 5][2 3 4 5 6 7][0 1 2 3 4 5 6 7][2 3 4 5 6 7][100 3 4 5 6 7][0 1 100 3 4 5 6 7][100 1 100 3 4 5 6 7]s3, s4, s5 = [100 1 100 3 4 5 6 7 10] [100 1 100 3 4 5 6 7 10 11] [100 1 100 3 4 5 6 7 10 11 12]arr = [100 1 100 3 4 5 6 7]*/ 1234567891011121314151617181920212223242526package mainimport \"fmt\"func printSlice(s []int)&#123; fmt.Printf(\"len=%d, cap=%d\\n\", len(s), cap(s))&#125;func main() &#123; var s[] int for i:=0;i&lt;100;i++&#123; printSlice(s) s=append(s,2*i+1) &#125; fmt.Println(s) s1:=[]int&#123;2,4,6,8&#125; printSlice(s1) s2:=make([]int ,16) s3:=make([]int ,10 ,32) printSlice(s2) printSlice(s3) fmt.Println(\"Copying slice\") copy(s2,s1) printSlice(s2) fmt.Println(\"Deleting slements from slice\") s2=append(s2[:3],s2[4:]...) printSlice(s2)&#125; Map创建 make(map[string]int) key不存在时，获取value类型的初始值 value,ok:=m[key]来判断是否存在key delete删除一个key range遍历 len获取元素个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport \"fmt\"func main() &#123; m := map[string]string&#123;//hash map 无序 \"name\":\"ccmouse\", \"course\":\"golang\", \"site\":\"imooc\", \"quality\":\"notbad\", &#125; m2:=make(map[string]string)//m2==empty map var m3 map[string]int//m3==nil fmt.Println(m,m2,m3) for k,v:=range m&#123; fmt.Println(k,v) &#125; fmt.Println(\"Getting values\") courseName,ok:=m[\"course\"] fmt.Println(courseName,ok) if causeName,ok:=m[\"cause\"];ok&#123; fmt.Println(causeName) &#125;else &#123; fmt.Println(\"Key dosen't exist\") &#125; fmt.Println(\"Deleting values\") name,ok:=m[\"name\"] fmt.Println(name,ok) delete(m,\"name\") name,ok=m[\"name\"] fmt.Println(name,ok)&#125;/*map[course:golang name:ccmouse quality:notbad site:imooc] map[] map[]site imoocquality notbadname ccmousecourse golangGetting valuesgolang trueKey dosen't existDeleting valuesccmouse true false*/","categories":[{"name":"Go","slug":"Go","permalink":"https://ghostlo.github.io/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://ghostlo.github.io/tags/go/"},{"name":"语言学习","slug":"语言学习","permalink":"https://ghostlo.github.io/tags/语言学习/"}]},{"title":"go学习（一）","slug":"Go学习1","date":"2019-04-21T08:36:07.000Z","updated":"2019-04-22T14:01:25.000Z","comments":true,"path":"2019/04/21/Go学习1/","link":"","permalink":"https://ghostlo.github.io/2019/04/21/Go学习1/","excerpt":"","text":"安装下载安装包地址： https://golang.org/dl/ 安装包的位置一般是默认在usr/local/go 配置环境变量1、打开终端输入cd ~进入用户主目录; 2、输入ls -all命令查看是否存在.bash_profile; 3、存在既使用vim .bash_profile 打开文件; 4、输入 i 进入vim编辑模式； 5、输入下面代码， 其中 GOPATH: 日常开发的根目录。GOBIN:是GOPATH下的bin目录。 12345export GOPATH=/Users/longxiansheng/goexport GOBIN=$GOPATH/binPATH=\\$PATH:\\$GOBIN 这里列举几个最为重要的环境变量： $GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。 为了区分本地机器和目标机器，你可以使用 GOHOSTOS 和 GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（GOOS 和 GOARCH）一样。 $GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节。 安装Intellij golang设置SDK路径为usr/local/go go run/ go install/ go build / go get的区别 go run 运行当个.go文件 go install 在编译源代码之后还安装到指定的目录 go build 加上可编译的go源文件可以得到一个可执行文件 go get = git clone + go install 从指定源上面下载或者更新指定的代码和依赖，并对他们进行编译和安装 调试如果你不想使用调试器，你可以按照下面的一些有用的方法来达到基本调试的目的： 在合适的位置使用打印语句输出相关变量的值（print/println 和 fmt.Print/fmt.Println/fmt.Printf）。 在 fmt.Printf 中使用下面的说明符来打印有关变量的相关信息： %+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息 %T 打印某个类型的完整说明 使用 panic 语句（第 13.2 节）来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。 使用关键字 defer 来跟踪代码执行过程（第 6.4 节）。 编写程序特性LALR 是 Go 语言的语法标准，你也可以在 src/cmd/internal/gc/go.y 中查看到，这种语法标准在编译时不需要符号表来协助解析。 许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。 为了简化设计，不支持函数重载和操作符重载 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换 Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型 不支持动态加载代码 不支持动态链接库 不支持泛型 通过 recover 和 panic 来替代异常机制（第 13.2-3 节） 不支持静态变量 关于 Go 语言开发团队对于这些方面的讨论，你可以通过 Go 常见问题 页面查看。 格式化Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：go fmt（gofmt）。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 gofmt 来格式化你的代码。 在格式化输出时，你可以使用 %t 来表示你要输出的值为布尔型。 在格式化字符串里，%d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0d 用于规定输出定长的整数，其中开头的数字 0 是必须的。 %n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f [格式化代码-gitbook][https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/03.5.md] [与c,c++交互][https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/03.9.md] 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var Go 语言还有 36 个预定义标识符 append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 可见性规则当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。 你可以通过使用包的别名来解决包名之间的名称冲突 1234567package mainimport fm \"fmt\" // alias3func main() &#123; fm.Println(\"hello, world\")&#125; 当一个变量被声明之后(var)，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate。 首字母大写表示全局的。 123456fmt.Println（\"hello, world\"）//以下函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 fmt 中的相关函数。printprintln：print(\"ABC\")println(\"ABC\")println(i) 类型转换在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）： 1valueOfTypeB = typeB(valueOfTypeA) 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 常量的定义格式：const identifier [type] = value，例如： 1const Pi = 3.14159 在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 显式类型定义： const b string = &quot;abc&quot; 隐式类型定义： const b = &quot;abc&quot; 12var n intf(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。 正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出 声明变量的一般形式是使用 var 关键字：var identifier type。 Go 编译器的智商已经高到可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程。因此，你还可以使用下面的这些形式来声明及初始化变量： 123var a = 15var b = falsevar str = \"Go says hello to the world!\" 或： 1234567var ( a = 15 b = false str = \"Go says hello to the world!\" numShips = 50 city string) 你可以通过 &amp;i 来获取变量 i 的内存地址（第 4.9 节），例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。 在 Go 语言中，指针（第 4.9 节）属于引用类型，其它的引用类型还包括 slices（第 7 章），maps（第 8 章）和 channel（第 13 章）。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。 变量的类型也可以在运行时实现自动推断，例如： 12345var ( HOME = os.Getenv(\"HOME\") USER = os.Getenv(\"USER\") GOROOT = os.Getenv(\"GOROOT\")) 这种写法主要用于声明 包级别 的全局变量，当你在函数体内声明 局部变量 时，应使用简短声明语法 :=(即只能在函数体内用)，例如： 1a := 1 打印函数 Printf 可以在 fmt 包外部使用，这是因为它以大写字母 P 开头，该函数主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数： 1func Printf(format string, list of variables to be printed) 这个格式化字符串可以含有一个或多个的格式化标识符，例如：%..，其中 .. 可以被不同类型所对应的标识符替换，如 %s 代表字符串标识符、%v 代表使用类型的默认输出格式的标识符。这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加，如果参数超过 1 个则同样需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。 函数 fmt.Print 和 fmt.Println 会自动使用格式化标识符 %v 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。例如： 1fmt.Print(\"Hello:\", 23) 将输出：Hello: 23。 如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a： 1234func main() &#123; var a string = \"abc\" fmt.Println(\"hello, world\")&#125; 尝试编译这段代码将得到错误 a declared and not used。 此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用 fmt.Println(&quot;hello, world&quot;, a) 会移除错误。 同一类型的多个变量可以声明在同一行，如： 1var a, b, c int (这是将类型写在标识符后面的一个重要原因) 多变量可以在同一行进行赋值，如： 1a, b, c = 5, 7, \"abc\" 上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用： 1a, b, c := 5, 7, \"abc\" 右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 &quot;abc&quot;。 这被称为 并行 或 同时 赋值。 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a。 (在 Go 语言中，这样省去了使用交换函数的必要) 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。","categories":[{"name":"Go","slug":"Go","permalink":"https://ghostlo.github.io/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://ghostlo.github.io/tags/go/"},{"name":"语言学习","slug":"语言学习","permalink":"https://ghostlo.github.io/tags/语言学习/"}]},{"title":"C++学习","slug":"C-学习","date":"2019-04-15T14:38:01.000Z","updated":"2019-04-26T05:34:16.000Z","comments":true,"path":"2019/04/15/C-学习/","link":"","permalink":"https://ghostlo.github.io/2019/04/15/C-学习/","excerpt":"","text":"转载至： 天千 CSDN专家博主，西安邮电大学硕士研究生，BAT某厂C++研发工程师，热爱Linux内核、C++、喜欢写博客。 如何学好 Linux、C++，并搞定 BAT 面试gitbook.cn C++从小白到入门 C++我是从研究生入学前的二个月开始学习，基本算是零基础吧，就大学那会学了一些C的知识，经常写一个程序一堆”烫烫烫”，真的是到了本科毕业还没搞懂C语言。然后在这个二个月我开窍了，突然发现对C语言融汇贯通了， 而这一切要归功于《C和指针》这本书，总结一下，我认为C语言要学好必须理解三个概念。 什么是指针?，指针和数组的关系。 程序分为哪几个段，能说清楚全局变量，局部变量，静态变量等分别属于哪个段，各个段的特点是什么? C语言的编译和链的接过程 真心不推荐在Windows上来学习C语言，因为它屏蔽了太多的细节，而这些细节却又是C程序员不可或缺的一部分。C语言这个阶段过去后，我开始学习Linux C系统编程这个部分，最开始接触的一本书就是《Unix/Linux编程实践教程》强力推荐给大家，这本书会给你介绍如何通过man手册来帮助编程，如何去实现who、cat、ls、ps等系统命令。通过这本书的学习会让你对Linux上很多的原理有一个深刻的认识。 这本书学完后我就开始看UNP和APUE，其中APUE我并不推荐给大家，我推荐给大家的是《Linux/UNIX系统编程手册》这本书的内容更全面，更新。建议大家在看这些书的时候可以做详细的笔记和代码练习，在我的博客上就有我总结的文章。系统编程ok后，就要重点看UNP了，看这本书的时候要找重点看，里面有的章节已经过时了，还有一些章节对于我们目前来说用途并不大，比如STCP的部分。对于这本书重点有三个部分。 各个socket API的对应到OS，做了哪些事情，比如connect后，做了哪些事情?，accept呢?，什么是RST报文?，什么是SIGPIPE，如何触发的? 网络IO模型，同步和异步，阻塞和非阻塞的概念，Linux上各种网络IO模型的优缺点对比，epoll、select、信号驱动IO等 服务器的网络编程模型，多线程、多进程、线程池等，各自优缺点 在我的博客上也有一篇文章介绍了相关的内容，学完这个后，剩下的就靠多实践和多读一些开源的项目来积累自己的经验了，这里推荐cjson、webbench、Tinyhttpd等，代码量都不大，很容易读懂，在读懂的基础上可以进行适当的改造和重写。 C语言和Linux系统编程这个部分结束后，就要开始踏入C++的世界了，自从C++11出来后，我觉得C++易学了，但是苦于现存的老的C++代码还是有很多，所以我们不得不去学习C++98相关的知识，这里我推荐《C++ primer》一书，注意是C++ primer，不是《C++ primer plus》我看书的方法都比较老套，第一遍力求看懂，第二遍开始抄代码，练习，第三遍开始总结写博客。所以这本书我前前后后看了大半年， 后面又看了C++编程思想上册，Effective C++、深度理解C++对象模型、Exceptional C++、深入理解C++11等经典书籍，看书的模式基本上都是二到三遍，通过抄书上的代码和写博客来加深记忆。看完这些书说真的，我觉得我的C++还只是一个小白，我真正蜕变要从读《Linux C++服务端编程》陈硕的这本书开始，通过这本书我觉得我的C++水平有了一个质的飞跃。我理解C++有以下几个要点(只是部分): RAII，这个很重要，是C++的核心，很多学习了C++的人都不知道RAII 值语义和对象语义，这个决定了你如何写好一个C++类 对象的生命周期，类的生命周期要清晰 智能指针，现代C++编程几乎不太可能出现delete语句，内存泄漏的问题真的很少会出现 各种STL和C++的一些坑，比如迭代器遍历过程中如何删除元素、std::list的size接口的复杂度居然是O(N)（C++11已经修正）等等 善用std::bind和std::function 基于对象编程和面向对象编程的区别 移动语义很重要 Lambda的捕获表达式 搞清楚C++的三五法则 std::string的实现方式，是否是线程安全的 std::map和std::set的底层数据结构等 到了这个阶段后我就开始找工作了，上面的全部过程花费了研究生二年的时间，后来找到了某BAT实习的工作后，我就一边实习，一边读《Effective Modern C++》，这本书我重点推荐给大家，在我的博客上也有全部的总结，这本书讲了很多C++11种的一些实现细节、坑以及建议。最后推荐一些linux内核相关的书籍和学习方法 《深入理解Linux内核架构》 《Linux环境编程 从应用到内核》 http://lwn.net 重点找自己感兴趣的模块来看，比如我就对文件系统 通过内核模块来探索，不能只看代码不练习 网络上有很多从头开始编写一个内存文件系统的文章，在我的博客上也有一个系列讲解Linux内核模块编程入门的文章，通过编写Linux内核模块可以做很多有趣的事情，比如系统调用拦截、网络拦截、做安全审计等等，通过编写内核模块可以提高对Linux内核学习的兴趣。 BAT求职之路研究生阶段我主要面试了阿里巴巴、腾讯、网易都是C++研发工程师，只有网易拿到的是实习的Offer，其他的都是拿到了实习和正式的Offer，就C++这个岗位来说，阿里巴巴的要求明显高于腾讯和网易，网易的C++面试相对容易一些，问的很基础，感觉就是走个过场，都没问什么太难的问题，可能是因为是招实习吧，腾讯的C++面试偏基础从OS、网络、编译原理、算法等。问题都不太难，问的比较广，阿里巴巴更侧重知识面、底层原理、解决问题的能力等。我阿里巴巴一共面了五面，问了很多C++、算法、Linux内核等知识，在整个求职过程中，我做了以下几件事: 刷leetcode的题目 从牛客网和google上搜集面试题，分门别类的进行整理，每天都回顾一下 拓宽自己的知识面，学习一些新的知识，比如当时流行的docker，更侧重学习其原理 加深自己对一些底层的OS知识的理解，比如epoll的原理、docker的cgroup机制和namespace机制的实现、文件系统VFS的实现、Linux信号、管道等的实现。 整理面试题和学习一些底层的OS知识对我整个面试过程中帮助很大，正常情况下如果你只学习Java或者C++是很难拿到阿里巴巴的Offer，阿里巴巴对应届生的知识面、知识的理解程度要求还是比较高的，在我的整个C++面试过程中，问的最多的就是IO复用、智能指针、内存泄漏的问题如何解决、如何排查Load高的问题、Linux内核相关的知识等，而这些问题对我来说早已得心应手，在搜集面试题的时候很多问题都是反复被提及到的，我只需要好好总结即可。 另外一点就是大家在准备面试题的时候不能只记一个结论，多问问为什么，举个例子，TCP/IP的三次握手和四次挥手的过程是什么样的，我们不光光要知道这个问题的结论，还要知道为什么是三次握手，四次挥手，为什么不是二次？当被问及到epoll、select的区别时，你应该从使用方法、可移植性、性能、优缺点、内核实现等多个方面分析和总结。而不是简简单单的就提及一个优缺点就完事了。 你擅长的地方你应该多多引导你的面试官去问。 工作心得在公司实习了大约1年，今年七月份正式入职，在这整个过程中我也零散的做了很多小需求，对C++的理解更加深刻，尤其是对软件工程有了一个新的理解，在此我想分享给大家。 要有造轮子的能力，但是不要轻易的去造轮子 单元测试的重要性，通过单元测试也可以提高程序员的信心，为了更好的写单测，会逼迫我们将模块之间的耦合降到最低，这样可以方便单测。 写易读的、可维护的代码 Google的C++编程规范，每一条都值得细细品味 Chromium开源项目有很多值得我们借鉴的地方 画UML图是程序员的基本素质，要有好的设计，设计要做评审 CodeReview一定要有的 类名和变量名的易读性 可能对于很多人来说编码规范、CodeReview、UML、单测好像都是说说而已，我起初也是这么认为，感触并不是很深刻，直到我的同事开始带我的时候，我自己亲身去体验的时候才发现这其中奥妙无穷， 我们团队使用Chromium的base库作为自己的基础库，编码规范、全都follow Chromium，至于为什么不用boost，我的理由则是，boost是一个我无法驾驭的怪兽，而chromium的base库是我可以驾驭的，可以打组合拳，代码的稳定性已经经过上亿人的考验，值得我们信赖。推荐大家看看chromium的base库，源代码很易读。通过阅读它的代码可以学习到很多知识。推荐一本书给大家《C++ API设计》，讲解了很多软件工程、设计层面的知识。 总结上面说了很多，更侧重分享了我的学习经历，和一些感悟，可能我说的比较简单，实际上理解上面这些东西，是存在一个过程的，是一个从量变到质变的过程，在整个过程中我理解到，学习要坚持，不是一蹴而就的，要经历量变到质变的过程。","categories":[{"name":"C++","slug":"C","permalink":"https://ghostlo.github.io/categories/C/"}],"tags":[{"name":"语言学习","slug":"语言学习","permalink":"https://ghostlo.github.io/tags/语言学习/"},{"name":"c++","slug":"c","permalink":"https://ghostlo.github.io/tags/c/"}]},{"title":"lfu and lru","slug":"suanfa-1","date":"2019-04-14T14:26:27.000Z","updated":"2019-04-14T14:38:48.000Z","comments":true,"path":"2019/04/14/suanfa-1/","link":"","permalink":"https://ghostlo.github.io/2019/04/14/suanfa-1/","excerpt":"","text":"leetcode 146 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 这道题让我们实现一个LRU缓存器，LRU是Least Recently Used的简写，就是最近最少使用的意思。那么这个缓存器主要有两个成员函数，get和put，其中get函数是通过输入key来获得value，如果成功获得后，这对(key, value)升至缓存器中最常用的位置（顶部），如果key不存在，则返回-1。而put函数是插入一对新的(key, value)，如果原缓存器中有该key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。具体实现时我们需要三个私有变量，cap, l和m，其中cap是缓存器的容量大小，l是保存缓存器内容的列表，m是HashMap，保存关键值key和缓存器各项的迭代器之间映射，方便我们以O(1)的时间内找到目标项。 然后我们再来看get和put如何实现，get相对简单些，我们在HashMap中查找给定的key，若不存在直接返回-1。如果存在则将此项移到顶部，这里我们使用C++ STL中的函数splice，专门移动链表中的一个或若干个结点到某个特定的位置，这里我们就只移动key对应的迭代器到列表的开头，然后返回value。这里再解释一下为啥HashMap不用更新，因为HashMap的建立的是关键值key和缓存列表中的迭代器之间的映射，get函数是查询函数，如果关键值key不在HashMap，那么不需要更新。如果在，我们需要更新的是该key-value键值对儿对在缓存列表中的位置，而HashMap中还是这个key跟键值对儿的迭代器之间的映射，并不需要更新什么。 对于put，我们也是现在HashMap中查找给定的key，如果存在就删掉原有项，并在顶部插入新来项，然后判断是否溢出，若溢出则删掉底部项(最不常用项)。 技巧，用map保存iteration指针来删除数组 12345678910111213141516171819202122232425262728293031323334353637383940414243class LRUCache&#123;public: LRUCache(int capacity) &#123; maxSize = capacity; &#125; int get(int key) &#123; if (index.find(key) == index.end()) return -1; int value=index[key]-&gt;second; data.erase(index[key]); data.push_front(make_pair(key,value)); index[key]=data.begin(); return value; &#125; void put(int key, int value) &#123; if (index.find(key) != index.end()) &#123; data.erase(index[key]); data.push_front(make_pair(key,value)); index[key]=data.begin(); &#125; else &#123; if (data.size() == maxSize) &#123; index.erase(data.back().first); data.pop_back(); &#125; data.push_front(make_pair(key,value)); index[key] = data.begin(); &#125; &#125; private: int maxSize; list&lt;pair&lt;int, int&gt;&gt; data; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; index;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940static const auto _ = []() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); return 0;&#125;();class LRUCache final &#123; const int capacity; list&lt;int&gt; keys; unordered_map&lt;int, pair&lt;int, list&lt;int&gt;::iterator&gt;&gt; values;public: LRUCache(const int capacity) noexcept : capacity(capacity) &#123;&#125; int get(const int key) noexcept &#123; const auto it = values.find(key); if (it == values.end()) return -1; if (it-&gt;second.second != keys.begin()) keys.splice(keys.begin(), keys, it-&gt;second.second); return it-&gt;second.first; &#125; void put(const int key, const int value) noexcept &#123; if (!capacity) return; const auto it = values.find(key); if (it != values.end()) &#123; if (it-&gt;second.second != keys.begin()) keys.splice(keys.begin(), keys, it-&gt;second.second); it-&gt;second.first = value; return; &#125; if (keys.size() == capacity) &#123; values.erase(keys.back()); if (capacity &gt; 1) keys.splice(keys.begin(), keys, prev(keys.end())); keys.front() = key; &#125; else keys.push_front(key); values[key] = &#123;value, keys.begin()&#125;; return; &#125;&#125;; leetcode 460 Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted. Follow up:Could you do both operations in O(1) time complexity? Example: 123456789101112LFUCache cache = new LFUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.get(3); // returns 3.cache.put(4, 4); // evicts key 1.cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 由于需要删除最少次数的数字，那么我们必须要统计每一个key出现的次数，所以我们用一个哈希表m来记录当前数据{key, value}和其出现次数之间的映射，这样还不够，为了方便操作，我们需要把相同频率的key都放到一个list中，那么需要另一个哈希表freq来建立频率和一个里面所有key都是当前频率的list之间的映射。由于题目中要我们在O(1)的时间内完成操作了，为了快速的定位freq中key的位置，我们再用一个哈希表iter来建立key和freq中key的位置之间的映射。最后当然我们还需要两个变量cap和minFreq，分别来保存cache的大小，和当前最小的频率。 为了更好的讲解思路，我们还是用例子来说明吧，我们假设cache的大小为2，假设我们已经按顺序put进去5，4，那么来看一下内部的数据是怎么保存的，由于value的值并不是很重要，为了不影响key和frequence，我们采用value#来标记： m: 5 -&gt; {value5, 1} 4 -&gt; {value4, 1} freq: 1 -&gt; {5，4} iter: 4 -&gt; list.begin() + 1 5 -&gt; list.begin() 这应该不是很难理解，m中5对应的频率为1，4对应的频率为1，然后freq中频率为1的有4和5。iter中是key所在freq中对应链表中的位置的iterator。然后我们的下一步操作是get(5)，下面是get需要做的步骤： 如果m中不存在5，那么返回-1 从freq中频率为1的list中将5删除 将m中5对应的frequence值自增1 将5保存到freq中频率为2的list的末尾 在iter中保存5在freq中频率为2的list中的位置 如果freq中频率为minFreq的list为空，minFreq自增1 返回m中5对应的value值 经过这些步骤后，我们再来看下此时内部数据的值： m: 5 -&gt; {value5, 2} 4 -&gt; {value4, 1} freq: 1 -&gt; {4} 2 -&gt; {5} iter: 4 -&gt; list.begin() 5 -&gt; list.begin() 这应该不是很难理解，m中5对应的频率为2，4对应的频率为1，然后freq中频率为1的只有4，频率为2的只有5。iter中是key所在freq中对应链表中的位置的iterator。然后我们下一步操作是要put进去一个7，下面是put需要做的步骤： 如果调用get(7)返回的结果不是-1，那么在将m中7对应的value更新为当前value，并返回 如果此时m的大小大于了cap，即超过了cache的容量，则： a）在m中移除minFreq对应的list的首元素的纪录，即移除4 -&gt; {value4, 1} b）在iter中清除4对应的纪录，即移除4 -&gt; list.begin() c）在freq中移除minFreq对应的list的首元素，即移除4 在m中建立7的映射，即 7 -&gt; {value7, 1} 在freq中频率为1的list末尾加上7 在iter中保存7在freq中频率为1的list中的位置 minFreq重置为1 经过这些步骤后，我们再来看下此时内部数据的值： m: 5 -&gt; {value5, 2} 7 -&gt; {value7, 1} freq: 1 -&gt; {7} 2 -&gt; {5} iter: 7 -&gt; list.begin() 5 -&gt; list.begin()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class LFUCache &#123;public: int capacity; int size; int minFreq; unordered_map&lt;int, pair&lt;int, int&gt;&gt; m; unordered_map&lt;int, list&lt;int&gt;::iterator&gt; indexMap; unordered_map&lt;int, list&lt;int&gt;&gt; freqMap; LFUCache(int capacity) &#123; this-&gt;capacity = capacity; size = 0; &#125; int get(int key) &#123; if(m.find(key) != m.end())&#123; freqMap[m[key].second].erase(indexMap[key]); m[key].second++; freqMap[m[key].second].push_back(key); indexMap[key] = --freqMap[m[key].second].end(); if(freqMap[minFreq].size() == 0) minFreq++; return m[key].first; &#125;else return -1; &#125; void put(int key, int value) &#123; if(capacity == 0) return; if(get(key) == -1)&#123; if(size &gt;= capacity)&#123; m.erase(freqMap[minFreq].front()); indexMap.erase(freqMap[minFreq].front()); freqMap[minFreq].pop_front(); size--; &#125; minFreq = 1; m[key] = pair&lt;int, int&gt;&#123;value, 1&#125;; freqMap[1].push_back(key); indexMap[key] = --freqMap[1].end(); size++; &#125;else &#123; m[key].first = value; &#125; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static int x = []() &#123; ios::sync_with_stdio(false); cin.tie(NULL); return 0; &#125;();class LFUCache &#123;private: typedef pair&lt;int, int&gt; P; typedef list&lt;P&gt; L; typedef L::iterator I; typedef unordered_map&lt;int, L&gt; C2L; typedef unordered_map&lt;int, I&gt; K2I; typedef unordered_map&lt;int, int&gt; K2C; C2L countToEntryList; K2I keyToIter; K2C keyToCount; int maxSize, minCount = 0;public: /* time: O(1), space: O(1) auxiliary (i.e. does not count cache capacity itself) */ LFUCache(int capacity) : maxSize(capacity) &#123; &#125; /* time: O(1), space: O(1) auxiliary (i.e. does not count cache capacity itself) */ int get(int key) &#123; if (!keyToIter.count(key)) return -1; const int oldCount = keyToCount[key], newCount = oldCount + 1; auto&amp; oldEntryList = countToEntryList[oldCount]; auto&amp; newEntryList = countToEntryList[newCount]; newEntryList.splice(newEntryList.begin(), oldEntryList, keyToIter[key]); keyToIter[key] = newEntryList.begin(), keyToCount[key] = newCount; if (oldEntryList.empty()) &#123; countToEntryList.erase(oldCount); if (minCount == oldCount) minCount = newCount; &#125; return keyToIter[key]-&gt;second; &#125; /* time: O(1), space: O(1) auxiliary (i.e. does not count cache capacity itself) */ void put(int key, int value) &#123; if (!maxSize) return; if (get(key) != -1) &#123; keyToIter[key]-&gt;second = value; return; &#125; if (keyToIter.size() == maxSize) &#123; auto&amp; entryList = countToEntryList[minCount]; const int LRFKey = entryList.back().first; keyToIter.erase(LRFKey), keyToCount.erase(LRFKey); entryList.pop_back(); if (entryList.empty()) countToEntryList.erase(minCount); &#125; minCount = 1; auto&amp; entryList = countToEntryList[minCount]; entryList.emplace_front(key, value); keyToIter[key] = entryList.begin(), keyToCount[key] = minCount; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://ghostlo.github.io/categories/算法/"}],"tags":[{"name":"lru","slug":"lru","permalink":"https://ghostlo.github.io/tags/lru/"},{"name":"lfu","slug":"lfu","permalink":"https://ghostlo.github.io/tags/lfu/"}]},{"title":"字节跳动 面试","slug":"suanfa","date":"2019-04-14T14:00:17.000Z","updated":"2019-04-14T14:27:14.000Z","comments":true,"path":"2019/04/14/suanfa/","link":"","permalink":"https://ghostlo.github.io/2019/04/14/suanfa/","excerpt":"","text":"后端1给一个数组，定义X为某个区间的最小值乘上这个区间内所有元素的和，求最大的X。如数组为3 1 6 4 5，则最大的X=4*（6+4+5）=60三次握手，TCP连接的本质同步IO和异步IO进程和线程的区别，创建线程和进程的开销指什么死锁及如何避免什么是面向对象C++多态和实现方法设计题：设计一个购物车，给出应该有哪些数据表，每个表包含哪些字段求数组的中位数。数组由一个升序数组翻转形成，如1 2 3 4 5 6 7可以从5处翻转，形成5 6 7 1 2 3 4，求5 6 7 1 2 3 4的中位数。要求时间复杂度低于O(n)。InnoDB的索引类型B树和B+树的区别事务的四个隔离级别拥塞控制及对应方法的使用场景session和cookie的区别设计题：设计一个任务定时器，给定时间和任务，到时间了自动执行对应的任务。堆里面如何控制并发安全 死锁 内存溢出设计线程安全类流程：1、找出构成对象状态的所有变量。2、找出约束状态变量的不变性条件。3、建立对象状态的并发访问管理策略。定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性，线程封闭，与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁保护。 一个单链表，奇数位置升序，偶数位置降序，将这个链表调整为整体升序，写出代码。 2找一个无序数组的中位数写了个快排，然后让我找到无序数组第k大的一个数，我说先排序再找，实际上可以用快排的partition函数。快排的时间复杂度，最坏情况呢，最好情况呢，堆排序的时间复杂度呢，建堆的复杂度是多少，nlgn。说说Linux的磁盘管理，一脸懵逼Linux有哪些进程通信方式，五大件Linux的共享内存如何实现，大概说了一下。共享内存实现的具体步骤，我说没用过socket网络编程，说一下TCP的三次握手和四次挥手，中间网络不好，面试官都没听清楚，很尴尬跳过网络，问了项目的一些东西问我如何把docker讲的很清楚，我从物理机，虚拟机到容器具体实现稍微说了下。问我cgroup在linux的具体实现，不会。多线程用过哪些 Java的集合类哪些是线程安全分别说说这些集合类，hashmap怎么实现的MySQL索引的实现，innodb的索引，b+树索引是怎么实现的，为什么用b+树做索引节点，一个节点存了多少数据，怎么规定大小，与磁盘页对应。MySQL的事务隔离级别，分别解决什么问题。Redis了解么，如果Redis有1亿个key，使用keys命令是否会影响线上服务，我说会，因为是单线程模型，可以部署多个节点。问我知不知道有一条命令可以实现上面这个功能Redis的持久化方式，aod和rdb，具体怎么实现，追加日志和备份文件，底层实现原理的话知道么，不清楚。Redis的list是怎么实现的，我说用ziplist+quicklist实现的，ziplist压缩空间，quicklist实现链表。sortedset怎么实现的，使用dict+skiplist实现的，问我skiplist的数据结构，大概说了下是个实现简单的快速查询结构。了解什么消息队列，rmq和kafka写一个层序遍历。写一个插入树节点到一颗排序树的插入方法，使用递归方式找到插入位置即可。一个有向图用邻接矩阵表示，并且是有权图，现在问怎么判断图中有没有环。 拓扑图一个二叉树，找到二叉树中最长的一条路径。 操作系统的进程通信方式，僵尸进程和孤儿进程是什么，如何避免僵尸进程那父进程怎么知道子进程结束了计算机网络TCP和UDP有什么区别，为什么迅雷下载是基于UDP的，我说FTP是基于TCP，而迅雷是p2p不需要TCP那么可靠的传输保证。他说不对，我说是不是因为要建立连接，开销比较大，他说不对我说p2p的发送节点很多，所以不是那么需要各种传输保证，他说不对。我说TCP会自动分包而TCP可以自己定义数据长度。。他还是说不对。是NAT穿透问题吧，P2P网络使用UDP打洞穿透NAT，虽然现在也能用TCP打洞没用拥塞控制，下的快吧。可能尽可能的利用带宽操作系统的死锁必要条件，如何避免死锁。写一个LRU的缓存，需要完成超时淘汰和LRU淘汰。 算法岗Q：Batch Normalization是什么意思 Q：简单说一下LDA的思想 Q：T-SNE算法呢 Q：写一下相对熵的公式 A: $P{ij}log\\frac{q{ij}}{p_{ij}}$ Q：有两个字符串，你只可以进行删除操作，问你最少进行多少次操作可以使两个字符串相等。例:sea,eat需要两次删除操作 A：这个简单，思路就是用动态规划求两个字符串的最大公共字串的长度。然后使用每一个字符串的长度减去公共子字符串的长度。 Q：那咱们再加一点，如果我想要知道每个字符串需要删除的字符是那些呢， A：那我们就需要求出最大公共字串具体是由什么字符构成的，思路也是动态规划。(很快就写完了) Q：给你一个二叉查找树，还有一个数K。如果能找到，就返回节点，如果找不到，就返回空 Q：你是用递归的形式实现的，那么和非递归，递归怎么样? Q：那递归有什么缺点 A:当递归层数很多的时候，容易造成内存溢出 Q：你刚刚说了鞍点，你知道鞍点的定义么，鞍点有什么特点？ Q：好的，下面我们来一个开放式的问题:现在有一组数，其中有m对数是两两有序的，请你设计一种算法来对这一组数排序。 Q：有M个有序链表（从大到小）。现在我们要取出前K大的元素。 Q：好的，那我们先来问一点C语言的。C语言中结构体struct{int i; bool b}一共占几个字节 A：如果int类型占4个字节的话，那么这个结构体一共需要8个字节。 Q：好的，那offset(b)在结构体中偏移几个字节 A：4个字节 Q：那么你会计算结构体中每个变量相对于结构体偏移几个字节么。 A：这个不太会 Q：好的。那么union了解么 A：了解，和struct类似，但是是共享内存。 Q：OK，那问一道概率方面的题把,几何分布知道什么意思么 A：听名字有点忘了，但是概念还记得 Q：那伯努利分布知道么 A：嗯，了解 Q：现在我有抛一枚硬币，正面朝上的概率是p,反面是1-p。那么第k次抛的时候出现第一次正面的概率是多少? A: $P(1-p)^{k-1}$ Q：好的，那么我们设 $f(z=k)=p(1-p)^{k-1}$，那你计算一下 $E(z)$ （求个均值） A：(想了一会) $E(z)=p+2p(1-p)+3p(1-p)^{2}+…+mp(1-p)^{m-1}$ Q：能不能计算一下 $E(z)$的数学表达式 A：好的，思考了一会，可以使用 $E(z)-(1-p)E(z)=A$ 。其中A是一个等比数列。然后就可以求出 $E(z)$。 Q：ok,来做一道编程题把 A：好的 Q：我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。 A：好的，我想想(其实完全没思路，但是明显这种题有时间复杂度为O(1)的解)，说了几种想法，都被否了 Q：那你说一种时间复杂度为O(k)的算法也可以 A：（思索一会）O(k)的话就相当于我们将前k大个元素都求了出来。（然后开始写代码） 5分钟过去了，写好了","categories":[{"name":"面试","slug":"面试","permalink":"https://ghostlo.github.io/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://ghostlo.github.io/tags/面试/"},{"name":"字节跳动","slug":"字节跳动","permalink":"https://ghostlo.github.io/tags/字节跳动/"}]},{"title":"守护进程","slug":"守护进程","date":"2019-04-08T08:16:36.000Z","updated":"2019-04-08T08:19:50.000Z","comments":true,"path":"2019/04/08/守护进程/","link":"","permalink":"https://ghostlo.github.io/2019/04/08/守护进程/","excerpt":"","text":"什么是守护进程？守护进程也称精灵进程（Daemon），是一种运行在后台的一种特殊的进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。由于在Linux中，每个系统与用户进行交流的界面成为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，当控制终端被关闭的时候，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。它从被执行的时候开始运转，知道整个系统关闭才退出（当然可以人为的杀死相应的守护进程，例：kill -9 +守护进程ID）。如果想让某个进程不因为用户或中断或其他变化而影响，那么就必须把这个进程变成一个守护进程。 怎样查看哪些进程属于守护进程？我们可以使用ps axj命令查看系统中的进程，参数a表示不仅列出当前用户的进程,也列出所有其他用户的进程,参数x表示不仅列出有控制终端的进程,也列出所有无控制终端的进程,参数j表示列出与作业控制相关的信息。凡是在TPGID一栏写着 -1 的都是没有控制终端的进程,也就是守护进程。在COMMAND⼀一列用[]括起来的名字表示内核线程,这些线程在内核里创建,没有用户空间代码,因此没有程序文件名和命令行, 通常采用以k开头的名字,表示Kernel。udevd负责维护/dev目录下的设备文件,acpid负责电源管理,syslogd负责维护/var/log下的日志⽂文件,可以看出,守护进程通 常采用以d结尾的名字,表示Daemon。如何创建一个守护进程？ 方法一：守护进程实现的步骤： 重设文件权限掩码：文件权限掩码是屏蔽掉文件权限中的对应位。由于使用fork（）函数新创建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带了很多的麻烦（比如父进程中的文件没有执行文件的权限，然而在子进程中希望执行相应的文件这个时候就会出问题）。因此在子进程中要把文件的权限掩码设置成为0，即在此时有最大的权限，这样可以大大增强该守护进程的灵活性。设置的方法是：umask（0）。 创建子进程，父进程退出（使子进程成为孤儿进程）：这是编写守护进程的第一步，由于守护进程是脱离终端的，因此完成第一步后就会在shell终端里造成一个程序已经运行完毕的假象。之后的所有工作在子进程中完成，而用户在shell终端里则可以执行其他命令，从而在形式上做到了与控制终端脱离。实现的语句如下：if(fork()&gt;0){exit(0);}是父进程结束，然后子进程继续执行。 在子进程中创建新的会话（脱离控制终端）：这步是创建守护进程中最重要的一步，虽然实现起来很简单，但是它的意义非常重要，在这里使用的是系统函数setsid（）来创建一个新的会话，并且担任该会话组的组长。在这里有两个概念需要解释一下，进程组合会话期。 进程组：是一个或多个进程的集合。进程组有进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且该进程组ID不会因组长进程的退出而受到影响。 会话周期：会话期是一个或者多个进程的集合。通常一个会话开始于用户的登录，终止于用户的退出，在此期间该用户运行的所有进程都属于这个会话期。 setsid（）函数的作用：创建一个新的会话，并且担任该会话组的组长。具体作用包括：让一个进程摆脱原会话的控制，让进程摆脱原进程的控制，让进程摆脱原控制终端的控制。 创建守护进程要调用setsid（）函数的原因：由于创建守护进程的第一步是调用fork（）函数来创建子进程，再将父进程退出。由于在调用了fork（）函数的时候，子进程拷贝了父进程的会话期、进程组、控制终端等资源、虽然父进程退出了，但是会话期、进程组、控制终端等并没有改变，因此，需要用setsid（）韩式来时该子进程完全独立出来，从而摆脱其他进程的控制。 改变当前目录为根目录：使用fork（）创建的子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。因此通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其他的别的目录来作为守护进程的工作目录。 关闭不再需要的文件描述符：同文件权限码一样，用fork（）函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些文件被打开的文件可能永远不会被守护进程读写，如果不进行关闭的话将会浪费系统的资源，造成进程所在的文件系统无法卸下以及引起预料的错误。按照如下方法关闭它们： for(i=0;i 关闭打开的文件描述符close(i); 守护进程的退出：上面建立了守护进程，当用户需要外部停止守护进程运行时，往往需要使用kill命令来停止该守护进程，所以守护进程中需要编码来实现kill发出的signal信号处理，达到进程的正常退出。实现该过程的函数是signal函数： signal(SIGCHLD,SIG_IGN); 实现代码： 123456789101112131415161718192021222324252627282930#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;void mydaemon()&#123; umask(0);//1 if(fork()&gt;0)&#123;//father 2 exit(0); &#125; setsid();//3 chdir(&quot;/&quot;);//4 close(0);//5 close(1); close(2); signal(SIGCHLD,SIG_IGN);//6&#125;int main()&#123; mydaemon(); while(1) &#123; sleep(1); &#125; return 0;&#125; 存在一个名为mydaemon的守护进程。 方法二：直接调用daemon函数。 daemon函数的作用：将此进程精灵化。 int daemon(int nochair,int noclose); nochdir：这个值为0的话，表示将当前进程的工作目录设值为”/”目录。noclose:这个值 为0的话表示将所有的文件描述符都写入”/dev/null”中。”/dev/null”表示黑洞，写入里面的所有信息都被内核丢弃。 1234567891011#include&lt;unistd.h&gt;int main()&#123; daemon(0,0); while(1) &#123; sleep(1); &#125; return 0;&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://ghostlo.github.io/categories/操作系统/"}],"tags":[{"name":"守护进程","slug":"守护进程","permalink":"https://ghostlo.github.io/tags/守护进程/"}]},{"title":"C++指针","slug":"C指针","date":"2019-04-07T06:40:56.000Z","updated":"2019-04-27T03:11:45.000Z","comments":true,"path":"2019/04/07/C指针/","link":"","permalink":"https://ghostlo.github.io/2019/04/07/C指针/","excerpt":"","text":"指针的概念指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。先声明几个指针放着做例子：例一： 12345int *ptr; char *ptr; int **ptr; int (*ptr)[3]; int *(*ptr)[4]; 指针的类型从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型： 12345int *ptr; //指针的类型是int * char *ptr; //指针的类型是char * int **ptr; //指针的类型是 int ** int (*ptr)[3]; //指针的类型是 int(*)[3] int *(*ptr)[4]; //指针的类型是 int *(*)[4] 怎么样？找出指针的类型的方法是不是很简单？ 指针所指向的类型当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如： 12345int *ptr; //指针所指向的类型是int char *ptr; //指针所指向的的类型是char int **ptr; //指针所指向的的类型是 int * int (*ptr)[3]; //指针所指向的的类型是 int()[3] int *(*ptr)[4]; //指针所指向的的类型是 int *()[4] 在指针的算术运算中，指针所指向的类型有很大的作用。指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。 指针的值指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？ 指针本身所占据的内存区指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int a[100];int main()&#123; char* t[] = &#123;\"p3423d\",\"wewr\",\"234\"&#125;; char* p=\"ewer\"; int b[100]; int* B=new int[10]; cout&lt;&lt;\"t \"&lt;&lt;sizeof(t)&lt;&lt;endl; cout&lt;&lt;\"p \"&lt;&lt;sizeof(p)&lt;&lt;endl; cout&lt;&lt;\"*t \"&lt;&lt;sizeof(*t)&lt;&lt;endl; cout&lt;&lt;\"*p \"&lt;&lt;sizeof(*p)&lt;&lt;endl; cout&lt;&lt;\"B \"&lt;&lt;sizeof(B)&lt;&lt;endl; cout&lt;&lt;\"*B \"&lt;&lt;sizeof(*B)&lt;&lt;endl; cout&lt;&lt;\"a \"&lt;&lt;sizeof(a)&lt;&lt;\" b \"&lt;&lt;sizeof(b)&lt;&lt;endl; char k[]=\"abcdef\"; cout&lt;&lt;dec&lt;&lt;(unsigned int)k[3]&lt;&lt;\" \"&lt;&lt;sizeof(k)&lt;&lt;endl; string s=\"abcdef\"; cout&lt;&lt;dec&lt;&lt;(unsigned int)s[6]&lt;&lt;\" \"&lt;&lt;sizeof(s)&lt;&lt;endl; k[3]='\\0'; cout&lt;&lt;k&lt;&lt;endl; s[6]='g'; cout&lt;&lt;s&lt;&lt;endl; int a1=0; cout&lt;&lt;sizeof(a1=3)&lt;&lt;endl; cout&lt;&lt;a1&lt;&lt;endl; return 0;&#125;t 24 一个指针8 3个就是24p 8 *t 8 指向了一个数组，还是个指针，如果是*t[1] 就是1*p 1 一个char是1B 8 指针*B 4 inta 400 b 400 数组100 7 0 24 string的sizeof在不同编译器中不一样，但char是可以的，strlen区别abcabcdef40 指针的算术运算指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：例二： 12345 char a[20]; int *ptr=a; ... ... ptr++; 在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：例三： 12345678910int array[20]; int *ptr=array; ... //此处略去为整型数组赋值的代码。 ... for(i=0;i&lt;20;i++) &#123; (*ptr)++; ptr++； &#125; 这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。再看例子：例四： 12345char a[20]; int *ptr = a; ... ... ptr += 5; 在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。 运算符&amp;和*这里&amp;是取地址运算符， 是…书上叫做“间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个 ，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。p的运算结果就五花八门了。总之p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。例五： 123456789int a=12; int b; int *p; int **ptr; p=&amp;a;//&amp;a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。 *p=24;//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。ptr=&amp;p;//&amp;p的结果是个指针，该指针的类型是p的类型加个*，在这里是int**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。 *ptr=&amp;b;//*ptr是个指针，&amp;b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以?amp;b来给*ptr赋值就是毫无问题的了。**ptr=34;//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。 指针表达式一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子：例六： 12345678int a,b; int array[10]; int *pa; pa=&amp;a;//&amp;a是一个指针表达式。 int **ptr=&amp;pa;//&amp;pa也是一个指针表达式。 *ptr=&amp;b;//*ptr和&amp;b都是指针表达式。 pa=array; pa++;//这也是指针表达式。 例七： 123456char *arr[20]; char **parr=arr;//如果把arr看作指针的话，arr也是指针表达式 char *str; str=*parr;//*parr是指针表达式 str=*(parr+1);//*(parr+1)是指针表达式 str=*(parr+2);//*(parr+2)是指针表达式 由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。 在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。ptr是一个左值，因为ptr这个指针已经占据了内存，其实ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么ptr当然也有了自己的位置。 数组和指针的关系数组的数组名其实可以看作一个指针。看下例：例八： 123456int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value; ... ... value=array[0];//也可写成：value=*array; value=array[3];//也可写成：value=*(array+3); value=array[4];//也可写成：value=*(array+4); 上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int ，所指向的类型是数组单元的类型即int。因此array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。例九： 123456789char *str[3]=&#123; &quot;Hello,this is a sample!&quot;, &quot;Hi,good morning.&quot;, &quot;Hello world&quot; &#125;; char s[80]； strcpy(s,str[0]);//也可写成strcpy(s,*str); strcpy(s,str[1]);//也可写成strcpy(s,*(str+1)); strcpy(s,str[2]);//也可写成strcpy(s,*(str+2)); 上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char，它指向的类型是char 。 str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地址是字符串”Hello,this is a sample!”的第一个字符的地址，即’H’的地址。 str+1也是一个指针，它指向数组的第1号单元，它的类型是char，它指向的类型是char 。 (str+1)也是一个指针，它的类型是char，它所指向的类型是char，它指向”Hi,good morning.”的第一个字符’H’，等等。下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。在不同的表达式中数组名array可以扮演不同的角色。在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。在表达式array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(array)测出的是数组单元的大小。表达式array+n（其中n=0，1，2，….。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE*，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。例十： 123int array[10]; int (*ptr)[10]; ptr=&amp;array; 上例中ptr是一个指针，它的类型是int (*)[10]，他指向的类型是int [10]，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array代表数组本身。本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如： 1int (*ptr)[10]; 则在32位程序中，有： 123sizeof(int(*)[10])==4 sizeof(int [10])==40 sizeof(ptr)==4 实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。 指针和结构类型的关系可以声明一个指向结构类型对象的指针。例十一： 12345678910struct MyStruct &#123; int a; int b; int c; &#125; MyStruct ss=&#123;20,30,40&#125;;//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。MyStruct *ptr=&amp;ss;//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。int *pstr=(int*)&amp;ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。 请问怎样通过指针ptr来访问ss的三个成员变量？答案： 123ptr-&gt;a; ptr-&gt;b; ptr-&gt;c; 又请问怎样通过指针pstr来访问ss的三个成员变量？答案： 123*pstr；//访问了ss的成员a。 *(pstr+1);//访问了ss的成员b。 *(pstr+2)//访问了ss的成员c。 呵呵，虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元：例十二： 12int array[3]=&#123;35,56,37&#125;; int *pa=array; 通过指针pa访问数组array的三个单元的方法是： 123*pa;//访问了第0号单元 *(pa+1);//访问了第1号单元 *(pa+2);//访问了第2号单元 从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个“填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。所以，在例十二中，即使pstr访问到了结构对象ss的第一个成员变量a，也不能保证(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。通过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。 指针和函数的关系可以把一个指针声明成为一个指向函数的指针。 123456int fun1(char*,int); int (*pfun1)(char*,int); pfun1=fun1; .... .... int a=(*pfun1)(\"abcdefg\",7);//通过函数指针调用函数。 可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。 THANKS 虚函数表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//// main.cpp// nothings//// Created by time on 19/4/13.// Copyright © 2019年 ghostlo. All rights reserved.//#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;class Base&#123;public: virtual void func1() &#123; cout &lt;&lt; \"Base::func1\" &lt;&lt; endl; &#125; virtual void func2() &#123; cout &lt;&lt; \"Base::func2\" &lt;&lt; endl; &#125; virtual void func3() &#123; cout &lt;&lt; \"Base::func3\" &lt;&lt; endl; &#125; virtual void func4() &#123; cout &lt;&lt; \"Base::func4\" &lt;&lt; endl; &#125;private: int a;&#125;;class Derive :public Base&#123;public: virtual void func1() &#123; cout &lt;&lt; \"Derive::func1\" &lt;&lt; endl; &#125; virtual void func3() &#123; cout &lt;&lt; \"Derive::func3\" &lt;&lt; endl; &#125; virtual void func4() &#123; cout &lt;&lt; \"Derive::func4\" &lt;&lt; endl; &#125; virtual void func5() &#123; cout &lt;&lt; \"Derive::func5\" &lt;&lt; endl; &#125;private: int b;&#125;;typedef void(*FUNC)(void);void PrintVTable(long long* VTable)&#123; cout &lt;&lt; \" 虚表地址\" &lt;&lt; VTable &lt;&lt; endl; for (int i = 0; i&lt;5; ++i)//比较好的写法是这样 //for (int i = 0; VTable[i]!=0x7fff754dbbb8&amp;&amp;VTable[i]!=0x0; ++i) &#123; printf(\" 第%d个虚函数地址 :0x%llx,-&gt;\", i, VTable[i]); FUNC f = (FUNC)VTable[i]; f(); cout&lt;&lt;hex&lt;&lt;VTable[i]&lt;&lt;endl; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int a=3; cout&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;sizeof(&amp;a)&lt;&lt;endl; Derive d1; PrintVTable((long long*)(*(long long*)(&amp;d1))); return 0;&#125;/*0x7fff5fbff798//64位的指针，使用后48位，前16位自动补0或者18 虚表地址0x1000020f0 第0个虚函数地址 :0x100000fe0,-&gt;Derive::func1100000fe0 第1个虚函数地址 :0x100001030,-&gt;Base::func2100001030 第2个虚函数地址 :0x100001080,-&gt;Derive::func3100001080 第3个虚函数地址 :0x1000010d0,-&gt;Derive::func41000010d0 第4个虚函数地址 :0x100001120,-&gt;Derive::func5100001120*/ 最后的地址在clang中是0x7fff754dbbb8别问我问什么，我也在想 在C++中，多态性是通过虚函数实现的，而虚函数的实现依靠虚函数表的存在。实现多态性的基本操作是将基类的对象指针指向子类对象， 通过子类对象调用函数。虚函数表中存放着重写后的虚函数。虚函数表如同一个地图，指明了实际所应该调用的函数。 C++中有规定，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（为了保证正确取到虚函数的偏移量）。 这意味着我们 通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 为了打印出这张虚函数表，我们把内存中的虚函数表看做一个整型数组，数组元素就是虚函数，为了取出虚函数的地址进行强制类型转换。","categories":[{"name":"C++","slug":"C","permalink":"https://ghostlo.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ghostlo.github.io/tags/C/"},{"name":"指针","slug":"指针","permalink":"https://ghostlo.github.io/tags/指针/"}]},{"title":"敏捷开发","slug":"敏捷开发","date":"2019-04-07T02:51:02.000Z","updated":"2019-04-07T02:56:31.000Z","comments":true,"path":"2019/04/07/敏捷开发/","link":"","permalink":"https://ghostlo.github.io/2019/04/07/敏捷开发/","excerpt":"","text":"迭代开发敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。 那么什么是”迭代开发”呢？迭代的英文是 iterative，直译为”重复”，迭代开发其实就是”重复开发”。 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。 增量开发迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用”增量开发”（incremental development）划分迭代。 所谓”增量开发”，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶…… 增量开发加上迭代开发，才算真正的敏捷开发。 敏捷开发的好处早期交付敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的”瀑布开发模式”，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。 降低风险敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？ 对于软件项目来说，先有一个原型产品，了解市场的接受程度，往往是项目成功的关键。有一本书叫做《梦断代码》，副标题就是”20+个程序员，三年时间，4732个bug，100+万美元，最后失败的故事”，这就是没有采用敏捷开发的结果。相反的，Instagram 最初是一个地理位置打卡 App，后来发现用户不怎么在乎地理位置，更喜欢上传照片，就改做照片上传软件，结果成了独角兽。 由于敏捷开发可以不断试错，找出对业务最重要的功能，然后通过迭代，调整软件方向。相比传统方式，大大增加了产品成功的可能性。如果市场需求不确定，或者你对该领域不熟悉，那么敏捷开发几乎是唯一可行的应对方式。 如何进行每一次迭代虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。 具体来说，每次迭代都必须依次完成以下五个步骤。 需求分析（requirements analysis） 设计（design） 编码（coding） 测试（testing） 部署和评估（deployment / evaluation） 每个迭代大约持续2~6周。 敏捷开发的价值观《敏捷软件开发宣言》里面提到四个价值观。 程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。 软件能够运行，优于详尽的文档。 跟客户的密切协作，优于合同和谈判。 能够响应变化，优于遵循计划。 十二条原则该宣言还提出十二条敏捷开发的原则。 通过早期和持续交付有价值的软件，实现客户满意度。 欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。 不断交付可用的软件，周期通常是几周，越短越好。 项目过程中，业务人员与开发人员必须在一起工作。 项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。 面对面交谈是最好的沟通方式。 可用性是衡量进度的主要指标。 提倡可持续的开发，保持稳定的进展速度。 不断关注技术是否优秀，设计是否良好。 简单性至关重要，尽最大可能减少不必要的工作。 最好的架构、要求和设计，来自团队内部自发的认识。 团队要定期反思如何更有效，并相应地进行调整。 来源：阮一峰","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://ghostlo.github.io/categories/软件工程/"}],"tags":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"https://ghostlo.github.io/tags/敏捷开发/"}]},{"title":"mysql-面试","slug":"mysql","date":"2019-04-06T14:19:09.000Z","updated":"2019-04-08T11:47:26.000Z","comments":true,"path":"2019/04/06/mysql/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/mysql/","excerpt":"","text":"Mysql中有哪几种锁？ 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 Mysql中有哪些不同的表格？共有5种类型的表格： MyISAM Heap Merge INNODB ISAM 另 简述在MySQL数据库中MyISAM和InnoDB的区别MyISAM： 不支持事务，但是每次查询都是原子的；支持表级锁，即每次操作是对整个表加锁；存储表的总行数； 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件； MyIASM基于了IASM代码，应该可以说是IASM的衍生品，不过增加了不少有用的扩展。它是MySQL的默认数据表类型，基于了传统的ISAM类型，ISAM是Indexed Sequential Access Method（有索引的顺序访问方法）的缩写，一般来说，它是存储记录和文件的标准方法。与其他存储引擎比较，MyISAM具有检查和修复表格的大多数工具。ISAM表格可以被压缩，而且它们支持全文搜索，不过它们是事务不安全的，而且也不支持外键。如果事务回滚将会造成不完全回滚，从而不具备原子性。所以假如忽略事务以及访问并发性的话，并且需要执行大量的SELECT检索语句的话，MyISAM将是最好的选择。 MyISAM表(TYPE=MYISAM)是ISAM类型的一种延伸，具有很多优化和增强的特性。 是MySQL的默认表类型。 MyISAM优化了压缩比例和速度，并且可以很方便的在不同的操作系统和平台之间进行移植。 MyISAM支持大表文件(大于4G) 允许对BLOB和TEXT列进行索引 支持使用键前缀和使用完整的键搜索记录 表数据和表索引文件可以依存在不同的位置，甚至是不同的文件系统中。 即使是具有相当多的插入、更新和删除操作的表，智能防碎片逻辑也能保证其高性能的协作性。 InnoDb： InnoDB表(TYPE=INNODB)，是一个完全兼容ACID（事务的原子性、一致性、独立性及持久性）的、高效率的表完全支持MySQL的事务处理。精细的（行级和表级）锁提高了MySQL事务处理的带走度，同时其也支持无锁定读操作（以前只在Oracle中包含）和多版本的特性。 支持行级锁及外键约束：因此可以支持写并发 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制； 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。 异步输入/输出和一系列的读缓冲将提高数据检索速度，同时可以进行文件的优化和内存的管理。需要的基础上支持自动在内存上创建散列索引来提高性能，使用缓冲来提高可靠性和数据库操作的速度。InnoDB表可以和MyISAM相媲美，甚至已经超过了MyISAM。 在不同的操作系统和体系结构上是完全可移植的。由于一直处于一致的状态（MySQL通过在启动时检查错误并修复错误来使它们更加健壮）。对外键、提交、回滚和前滚的操作的支持，使其成为MySQL中最完善的表格式。 thanks Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？SQL标准定义的四个隔离级别为： read uncommited ：读到未提交数据 read committed：脏读，不可重复读 repeatable read：可重读 serializable ：串行事物 CHAR和VARCHAR的区别？1.CHAR和VARCHAR类型在存储和检索方面有所不同2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。 主键和候选键有什么区别？表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 myisamchk是用来做什么的？它用来压缩MyISAM表，这减少了磁盘或内存使用。 MyISAM Static和MyISAM Dynamic有什么区别？在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。 MyISAM Static在受损情况下更容易恢复。 如果一个表有一列定义为TIMESTAMP，将发生什么？每当行被更改时，时间戳字段将获取当前时间戳。 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。 怎样才能找出最后一次插入时分配了哪个自动增量？LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。 你怎么看到为表格定义的所有索引？索引是通过以下方式为表格定义的： SHOW INDEX FROM &lt; tablename &gt; ; LIKE声明中的％和_是什么意思？％对应于0个或更多字符，_只是LIKE语句中的一个字符。 如何在Unix和Mysql时间戳之间进行转换？UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令 列对比运算符是什么？在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。 mysql_fetch_array和mysql_fetch_object的区别是什么？以下是mysql_fetch_array和mysql_fetch_object的区别： mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。 mysql_fetch_object – 从数据库返回结果行作为对象。 MyISAM表格将在哪里存储，并且还提供其存储格式？每个MyISAM表格以三种格式存储在磁盘上： “.frm”文件存储表定义 数据文件具有“.MYD”（MYData）扩展名 索引文件具有“.MYI”（MYIndex）扩展名 Mysql如何优化DISTINCT？DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。 SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a; 如何显示前50行？在Mysql中，使用以下代码查询显示前50行： SELECT … FROM … LIMIT 0,50; 可以使用多少列创建索引？任何标准表最多可以创建16个索引列。 NOW（）和CURRENT_DATE（）有什么区别?NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 CURRENT_DATE（）仅显示当前年份，月份和日期。 什么是通用SQL函数？ CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。 FORMAT(X, D)- 格式化数字X到D有效数字。 CURRDATE(), CURRTIME()- 返回当前日期或时间。 NOW（） – 将当前日期和时间作为一个值返回。 MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。 HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。 DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄 SUBTIMES（A，B） – 确定两次之间的差异。 FROMDAYS（INT） – 将整数天数转换为日期值。 MYSQL支持事务吗？在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。 但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SETAUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。 mysql里记录货币用什么字段类型好NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。 例如： salary DECIMAL(9,2) 在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。 因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。 mysql有关权限的表都有哪几个？Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。 列的字符串类型可以是什么？字符串类型是： SET BLOB 大二进制文件 ENUM CHAR TEXT 字符串类型 字节 描述及存储需求 CHAR(M) M M为0~255之间的整数 VARCHAR(M) M为0~65536之间的整数 TINYBLOB 允许长度0~255字节 BLOB 允许长度0~65535字节 MEDUIMBLOB 允许长度0~167772150字节 LONGBLOB 允许长度0~4294967295 TINYTEXT 允许长度0~255字节 TEXT 允许长度0~65535字节 MEDIUMTEXT 允许长度0~167772150字节 LONGTEXT 允许长度0~4294967295字节 VARBINARY(M) M 允许长度0~M个字节的边长字节字符集 BINARY(M) M 允许长度0~M个字节的定长字节字符集 CHAR于VARCHAR类型 CHAR和VARCHAR很类似，都是用来保存Mysql中较短的字符串，主要区别在于:CHAR列的长度固定为创建表时声明的长度，长度可以为从0~255的任何值，而VARCHAR的值可以是变长字符串，长度可以指定0~65535之间的值，在检索的时候，CHAR列会删除尾部的空格而VARCHAR则保留了这些空格。 ENUM类型 枚举类型，忽略大小写，它的值范围需要在创建表时通过枚举方式显示指定，对1~255个成员的枚举需要1个字节存储，对于255~65535个成员，需要2个字节存储，最多允许65535个成员。 SET类型 SET和enum非常相似，里面可以包含0~64个成员，根据成员的不用，存储上也有不同。 1~8成员的集合，占1个字节 9~16成员的集合，占2个字节 17~24成员的集合，占3个字节 25~32成员的集合，占4个字节 33~64成员的集合，占8个字节 set类型一次可以选取多个成员，而ENUM则只能选一个，就相当于ENUM是单选，而set是复选。 什么是非标准字符串类型？ TINYTEXT TEXT MEDIUMTEXT LONGTEXT BLOB和TEXT有什么区别？BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。 BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。 MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。c. mysql库主从读写分离。d. 找规律分表，减少单表中的数据量提高查询速度。e。添加缓存机制，比如memcached，apc等。f. 不经常改动的页面，生成静态页面。g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 锁的优化策略 读写分离 分段加锁 减少锁持有的时间 多个线程尽量以相同的顺序去获取资源 不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。 索引的底层实现原理和优化B+树，经过优化的B+树 主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。 什么情况下设置了索引但无法使用 以“%”开头的LIKE语句，模糊匹配 OR语句前后没有同时使用索引 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型） 实践中如何优化MySQL最好是按照以下顺序优化： SQL语句及索引的优化 数据库表结构的优化 系统配置的优化 硬件的优化 详细可以查看 阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结 优化数据库的方法 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM 使用连接(JOIN)来代替子查询 适用联合(UNION)来代替手动创建的临时表 事务处理 锁定表、优化事务处理 适用外键，优化锁定表 建立索引 优化查询语句 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。 普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。 主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。 索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。 数据库中的事务是什么?事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。 事务特性：（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。 （2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态 （3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， （4）持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 或者这样理解： 事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 SQL注入漏洞产生的原因？如何防止？SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。 防止SQL注入的方式：开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置 执行sql语句时使用addslashes进行sql语句转换 Sql语句书写尽量不要省略双引号和单引号。 过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。 提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。 为表中得字段选择合适得数据类型字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型 存储时期Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，占用8个字节得存储空间，datatime类型与时区无关Timestamp:以时间戳格式存储，占用4个字节，范围小1970-1-1到2038-1-19，显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改timestamp列得值Date:（生日）占用得字节数比使用字符串.储存要少，使用date只需要3个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算Time:存储时间部分得数据注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，在进行查找过滤可以利用日期得函数）使用int存储日期时间不如使用timestamp类型 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题： 索引的目的是什么？ 快速访问数据表中的特定信息，提高检索速度创建唯一性索引，保证数据库表中每一行数据的唯一性。加速表和表之间的连接 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 索引对数据库系统的负面影响是什么？ 负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。 为数据表建立索引的原则有哪些？ 在最频繁使用的、用以缩小查询范围的字段上建立索引。 在频繁使用的、需要排序的字段上建立索引 什么情况下不宜建立索引？ 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。 对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等 解释MySQL外连接、内连接与自连接的区别先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。 内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。 左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。 Myql中的事务回滚机制概述事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。 要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚 SQL语言包括哪几部分？每部分都有哪些操作关键字？SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。 数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等 数据操纵：Select ,insert,update,delete, 数据控制：grant,revoke 数据查询：select 完整性约束包括哪些？数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类：1) 实体完整性：规定表的每一行在表中是惟一的实体。 2) 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 3) 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 4) 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 什么是锁？数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。 基本锁类型锁包括行级锁、表级锁、页面锁（见开头） 什么叫视图？游标是什么？视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改影响基本表。它使得我们获取数据更容易，相比多表查询。另不能在一张由多张关联表连接而成的视图上做同时修改两张表的操作；视图与表是一对一关系时如果没有其它约束（如视图中没有的字段，在基本表中是必填字段情况），是可以进行增删改数据操作；修改操作时要小心，不经意间你已经修改了基本表里的多条数据，对视图的创建与删除不影响基本表。 1234567891011121314151617181920DROP VIEWIF EXISTS `view_user_course`;CREATE ALGORITHM = UNDEFINED DEFINER = `root`@`localhost` SQL SECURITY DEFINER VIEW `view_user_course` AS ( SELECT `uc`.`id` AS `id`, `u`.`name` AS `username`, `c`.`name` AS `coursename` FROM ( ( `user` `u` LEFT JOIN `user_course` `uc` ON ((`u`.`id` = `uc`.`userid`)) ) LEFT JOIN `course` `c` ON ((`uc`.`courseid` = `c`.`id`)) )); 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 需要强调的是，游标必须在定义处理程序之前被定义，但变量必须在定义游标之前被定义，顺序就是变量定义-游标定义-处理程序。 定义游标：DECLARE cursor_name CURSOR FOR select_statement 这个语句声明一个游标。也可以在子程序中定义多个游标，一个块中的每一个游标必须命名唯一。声明游标后也是单条操作的。 游标OPEN：OPEN cursor_name 这个语句打开先前声明的游标。 游标FETCH：FETCH cursor_name INTO var_name [, var_name] … 这个语句用指定的打开游标读取下一行（如果有下一行的话），并且前进游标指针至该行。 游标CLOSE：CLOSE cursor_name 这个语句关闭先前打开的游标，注意，用完后必须关闭。 什么是存储过程？用什么来调用？答：存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。 如何通俗地理解三个范式？第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性,为实现区分通常需要我们设计一个主键来实现第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。很多时候，我们为了满足第三范式往往会把一张表分成多张表。 范式化设计优缺点:优点:可以尽量得减少数据冗余，使得更新快，体积小缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化反范式化:优点:可以减少表得关联，可以更好得进行索引优化缺点:数据冗余以及数据异常，数据得修改需要更多的成本 什么是基本表？什么是视图？基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表 试述视图的优点？ 视图能够简化用户的操作。 视图使用户能以多种角度看待同一数据。 视图对重构数据库提供了一定程度的逻辑独立性。 视图能够对机密数据提供安全保护。 适当利用视图可以更清晰的表达查询。 NULL是什么意思NULL这个值表示UNKNOWN(未知):它不表示 “ “ (空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。 使用IS NULL来进行NULL判断 主键、外键和索引的区别？定义：主键–唯一标识一条记录，不能有重复的，不允许为空 外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值 索引–该字段没有重复值，但可以有一个空值 作用：主键–用来保证数据完整性 外键–用来和其他表建立联系用的 索引–是提高查询排序的速度 个数：主键–主键只能有一个 外键–一个表可以有多个外键 索引–一个表可以有多个唯一索引 你可以用什么来确保表格里的字段只接受特定范围里的值?答：Check限制，它在数据库表格里被定义，用来限制输入该列的值。 触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。 说说对SQL语句优化有哪些方法？（选择几条）（1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。 （2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。 （3）避免在索引列上使用计算 （4）避免在索引列上使用IS NULL和IS NOT NULL （5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 （6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 （7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描 on与wheresql连接方式为嵌套循环连接。一层一层的连接，循环用外层结果集的记录行和内层的所有符合条件ON条件的记录依次连接，内层没有符合条件的生成所有字段为null的记录行，当不存在ON条件是以“笛卡尔积”的形式连接。连接过后where过滤，再连接，在过滤，直到左右表均连接完毕。连接完毕后有group by字句则执行分组，有having字句的则对分组后的结果集再过滤，所以having执行在where之后，因此有些条件放where字句内能缩小分组前的结果集，提高执行效率。之后还有order by字句的则执行排序，最后得到查询的结果。 where里可能有关于每张表的筛选条件，不同表的条件生效时期不同。对于驱动表，在执行一开始就会通过where上关于词表的条件筛选一条或者一批记录，然后通过on条件关联下一张表，将得到的结果集再用where上第二张表的条件做过滤，然后重复此过程直到所有表关联完毕。也就是对于驱动表，因为只有where生效，对于其他被驱动表，先被on关联，也就是on先生效，然后再用where过滤关联的结果集。同时对于外表连接，比如left join和right join，把条件放在on上，如果被关联表没有匹配上，那么外表还是能放入结果集的；而如果将条件放在where上，因为where是对关联后的结果做过滤，此时之前匹配的记录也会被筛选掉。thanks sql and nosqlSQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL，PostgreSQL。 NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB，Redis，CouchDB。 sql优点 事务处理—保持数据的一致性 由于以标准化为前提，数据更新的开销很小（相同的字段基本上只有一处） 可以进行Join等复杂查询 sql缺点 扩展困难：由于存在类似Join这样多表查询机制，使得数据库在扩展方面很艰难; 读写慢：这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重 成本高：企业级数据库的License价格很惊人，并且随着系统的规模，而不断上升 nosql优点 Nosql的存储方式灵活，NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。 简单的扩展：典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群 快速的读写：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作 低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本 thanks","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ghostlo.github.io/categories/数据库/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://ghostlo.github.io/tags/面试/"},{"name":"mysql","slug":"mysql","permalink":"https://ghostlo.github.io/tags/mysql/"}]},{"title":"并发","slug":"并发","date":"2019-04-06T13:47:29.000Z","updated":"2019-04-08T13:33:51.000Z","comments":true,"path":"2019/04/06/并发/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/并发/","excerpt":"","text":"什么是并发： 并发是指多个执行任务同时、在一个较长的时间段内可认为是并行被执行。什么是并行： 并行就是指多个任务同时执行什么是竞态： 字面意思是竞争，并发的执行单元对共享资源（硬件资源和软件上的全局变量，静态变量等）的访问容易发生竞态。对于一个虚拟的字符设备驱动，假设一个执行单元A对其写入300个字符‘a’，而另一个执行单元B对其写入300个字符‘b’，第三个执行单元读取所有字符。如果A、B被顺序串行执行那么C读出的则不会出错，但如果A、B并发执行，那结果则是我们不可料想的。竞态发生的情况对称多处理器（SMP）的多个CPU： SMP是一种紧耦合、共享存储的系统模型，它的特点是多个CPU使用共同的系统总线，因此可以访问共同的外设和存储器。单CPU内进程与抢占它的进程： Linux 2.6的内核支持抢占调度，一个进程在内核执行的时候可能被另一高优先级进程打断。中断（硬中断、软中断、tasklet、低半部）与进程之间：中断可以打断正在执行的进程，处理中断的程序和被打断的进程间也可能发生竞态。竞态的解决办法解决竞态问题的途径是保证对共享资源的互斥访问。访问共享资源的代码区域称为临界区，临界区要互斥机制保护。Linux设备驱动中常见的互斥机制有以下方式：中断屏蔽、原子操作、自旋锁和信号量等。 临界区Most readers would agree that this scenario is best avoided.Therefore, the core rule that applies to spinlocks is that any codemust, while holding a spinlock, be atomic.It cannot sleep; in fact, itcannot relinquish the processor for any reason except toserviceinterrupts (and sometimes not even then). 互斥锁和自旋锁、信号量的区别互斥锁和互斥量 在我的理解里没啥区别，不同叫法。广义上讲可以值所有实现互斥作用的同步机制。狭义上讲指的就是mutex这种特定的二元锁机制。互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的 。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。 信号量（semaphore） 是一种更高级的同步机制，mutex（互斥锁） 可以说是 semaphore（信号量） 在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。 程序运行状态 开始 运行 就绪 阻塞 结束 互斥锁：常用，使用后需要的程序进入就绪态，通常情况下锁操作失败会将该线程睡眠等待锁释放时被唤醒，用于互斥，信号量用于同步 自旋锁：相比一般的互斥锁会在等待期间放弃cpu，使用硬件提供的swap指令或test_and_set指令实现，自旋锁则是不断循环并测试锁的状态，这样就一直占着cpu。所以相比于自旋锁和信号量，在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒休眠的线程。可以联想到程序查询中断方式。 递归锁：严格上讲递归锁只是互斥锁的一个特例，同样只能有一个线程访问该对象，但允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作，直到一个线程所有的acquire都被release，其他的线程才能获得资源。 windows下的临界区默认是支持递归锁的，而linux下的互斥量则需要设置参数PTHREAD_MUTEX_RECURSIVE_NP，默认则是不支持。 读写锁(rwlock)：高级别锁，区分读和写，符合条件时允许多个线程访问对象。处于读锁操作时可以允许其他线程和本线程的读锁， 但不允许写锁， 处于写锁时则任何锁操作都会睡眠等待；常见的操作系统会在写锁等待时屏蔽后续的读锁操作以防写锁被无限孤立而等待，在操作系统不支持情况下可以用引用计数加写优先等待来用互斥锁实现。 读写锁适用于大量读少量写的环境，但由于其特殊的逻辑使得其效率相对普通的互斥锁和自旋锁要慢一个数量级；值得注意的一点是按POSIX标准 在线程申请读锁并未释放前本线程申请写锁是成功的，但运行后的逻辑结果是无法预测 另外注意并发时候stl的改变","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://ghostlo.github.io/categories/操作系统/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://ghostlo.github.io/tags/并发/"}]},{"title":"数据库事务的四大特性以及事务的隔离级别","slug":"数据库事务的四大特性以及事务的隔离级别","date":"2019-04-06T08:38:07.000Z","updated":"2019-04-09T02:23:06.000Z","comments":true,"path":"2019/04/06/数据库事务的四大特性以及事务的隔离级别/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/数据库事务的四大特性以及事务的隔离级别/","excerpt":"","text":"数据库的四个特性如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性： 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。 持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题： 问题脏读 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下 123update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’; 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。 不可重复读 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了…… 虚读(幻读) 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 范式第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性,为实现区分通常需要我们设计一个主键来实现 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。很多时候，我们为了满足第三范式往往会把一张表分成多张表。 隔离级别现在来看看MySQL数据库为我们提供的四种隔离级别： Serializable (串行化)可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读)可避免脏读、不可重复读的发生。 Read committed (读已提交)可避免脏读的发生。 Read uncommitted (读未提交)最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。 在MySQL数据库中查看当前事务的隔离级别： 1select @@tx_isolation; 在MySQL数据库中设置事务的隔离 级别： 123set [glogal | session] transaction isolation level 隔离级别名称;set tx_isolation=’隔离级别名称;’ 例1：查看当前事务的隔离级别： 例2：将事务的隔离级别设置为Read uncommitted级别： 或： 记住：设置数据库的隔离级别一定要是在开启事务之前！ 如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段： 在JDBC中设置隔离级别的部分代码： 后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 参考博客： http://www.zhihu.com/question/23989904 http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html http://www.cnblogs.com/xdp-gacl/p/3984001.html 来源","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ghostlo.github.io/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ghostlo.github.io/tags/数据库/"},{"name":"mysql","slug":"mysql","permalink":"https://ghostlo.github.io/tags/mysql/"}]},{"title":"面试--抛棋子","slug":"面试-抛棋子","date":"2019-04-06T08:36:07.000Z","updated":"2019-04-14T13:51:21.000Z","comments":true,"path":"2019/04/06/面试-抛棋子/","link":"","permalink":"https://ghostlo.github.io/2019/04/06/面试-抛棋子/","excerpt":"","text":"问题有一个一百层高的大厦，从这个大厦的某一层扔下棋子恰好就会碎（称这一层为临界层）。请你用手中的两个玻璃围棋子，找出一个最优的策略来得出那个最优层。分析：题目要求策略最优，因而要使得在最坏的情况下投掷的总次数 $T_{max}​$ 最少。首先考虑只有一个棋子的情况，条件若为多个棋子则可转化为一个棋子的情况。 解答一个棋子棋子必须在临界层扔下的时候碎，所以唯一的策略是从1层往上逐层投掷，此时$T_{max} =99$，临界层为99层或100层（因为题目告诉100层肯定会碎，如果99层没碎，那表示临界层即为100） 两个棋子利用多的这个棋子缩小查找的范围，因而把100层分成若干段：先利用一个棋子来确定临界层所在的段，再利用另一个棋子确定临界层，总的投掷次数等于确定临界段的次数$n{1}$和确定临界层的次数$n{2}$的和现把100层平均分成n段（n是100的正因数），有$T{max}= (n-1) + \\frac{100}{n-1} = n + \\frac{100}{n}-2$由均值不等式可知n=10时，$T{max} =18$为最小值，此时临界段为第80~90层，临界层为第89层。如果把100层分成12段$(100=9\\times 11+1)$：1~9,10~18,…91~99,100,与上述n=10的情况相比虽然每段的层数在减少（从而$n{1}$在减少），但所分的段数在增加（从而$n{2}$在增加），因而$T{max}$并没有减少。如果把100层分成其他段（比如9段：$100=12\\times 8+4$，情况也是如此.根据上面的讨论，如何把100层合理地分段是关键。上述对100层所分段数的调整并没有使得$T{max} =18$减少的原因在于每段包含的层数比较均匀(图1)，因而出现$n{1}$和$n{2}$此消彼长的情况。鉴于此我们做出以下方式的调整：把100层分成若干段，从下往上，每段的层数逐渐少1（图2），这样就使得在最坏的情况下，$n{1}$增加1的同时$n{2}$减少1，因而$n{1}$与$n{2}$的总和不变（等于第一段的层数n）,为确定n的值，只需要解不等式$n+(n-1)+(n-2)+…+1\\geq 100$,从而得到n=14从第14层开始扔第一枚棋子，如果没有碎则从第14+13=27层开始扔，如果还没有碎则从14+13+12=39层开始扔，以此类推，此时$T_{max} =14$,临界层可为第27层，第39层，…第99层。 拓展：对于m层楼高，k个球的扔棋子问题，又该怎么做？答案是用动态规划的思想：如果是三个棋子，100层楼，我扔了一次棋子碎了以后，就变成2个棋子的问题了，因此可以利用上面的结果： $（x(x-1)/2+((x-1)(x-2)/2)+…+3+1&gt;=100. $ 推广从上面的讨论可以发现此题的关键是（高阶）等差数列：两个棋子：1 2 3 4 5… $ \\sum{i=1}^{n}{C{i}^{1} \\geq }100 $ !三个棋子：1 3 6 10 15…. $ \\sum{i=2}^{n}{C{i}^{2} }\\geq 100 $因而我们还可以考虑大楼有m层，棋子有k个的情况 $\\sum{ i=k}^{n}{C{i}^{k} } \\geq m$算法证明：对 $m$ 层楼，k个棋子的问题，存在复杂度为$O(\\sqrt[y]{m})$的算法。 thanks","categories":[{"name":"面试","slug":"面试","permalink":"https://ghostlo.github.io/categories/面试/"}],"tags":[{"name":"建模","slug":"建模","permalink":"https://ghostlo.github.io/tags/建模/"},{"name":"数学","slug":"数学","permalink":"https://ghostlo.github.io/tags/数学/"}]},{"title":"cookie 与 session 的区别","slug":"cookie-与-session-的区别","date":"2019-04-04T12:26:55.000Z","updated":"2019-04-04T12:29:05.000Z","comments":true,"path":"2019/04/04/cookie-与-session-的区别/","link":"","permalink":"https://ghostlo.github.io/2019/04/04/cookie-与-session-的区别/","excerpt":"","text":"原文链接：mp.weixin.qq.com 本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有一个更深入的了解，并对自己的开发工作中灵活运用带来启示。 cookie机制Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。 具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。 session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。 session机制session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。 Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。 不同1、存取方式的不同Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。 而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 2、隐私策略的不同Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。 假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。 3、有效期上的不同使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。 由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。 4、服务器压力的不同Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。 而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。 5、浏览器支持的不同Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。 假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。 假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干） 6、跨域支持上的不同Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。 仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。","categories":[],"tags":[]},{"title":"同步异步阻塞非阻塞","slug":"同步异步阻塞非阻塞","date":"2019-04-04T12:26:17.000Z","updated":"2019-04-04T12:26:41.000Z","comments":true,"path":"2019/04/04/同步异步阻塞非阻塞/","link":"","permalink":"https://ghostlo.github.io/2019/04/04/同步异步阻塞非阻塞/","excerpt":"","text":"同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事 异步：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕 阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。 有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。 非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 再简单点理解就是： 同步，就是我调用一个功能，该功能没有结束前，我死等结果。 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞 阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回 综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。","categories":[],"tags":[]},{"title":"Hexo 安装","slug":"安装-Hexo","date":"2019-04-04T11:38:48.000Z","updated":"2019-04-07T11:57:54.000Z","comments":true,"path":"2019/04/04/安装-Hexo/","link":"","permalink":"https://ghostlo.github.io/2019/04/04/安装-Hexo/","excerpt":"","text":"安装首先安装如下两个包 Node.js Git 安装好之后初次运行Git需要做一些配置：12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 文档 npm安装时改源npm 安装报错 rollbackFailedOptional verb npm-session 解决办法 npm config set registry http://registry.npm.taobao.org 建站Hexo安装好了之后，就开始进行建站。打开终端cd到桌面并使用如下命令即可建好 hexo init namecd name 常用参数 clean Remove generated files and cache. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. new Create a new post. server Start the server. deploy注意事项1:排查-&gt;是否安装一下hexo-deployer-git这个模块 没有安装:npm install hexo-deployer-git --save使用指令安装2:排查-&gt;_config.yml 这个文件的deploy写了没有;写全了没有 我的就是因为_config.yml中deploy下的type等前面没有空格导致。。。。。 hexo d 提示You should configure deployment settings in _config.yml first! 123deploy: type: repo: hexo d/deploy 时遇到问题再试一次，可能是用户名密码没有来得及输入，， 主题next主题 deploy后github上未显示主题If your site is put in a subdirectory, set url as ‘http://yoursite.com/child‘ and root as ‘/child/‘url: https://ghostlo.github.io/ostloroot: /ostlo/ 后续后续的修改只需要重复第5步就可以了，代码如下： 1234cd 本地库目录git add .git commit -m &quot;版本日志&quot;git push -u origin master Hexo 配置1 Hexo 配置2 GitHub还有很多好功能有待开发，善于利用搜索引擎，have fun~ 推荐阅读","categories":[{"name":"建站","slug":"建站","permalink":"https://ghostlo.github.io/categories/建站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ghostlo.github.io/tags/hexo/"}]}]}